# [Uniswap Docs](https://docs.uniswap.org/)

# Uniswap Overview

## Protocol, Interface, Labs

To begin, we should make clear the distinctions between the different areas of "Uniswap", some of which may confuse new users.

- **[Uniswap Labs](https://x.com/Uniswap)**: The company which developed the Uniswap protocol, along with the web interface.
- **[Uniswap Foundation](https://www.uniswapfoundation.org/)**: A non-profit organization that supports the development of the Uniswap protocol and its DeFi ecosystem.
- **[Uniswap Protocol](https://github.com/Uniswap/contracts)**: A suite of persistent, non-upgradable smart contracts that together create an automated market maker, a protocol that facilitates peer-to-peer market making and swapping of ERC-20 tokens on the Ethereum blockchain.
- **[Uniswap Interface](https://app.uniswap.org/)**: A web interface that allows for easy interaction with the Uniswap protocol. The interface is only one of many ways one may interact with the Uniswap protocol.
- **[Uniswap Governance](https://gov.uniswap.org/)**: A governance system for governing the Uniswap Protocol, enabled by the UNI token.

[Concepts](https://docs.uniswap.org/concepts/overview)[The Uniswap Protocol](https://docs.uniswap.org/concepts/uniswap-protocol)

# The Uniswap Protocol

## Introduction

The Uniswap protocol is a peer-to-peer[1](https://docs.uniswap.org/concepts/uniswap-protocol#user-content-fn-1) system designed for exchanging cryptocurrencies [(ERC-20 Tokens)](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) on the [Ethereum](https://ethereum.org/) blockchain. The protocol is implemented as a set of persistent, non-upgradable smart contracts; designed to prioritize censorship resistance, security, self-custody, and to function without any trusted intermediaries who may selectively restrict access.

There are currently four versions of the Uniswap protocol. [v1](https://docs.uniswap.org/contracts/v1/overview) and [v2](https://docs.uniswap.org/contracts/v2/overview) are open source and licensed under GPL. [v3](https://docs.uniswap.org/contracts/v3/overview) introduced concentrated liquidity and is open source with slight modifications, which are viewable [here](https://github.com/Uniswap/uniswap-v3-core/blob/main/LICENSE). [v4](https://docs.uniswap.org/contracts/v4/overview) introduces the singleton pool architecture and hooks system, enabling unprecedented protocol customization, and uses a dual license structure viewable [here](https://github.com/Uniswap/v4-core/tree/main/licenses). Each version of Uniswap, once deployed, will function in perpetuity, with 100% uptime, provided the continued existence of the Ethereum blockchain.

## How does the Uniswap protocol compare to a typical market?

To understand how the Uniswap protocol differs from a traditional exchange, it is helpful to first look at two subjects: how the Automated Market Maker design deviates from traditional central limit order book-based exchanges, and how permissionless systems depart from conventional permissioned systems.

### Order Book VS AMM

Most publicly accessible markets use a central limit [order book](https://www.investopedia.com/terms/o/order-book.asp) style of exchange, where buyers and sellers create orders organized by price level that are progressively filled as demand shifts. Anyone who has traded stocks through brokerage firms will be familiar with an order book system.

The Uniswap protocol takes a different approach, using an Automated Market Maker (AMM), sometimes referred to as a Constant Function Market Maker, in place of an order book. Through its evolution, the protocol has enhanced this model: [v3](https://docs.uniswap.org/contracts/v3/overview) introduced concentrated liquidity for capital efficiency, and [v4](https://docs.uniswap.org/contracts/v4/overview)'s singleton pool architecture and hooks system enable unprecedented customization of pool behavior while maintaining the core AMM principles.

At a very high level, an AMM replaces the buy and sell orders in an order book market with a liquidity pool of two assets, both valued relative to each other. As one asset is traded for the other, the relative prices of the two assets shift, and a new market rate for both is determined. In this dynamic, a buyer or seller trades directly with the pool, rather than with specific orders left by other parties. The advantages and disadvantages of Automated Market Makers versus their traditional order book counterparts are under active research by a growing number of parties. We have collected some notable examples on our [research page](https://docs.uniswap.org/concepts/research).

### Permissionless Systems

The second departure from traditional markets is the permissionless and immutable design of the Uniswap protocol. These design decisions were inspired by Ethereum's core tenets, and our commitment to the ideals of permissionless access and immutability as indispensable components of a future in which anyone in the world can access financial services without fear of discrimination or counter-party risk.

Permissionless design means that the protocol's services are entirely open for public use, with no ability to selectively restrict who can or cannot use them. Anyone can swap, provide liquidity, or create new markets at will. This is a departure from traditional financial services, which typically restrict access based on geography, wealth status, and age.

The protocol is also immutable, in other words not upgradeable. No party is able to pause the contracts, reverse trade execution, or otherwise change the behavior of the protocol in any way. It is worth noting that Uniswap Governance has the right (but no obligation) to divert a percentage of swap fees on any pool to a specified address. However, this capability is known to all participants in advance, and to prevent abuse, the percentage is constrained between 10% and 25%.

## Where can I find more information

For research into the economics of AMMs, game theory, or optimization research, check out our [research](https://docs.uniswap.org/concepts/research) page.

For features implemented in v3 that expand and refine the AMM design, see the [v3 Concepts](https://docs.uniswap.org/concepts/protocol/concentrated-liquidity) page.

For the latest innovations in v4, including singleton pools and hooks, see the [v4 Concepts](https://docs.uniswap.org/concepts/protocol/hooks) page.

## Footnotes

1. Ethereum protocols are sometimes referred to as peer-to-contract systems as well. These are similar to a peer-to-peer systems, but with immutable, persistent programs known as smart contracts taking the place of a peer. [↩](https://docs.uniswap.org/concepts/uniswap-protocol#user-content-fnref-1)

[Concepts](https://docs.uniswap.org/concepts/overview)Protocol Concepts[Hooks](https://docs.uniswap.org/concepts/protocol/hooks)

# Hooks

## Introduction

Uniswap v4 inherits all of the capital efficiency gains of Uniswap v3 while introducing major architectural improvements.

The key innovations are the Hook System and Singleton Architecture, which together enable unprecedented protocol customization and gas optimization.

## Hooks

Hooks allow developers to customize and extend the behavior of liquidity pools. They are external smart contracts that can be attached to individual pools to intercept and modify the execution flow at specific points during pool-related actions.

The logic is executed before and/or after major operations such as pool creation, liquidity addition and removal, swapping, and donations.

Through these hook functions, developers can build sophisticated features like custom AMMs with different pricing curves, yield farming protocols, advanced trading features including limit orders, dynamic fee strategies, and custom oracle implementations. Each pool can have one hook (though a hook can serve multiple pools), hooks are optional and specified during pool creation, and developers can implement any combination of hook functions based on their needs.

## Singleton Architecture

The hook system in v4 is built on top of a revolutionary architectural change known as the singleton design. Unlike previous versions where each pool was a separate smart contract, v4 manages all pools through a single contract called the [PoolManager](https://docs.uniswap.org/contracts/v4/concepts/PoolManager). This architectural innovation brings several key improvements:

- **Efficient Pool Creation**: Pools are created as state updates rather than contract deployments, significantly reducing gas costs
- **Gas Optimization**: Multi-hop swaps and complex operations are streamlined through a single contract
- **Flash Accounting**: Token balances are tracked internally and settled at the end of transactions, minimizing transfers
- **Native ETH Support**: Direct ETH trading without the need to wrap to WETH, improving user experience

These core features are just the beginning of what's possible with Uniswap v4.

To explore all features including flash accounting, native ETH support, dynamic fees, and custom accounting, check out the [v4 whitepaper](https://uniswap.org/whitepaper-v4.pdf).

For technical implementations and detailed guides, visit the [v4 technical documentation](https://docs.uniswap.org/contracts/v4/overview).



# Swaps

## Introduction

Swaps are the most common way of interacting with the Uniswap protocol. For end-users, swapping is straightforward: a user selects an ERC-20 token that they own and a token they would like to trade it for. Executing a swap sells the currently owned tokens for the proportional[1](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fn-1) amount of the tokens desired, minus the swap fee, which is awarded to liquidity providers[2](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fn-2). Swapping with the Uniswap protocol is a permissionless process.

> note: Using web interfaces (websites) to swap via the Uniswap protocol can introduce additional permission structures, and may result in different execution behavior compared to using the Uniswap protocol directly. To learn more about the differences between the protocol and a web interface, see What is Uniswap.

Swaps using the Uniswap protocol are different from traditional order book trades in that they are not executed against discrete orders on a first-in-first-out basis — rather, swaps execute against a passive pool of liquidity, with liquidity providers earning fees proportional to their capital committed

## Price Impact

In a traditional order-book market, a sizeable market-buy order may deplete the available liquidity of a prior limit-sell and continue to execute against a subsequent limit-sell order at a higher price. The result is the final execution price of the order is somewhere in between the two limit-sell prices against which the order was filled.

Price impact affects the execution price of a swap similarly but is a result of a different dynamic. When using an automated market maker, the relative value of one asset in terms of the other continuously shifts during the execution of a swap, leaving the final execution price somewhere between where the relative price started - and ended.

This dynamic affects every swap using the Uniswap protocol, as it is an inextricable part of AMM design.

As the amount of liquidity available at different price points can vary, the price impact for a given swap size will change relative to the amount of liquidity available at any given point in price space. The greater the liquidity available at a given price, the lower the price impact for a given swap size. The lesser the liquidity available, the higher the price impact.

Approximate[3](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fn-3) price impact is anticipated in real-time via the Uniswap interface, and warnings appear if unusually high price impact will occur during a swap. Anyone executing a swap will have the ability to assess the circumstances of price impact when needed.

## Slippage

The other relevant detail to consider when approaching swaps with the Uniswap protocol is slippage. Slippage is the term we use to describe alterations to a given price that could occur while a submitted transaction is pending.

When transactions are submitted to Ethereum, their order of execution is established by the amount of "gas" offered as a fee for executing each transaction. The higher the fee offered, the faster the transaction is executed. The transactions with a lower gas fee will remain pending for an indeterminate amount of time. During this time, the price environment in which the transaction will eventually be executed will change, as other swaps will be taking place.

Slippage tolerances establish a margin of change acceptable to the user beyond price impact. As long as the execution price is within the slippage range, e.g., 1%, the transaction will be executed. If the execution price ends up outside of the accepted slippage range, the transaction will fail, and the swap will not occur.

A comparable situation in a traditional market would be a market-buy order executed after a delay. One can know the expected price of a market-buy order when submitted, but much can change in the time between submission and execution.

## Safety Checks

Price impact and slippage can both change while a transaction is pending, which is why we have built numerous safety checks into the Uniswap protocol to protect end-users from drastic changes in the execution environment of their swap. Some of the most commonly encountered safety checks:

- **Expired** : A transaction error that occurs if a swap is pending longer than a predetermined deadline. The deadline is a point in time after which the swap will be canceled to protect against unusually long pending periods and the changes in price that typically accompany the passage of time.
- **INSUFFICIENT_OUTPUT_AMOUNT** : When a user submits a swap, the Uniswap interface will send an estimate of how much of the purchased token the user should expect to receive. If the anticipated output amount of a swap does not match the estimate within a certain margin of error (the slippage tolerance), the swap will be canceled. This attempts to protect the user from any drastic and unfavorable price changes while their transaction is pending.

## Footnotes

1. Proportional in this instance takes into account many factors, including the relative price of one token in terms of the other, slippage, price impact, and other factors related to the open and adversarial nature of Ethereum. [↩](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fnref-1)
2. For information about liquidity provision, see the liquidity user guide [↩](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fnref-2)
3. The Uniswap interface informs the user about the circumstances of their swap, but it is not guaranteed. [↩](https://docs.uniswap.org/concepts/protocol/swaps#user-content-fnref-3)

# Fees

note

While v3 uses predefined fee tiers (0.01%, 0.05%, 0.3%, and 1%), v4 introduces flexible fees that can range from 0% to 100%, offering greater customization options for pools.

## Swap Fees

Swap fees are distributed pro-rata to all in-range[1](https://docs.uniswap.org/concepts/protocol/fees#user-content-fn-1) liquidity at the time of the swap. If the spot price moves out of a position’s range, the given liquidity is no longer active and does not generate any fees. If the spot price reverses and reenters the position’s range, the position’s liquidity becomes active again and will generate fees.

Swap fees are not automatically reinvested as they were in previous versions of Uniswap. Instead, they are collected separately from the pool and must be manually redeemed when the owner wishes to collect their fees.

## Pool Fees Tiers

Uniswap v3 introduces multiple pools for each token pair, each with a different swapping fee. Liquidity providers may initially create pools at three fee levels: 0.05%, 0.30%, and 1%. More fee levels may be added by UNI governance, e.g. the 0.01% fee level added by [this](https://vote.uniswapfoundation.org/proposals/9) governance proposal in December 2021, as executed [here](https://etherscan.io/tx/0x5c84f89a67237db7500538b81af61ebd827c081302dd73a1c20c8f6efaaf4f3c).

Breaking pairs into separate pools was previously untenable due to the issue of liquidity fragmentation. Any incentive alignments achieved by more fee optionality invariably resulted in a net loss to traders, due to lower pairwise liquidity and the resulting increase in price impact upon swapping.

The introduction of concentrated liquidity decouples total liquidity from price impact. With price impact concerns out of the way, breaking pairs into multiple pools becomes a feasible approach to improving the functionality of a pool for assets previously underserved by the 0.30% swap fee.

## Finding The Right Pool Fee

We anticipate that certain types of assets will gravitate towards specific fee tiers, based on where the incentives for both swappers and liquidity providers come nearest to alignment.

We expect low volatility assets (stable coins) will likely congregate in the lowest fee tier, as the price risk for liquidity providers holding these assets is very low, and those swapping will be motivated to pursue an execution price closest to 1:1 as they can get.

Similarly, we anticipate more exotic assets, or those traded rarely, will naturally gravitate towards a higher fee - as liquidity providers will be motivated to offset the cost risk of holding these assets for the duration of their position.

## Protocol Fees

Both Uniswap v3 and v4 include a protocol fee mechanism that can be activated through UNI governance. This fee structure offers greater flexibility compared to v2, allowing governance to adjust the fraction of swap fees allocated to the protocol. For detailed information about protocol fees, refer to the [v3 whitepaper](https://uniswap.org/whitepaper-v3.pdf) and [v4 whitepaper](https://uniswap.org/whitepaper-v4.pdf).

## Footnotes

1. In-range liquidity refers to the liquidity contained in any positions which span both sides of the spot price. [↩](https://docs.uniswap.org/concepts/protocol/fees#user-content-fnref-1)

# Oracle

note

Uniswap v4 does not include built-in oracle functionality. If you're unfamiliar with oracles, check out the Ethereum Foundation's [oracle overview](https://ethereum.org/en/developers/docs/oracles/).

All Uniswap v3 pools can serve as oracles, offering access to historical price and liquidity data. This capability unlocks a wide range of on-chain use cases.

Historical data is stored as an array of observations. At first, each pool tracks only a single observation, overwriting it as blocks elapse. This limits how far into the past users may access data. However, any party willing to pay the transaction fees may [increase the number of tracked observations](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Pool#increaseobservationcardinalitynext) (up to a maximum of `65535`), expanding the period of data availability to ~9 days or more.

Storing price and liquidity history directly in the pool contract substantially reduces the potential for logical errors on the part of the calling contract, and reduces integration costs by eliminating the need to store historical values. Additionally, the v3 oracle's considerable maximum length makes oracle price manipulation significantly more difficult, as the calling contract may cheaply construct a time-weighted average over any arbitrary range inside of (or fully encompassing) the length of the oracle array.

## Observations

`Observation`s take the following form:

```solidity
struct Observation {
    // the block timestamp of the observation
    uint32 blockTimestamp;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    int56 tickCumulative;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    uint160 secondsPerLiquidityCumulativeX128;
    // whether or not the observation is initialized
    bool initialized;
}
```



`Observation`s may be retrieved via the [`observations`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState#observations) method on v3 pools. However, this is *not* the recommended way to consume oracle data. Instead, prefer [`observe`](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Pool#observe):

```solidity
function observe(uint32[] calldata secondsAgos)
    external
    view
    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
```



Each time `observe` is called, the caller must specify an array containing any number of seconds ago, denoting the times to return observations from. Note that each of the given times must be more recent (or as old as) the oldest stored observation. Note: if the times don't correspond exactly to a block in which an observation was written, a counterfactual observation will be constructed, removing the need for the caller to interpolate manually. This is one of the primary reasons to use `observe` over `observations`.

Note that because the oracle is only updated at most once every block, calling `observe` with a `secondsAgo` value of `0` will return the most recently written observation, which can only be as recent as the beginning of the current block (or older).

## Tick Accumulator

The tick accumulator stores the cumulative sum of the active tick at the time of the observation. The tick accumulator value increases monotonically and grows by the value of the current tick - per second.

To derive the arithmetic mean tick over an interval, the caller needs to retrieve two observations, one after the other, take the delta of the two values, and divide by the time elapsed between them. Calculating a TWAP from the tick accumulator is also covered in the [**whitepaper**](https://uniswap.org/whitepaper-v3.pdf). Note that using an arithmetic mean tick to derive a price corresponds to a *geometric* mean price.

See [OracleLibrary](https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol) for an example of how to use the tick accumulator.

## Liquidity Accumulator

The liquidity accumulator stores the value of seconds / in-range liquidity at the time of the observation. The liquidity accumulator value increases monotonically and grows by the value of seconds / in-range liquidity - per second.

To derive the harmonic mean liquidity over an interval, the caller needs to retrieve two observations, one after the other, take the delta of the two values, then divide the time elapsed by this value. Calculating TWAL is addressed in finer detail in the [**whitepaper**](https://uniswap.org/whitepaper-v3.pdf).

note

The in-range liquidity accumulator should be used with care. Because the current tick and the current in-range liquidity can be entirely uncorrelated, there are scenarios in which taking the arithmetic mean tick and the harmonic mean liquidity over the same interval in a pool can inaccurately characterize this pool relative to another. For example, if the current tick on pool A is 0 for 5 seconds, and 100 for 5 seconds, the tick accumulator will be 50. If over this same interval, the in-range liquidity was 5000 and 50, the harmonic mean liquidity will be ~99. Compare this to pool B (composed of the same assets) where the tick was 50 and the in-range liquidity was ~99 for 10 seconds. The accumulator values will be identical, but the underlying behavior is of course quite different.

## Deriving Price From A Tick

> When we use "active tick" or otherwise to refer to the current tick of a pool, we mean the lower tick boundary that is closest to the current price.

When a pool is created, each token is assigned to either `token0` or `token1` based on the contract address of the tokens in the pair. Whether or not a token is `token0` or `token1` is meaningless; it is only used to maintain a fixed assignment for the purpose of relative valuation and general logic in the pool contract.

Deriving an asset price from the current tick is achievable due to the fixed expression across the pool contract of token0 in terms of token1.

------

An example of finding the price of WETH in a WETH / USDC pool, where WETH is `token0` and USDC is `token1`:

You have an oracle reading that shows a return of `tickCumulative` as [`70_000`, `1_070_000`], with an elapsed time between the observations of 10 seconds.

We can derive the average tick over this interval by taking the difference in accumulator values (`1_070_000` - `70_000` = `1_000_000`), and dividing by the time elapsed (`1_000_000` / `10` = `100_000`).

With a tick reading of `100_000`, we can find the value of `token1` (USDC) in terms of `token0` (WETH) by using the current tick as `i` in the formula `p(i) = 1.0001**i` (see 6.1 in the [whitepaper](https://uniswap.org/whitepaper-v3.pdf)).

`1.0001**100_000 ≅ 22015.5` USDC / WETH

------

Ticks are signed integers and can be expressed as a negative number, so for any circumstances where `token0` is of a lower value than `token1`, a negative tick value will be returned by `tickCumulative` and a relative value of `< 0` will be returned by a calculation of `token0` in terms of `token1`.

## Oracles Integrations on Layer 2 Rollups

### Arbitrum One

On Arbitrum One, multiple transactions can be part of a block, and [multiple blocks](https://arbiscan.io/blocks) are usually created per second (up to a maximum of 4 blocks per second). Their `block.timestamp` reflect the time at which the block was produced based on the sequencer's clock (see [Arbitrum's sequencer documentation](https://docs.arbitrum.io/sequencer) to learn more about its trust assumptions), so observations have enough granularity to make the oracle more difficult to manipulate. Thus, Uniswap pools on Arbitrum One are suitable for providing oracle prices. For more information on how block numbers and time work on Arbitrum One, please see the [Arbitrum documentation portal](https://docs.arbitrum.io/time).



# Range Orders

note

Range orders have the same implementation in both Uniswap v3 and v4, offering consistent functionality across both versions.

Customizable liquidity positions, along with single-sided asset provisioning, allow for a new style of swapping with automated market makers: the range order.

In typical order book markets, anyone can easily set a limit order: to buy or sell an asset at a specific predetermined price, allowing the order to be filled at an indeterminate time in the future.

With Uniswap v3, one can approximate a limit order by providing a single asset as liquidity within a specific range. Like traditional limit orders, range orders may be set with the expectation they will execute at some point in the future, with the target asset available for withdrawal after the spot price has crossed the full range of the order.

Unlike some markets where limit orders may incur fees, the range order maker generates fees while the order is filled. This is due to the range order technically being a form of liquidity provisioning rather than a typical swap.

## Possibilities of Range orders

The nature of AMM design makes some styles of limit orders possible, while others cannot be replicated. The following are four examples of range orders and their traditional counterparts; the first two are possible, the second two are not.

> One important distinction: range orders, unlike traditional limit orders, will be **unfilled** if the spot price crosses the given range and then reverses to recross in the opposite direction before the target asset is withdrawn. While you will be earning LP fees during this time, if the goal is to exit fully in the desired destination asset, you will need to keep an eye on the order and either manually remove your liquidity when the order has been filled or use a third party position manager service to withdraw on your behalf.

### Take-Profit Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You would like to sell your ETH for DAI when the price of ETH reaches 1,600 DAI / ETH. This is possible, as the price space above the spot price is denominated in the higher valued asset, ETH. You can provide ETH at a price of 1,600 DAI / ETH and have the order filled when the spot price crosses your position.

![RangeOrder1](https://docs.uniswap.org/assets/images/RangeOrder1-b9d8771ff290b67b408790362ac6838e.png)

​    

![RangeOrder1](https://docs.uniswap.org/assets/images/RangeOrder2-9578c6d42b3b8d3d062d0956aee84f1c.png)

------

### Buy Limit Orders

> The Current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect that ETH will rebound after it drops to 1,000 at the next market downturn, so you would like to place a range order swapping DAI to ETH at the price of 1,000 DAI / ETH. This is possible, as the price space below the spot price is denominated in the lower-priced asset, DAI. You can provide DAI at the price of 1,000 DAI / ETH, which will be swapped for ETH when the spot price of ETH drops past 1,000 DAI / ETH.

As the above examples show, in Uniswap v3, the two paired assets in a given pool are separated above and below the spot price, with the higher price asset available above the spot price and the lower-priced asset below.

The following examples show limit order styles that are unable to be replicated due to the separation of assets in price space.

------

### Buy Stop Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect the price of ETH to rocket up to 3,000 once it hits 2,000 DAI/ ETH, So you would like to place a range order from DAI to ETH at a price of 2,000 DAI/ETH. This is not possible as the price space above 1,500 DAI / ETH is denominated in ETH - and thus, you cannot provide the DAI necessary at your desired price to be swapped into ETH.

------

### Stop-Loss Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect once the price of ETH drops to below 1,000, it will tank to 200. So you would like to place a range order from ETH to DAI at a price of 1,000. This is not possible as the price space below the spot price is denominated in DAI, and so you cannot allocate the ETH necessary at 1,000 to be swapped into DAI.

------

## Fees

The fees due to your liquidity position will be denominated in both tokens of the given pair. In any of the above examples, after swapping ETH for DAI, or DAI for ETH, a small amount of both ETH and DAI will be due to your account as liquidity provisioning rewards.

Approaches to concentration when setting range orders are up to the user. Selecting a wider range may generate more fees if there is price churn within your range, at the cost of increasing the risk of having your order unfilled if the spot price reverses before completing your full range.



# Concentrated Liquidity

<video width="100%" height="100%" playsinline="" controls="" loop="" style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ;"></video>

------

note

Concentrated liquidity, first introduced as a native feature in Uniswap v3, maintains the same core implementation in v4, ensuring consistency in how liquidity providers can focus their capital.

## Introduction

The defining idea of Uniswap v3 is concentrated liquidity: liquidity that is allocated within a custom price range. In earlier versions, liquidity was distributed uniformly along the price curve between 0 and infinity.

The previously uniform distribution allowed trading across the entire price interval (0, ∞) without any loss of liquidity. However, in many pools, the majority of the liquidity was never used.

Consider stablecoin pairs, where the relative price of the two assets stays relatively constant. The liquidity outside the typical price range of a stablecoin pair is rarely touched. For example, the v2 DAI/USDC pair utilizes ~0.50% of the total available capital for trading between $0.99 and $1.01, the price range in which LPs would expect to see the most volume - and consequently earn the most fees.

With v3, liquidity providers may concentrate their capital to smaller price intervals than (0, ∞). In a stablecoin/stablecoin pair, for example, an LP may choose to allocate capital solely to the 0.99 - 1.01 range. As a result, traders are offered deeper liquidity around the mid-price, and LPs earn more trading fees with their capital. We call liquidity concentrated to a finite interval a position. LPs may have many different positions per pool, creating individualized price curves that reflect the preferences of each LP.

## Active Liquidity

As the price of an asset rises or falls, it may exit the price bounds that LPs have set in a position. When the price exits a position's interval, the position's liquidity is no longer active and no longer earns fees.

As price moves in one direction, LPs gain more of the one asset as swappers demand the other, until their entire liquidity consists of only one asset. (In v2, we don't typically see this behavior because LPs rarely reach the upper or lower bound of the price of two assets, i.e., 0 and ∞). If the price ever reenters the interval, the liquidity becomes active again, and in-range LPs begin earning fees once more.

Importantly, LPs are free to create as many positions as they see fit, each with its own price interval. Concentrated liquidity serves as a mechanism to let the market decide what a sensible distribution of liquidity is, as rational LPs are incentivized to concentrate their liquidity while ensuring that their liquidity remains active.

## Ticks

To achieve concentrated liquidity, the once continuous spectrum of price space has been partitioned with ticks.

Ticks are the boundaries between discrete areas in price space. Ticks are spaced such that an increase or decrease of 1 tick represents a 0.01% increase or decrease in price at any point in price space.

Ticks function as boundaries for liquidity positions. When a position is created, the provider must choose the lower and upper tick that will represent their position's borders.

As the spot price changes during swapping, the pool contract will continuously exchange the outbound asset for the inbound, progressively using all the liquidity available within the current tick interval[1](https://docs.uniswap.org/concepts/protocol/concentrated-liquidity#user-content-fn-1) until the next tick is reached. At this point, the contract switches to a new tick and activates any dormant liquidity within a position that has a boundary at the newly active tick.

While each pool has the same number of underlying ticks, in practice only a portion of them are able to serve as active ticks. Due to the nature of the v3 smart contracts, tick spacing is directly correlated to the swap fee. Lower fee tiers allow closer potentially active ticks, and higher fees allow a relatively wider spacing of potential active ticks.

While inactive ticks have no impact on transaction cost during swaps, crossing an active tick does increase the cost of the transaction in which it is crossed, as the tick crossing will activate the liquidity within any new positions using the given tick as a border.

In areas where capital efficiency is paramount, such as stable coin pairs, narrower tick spacing increases the granularity of liquidity provisioning and will likely lower price impact when swapping - the result being significantly improved prices for stable coin swaps.

For more information on fee levels and their correlation to tick spacing, see the [whitepaper](https://uniswap.org/whitepaper-v3.pdf).

## Footnotes

1. Tick interval refers to the area of price space between two nearest active ticks [↩](https://docs.uniswap.org/concepts/protocol/concentrated-liquidity#user-content-fnref-1)

# Token Integration Issues

Fee-on-transfer and rebasing tokens will not function correctly on v3.

## Fee-on-transfer Tokens

Fee-on-transfer tokens will not function with our router contracts. As a workaround, the token creators may create a token wrapper or a customized router. We will not be making a router that supports fee-on-transfer tokens in the future.

## Rebasing Tokens

Rebasing tokens will succeed in pool creation and swapping, but liquidity providers will bear the loss of a negative rebase when their position becomes active, with no way to recover the loss.



[Concepts](https://docs.uniswap.org/concepts/overview)Governance[Overview](https://docs.uniswap.org/concepts/governance/overview)

# Overview

## Code

[`governance`](https://github.com/Uniswap/governance)

## UNI Address

`UNI` is deployed at `0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984` on the Ethereum [mainnet](https://etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), and the [Ropsten](https://ropsten.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), [Rinkeby](https://rinkeby.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), [Görli](https://goerli.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), and [Kovan](https://kovan.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

```typescript
import Uni from '@uniswap/governance/build/Uni.json'
```



https://unpkg.com/@uniswap/governance@1.0.2/build/Uni.json

## Timelock

`Timelock` is deployed at `0x1a9C8182C09F50C8318d769245beA52c32BE35BC` on the Ethereum [mainnet](https://etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), and the [Ropsten](https://ropsten.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), [Rinkeby](https://rinkeby.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), [Görli](https://goerli.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), and [Kovan](https://kovan.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

```typescript
import Timelock from '@uniswap/governance/build/Timelock.json'
```



https://unpkg.com/@uniswap/governance@1.0.2/build/Timelock.json

## GovernorAlpha (Deprecated)

`GovernorAlpha` is deployed at `0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F` on the Ethereum [mainnet](https://etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), and the [Ropsten](https://ropsten.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), [Rinkeby](https://rinkeby.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), [Görli](https://goerli.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), and [Kovan](https://kovan.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

The `GovernorAlpha` ABI is viewable on [Etherscan](https://etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), as well as via an [npm package](https://www.npmjs.com/package/@uniswap/governance).

https://unpkg.com/@uniswap/governance@1.0.2/build/GovernorAlpha.json

```typescript
import GovernorAlpha from '@uniswap/governance/build/GovernorAlpha.json'
```



## GovernorAlpha v2 (Deprecated)

`GovernorAlpha v2` is deployed at `0xC4e172459f1E7939D522503B81AFAaC1014CE6F6` on the Ethereum [mainnet](https://etherscan.io/address/0xC4e172459f1E7939D522503B81AFAaC1014CE6F6).

### ABI

The `GovernorAlpha v2` ABI is viewable on [Etherscan](https://etherscan.io/address/0xC4e172459f1E7939D522503B81AFAaC1014CE6F6)

## GovernorBravo (Current)

`GovernorBravo` is deployed at `0x408ED6354d4973f66138C91495F2f2FCbd8724C3` on the Ethereum [mainnet](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#code).

### ABI

The Governor Bravo ABI can be found on [Etherscan](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#code).

## Miscellaneous Addresses

**The following addresses only exist on the Ethereum mainnet.**

The UNI merkle distributor address is `0x090D4613473dEE047c3f2706764f49E0821D256e`.

The staking rewards factory address is `0x3032Ab3Fa8C01d786D29dAdE018d7f2017918e12`.

The four staking rewards addresses are:

```js
0x6c3e4cb2e96b01f4b866965a91ed4437839a121a
0x7fba4b8dc5e7616e59622806932dbea72537a56b
0xa1484c3aa22a66c62b77e0ae78e15258bd0cb711
0xca35e32e7926b96a9988f61d510e038108d8068e
```



The four year-long vesting contract addresses are:

```js
0x4750c43867ef5f89869132eccf19b9b6c4286e1a
0xe3953d9d317b834592ab58ab2c7a6ad22b54075d
0x4b4e140d1f131fdad6fb59c13af796fd194e4135
0x3d30b1ab88d487b0f3061f40de76845bec3f1e94
```



The `feeToSetterVester` address is `0x18e433c7Bf8A2E1d0197CE5d8f9AFAda1A771360`.

The `feeTo` address is `0xDAF819c2437a82f9e01f6586207ebF961a7f0970`.



# Process

This is a living document which represents the current process guidelines for developing and advancing Uniswap Governance Proposals. It was last updated September 2024.

## Tools

Uniswap Governance takes place in several venues. Each serves its own particular purpose.

1. [*Governance Forum*](https://gov.uniswap.org/)

A Discourse-hosted forum for governance-related discussion. Community members must register for an account before sharing or liking posts. New members must read 4 topics and a combined 15 posts over the course of at least 10 minutes before they may post themselves.

1. [*Snapshot*](https://snapshot.box/#/s:uniswapgovernance.eth)

A simple voting interface that allows users to signal sentiment off-chain. Votes on Snapshot are weighted by the number of UNI delegated to the address used to vote.

1. [*Uniswap Agora*](https://vote.uniswapfoundation.org/)

The [Uniswap Foundation](https://www.uniswapfoundation.org/) supports this voting and delegation interface. [Tally](https://www.tally.xyz/gov/uniswap) is another excellent app that supports proposal creation, delegation, and voting.

## Process

Below we outline the current Uniswap governance process, detailing where these venues fit in. These processes are subject to change according to feedback from the Uniswap community.

### Phase 1: Request for Comment (RFC)

*Timeframe*: At least 7 days

*Form*: [Governance Forum](https://gov.uniswap.org/) Post

As a proposer, you should use the RFC phase to introduce the community to your proposal. Your post should detail exactly what you are asking delegates to vote on as well as your rationale for why it is a good idea. You should be prepared to answer questions about your proposal. Willingness to adjust based on community feedback is a hallmark of successful past proposals.

To post a RFC, label your post “RFC - [Your Title Here]”. Prior to moving to Phase 2, give the community at least 7 days to read and comment on the RFC. Please respond to questions in the comments, and take feedback into account in the next iteration of the proposal posted in Phase 2.

### Phase 2: Temperature Check

*Timeframe*: 5 days

*Quorum*: 10M UNI

*Form*: [Snapshot Poll](https://snapshot.box/#/s:uniswapgovernance.eth)

The purpose of the Temperature Check is to signal community sentiment on a proposal prior to moving towards an onchain vote.

To create a Temperature Check:

1. Incorporate the community feedback from the RFC phase into the proposal.
2. Create and post this version of the proposal in the [Governance Forum](https://gov.uniswap.org/) with the title “Temperature Check — [Your Title Here]”. Include a link to the RFC post. You will update the post to include a link to the Snapshot poll after you’ve posted that.
3. Create a [Snapshot poll](https://snapshot.box/#/s:uniswapgovernance.eth). The voting options should consist of those which have gained support in the RFC Phase. This poll can be either binary or multiple choice but must include a `No change` option. Set the poll duration to 5 days. Include a link to the Forum Temperature Check post.
4. Update the Forum post with a link to the Snapshot Poll.

At the end of 5 days, the option with the majority of votes wins. There must be at least 10M UNI `Yes` votes to move onto Phase 3. If the “No change” option wins, the proposal will not move onto the Phase 3.

### Phase 3: Governance Proposal

*Timeframe*: 2 day waiting period, 7 day voting period, 2 day timelock

*Threshold*: 1M UNI

*Quorum*: 40M UNI votes in favor

Form: [Governance Proposal](https://vote.uniswapfoundation.org/)

![img](https://docs.uniswap.org/assets/images/Proposal_Flow-8ca9bfffde99de9627f7b352a5578936.png)

Phase 3 is the final step of the governance process. If this vote passes, then a change will be enacted onchain.

To create an onchain Governance Proposal:

1. Incorporate any last iterations to your proposal based on feedback prior to posting.
2. Create a topic in the [Governance Forum](https://gov.uniswap.org/) titled "Governance Proposal — [Your Title Here]" and link to previous forum posts and the Temperature Check Snapshot poll.
3. Create your proposal. This can be done either through an interface (e.g. [Tally](https://tally.xyz/gov/uniswap)) or through writing the calldata for more complicated proposal logic. If the proposal passed, this calldata will execute. If writing the calldata yourself, please review the logic with a qualified Uniswap community member prior to posting the proposal.
4. Ensure that at least 1 million UNI is delegated to your address in order to submit a proposal, or find a delegate who has enough delegated UNI to meet the proposal threshold to propose on your behalf.
5. Once you submit the proposal, a two-day voting delay will start. After the voting delay finishes, a ~seven-day voting period begins. If the proposal passes, a two-day timelock must pass before you can execute the proposed code.

## Changes to the Governance Process

Timeframe: 7 days

*Quorum*: 40M UNI

Form: [Snapshot Poll](https://snapshot.box/#/s:uniswapgovernance.eth)

In the future, the community governance process above may need to undergo additional changes to continue to meet the needs of the Uniswap community. While an onchain vote is not required to change the majority of this process, a clear display of community support and acceptance is important for process changes to have legitimacy.

Thus, changes to all off-chain community governance processes should be voted on through an off-chain Snapshot vote. There should be a 7-day voting period and 40M UNI quorum.



# Beginners' Guide to Voting

This guide contains everything you need to start voting in Uniswap Governance.

To participate you will need:

- [UNI Tokens](https://uniswap.org/blog/uni/)
- ETH for transaction costs
- A wallet that supports the Ethereum protocol and holds UNI tokens. (We suggest the [Uniswap wallet](https://wallet.uniswap.org/)).
- To [delegate](https://docs.uniswap.org/concepts/governance/guide-to-voting#delegation) your tokens before the vote is active.

The governance [process](https://docs.uniswap.org/concepts/governance/02-process.md) begins in the [Governance Forum](https://gov.uniswap.org/), where you can find proposals under consideration, gather information about community sentiment, and engage with the community.

Once a given proposal is ready for an onchain vote, it will appear in the Uniswap [voting dashboard](https://vote.uniswapfoundation.org/) - where you can view all current and former Uniswap proposals.

![img](https://docs.uniswap.org/assets/images/Proposals_Overview-45a7f1bc8cab6113e2f7388e7621b3ea.png)

Clicking a proposal will show all the necessary information, documentation, and discussion needed for a voter to make an informed decision, and help visualize how the voting transpired.

![img](https://docs.uniswap.org/assets/images/Proposal_Active-cabd5b3b1c61959b9b5969d4e59e2e6b.png)

***Once a proposal has reached the voting stage it represents real, executable code which will alter the functionality of Uniswap Governance or anything under its jurisdiction. Proper care should be taken to ensure that the code represented in the proposal has been audited and is found to be in good faith.***

## Delegation

UNI is a tradable asset and functions like most other standard ERC20 tokens, except it has a deeper power as a voting mechanism. In order for UNI to be used as a vote, the owner must first go through the delegation process. Delegating UNI binds the voting power of your tokens to an address so it may be used to vote. This address could be yourself, or a trusted party who you believe will vote in the best interest of Uniswap Governance.

To submit a proposal, an address must have 1,000,000 UNI delegated to it.

For a proposal to pass, 40,000,000 UNI (from any number of addresses) must vote on it, and the majority must be in favor.

To delegate your UNI tokens, visit the [Uniswap voting dashboard](https://vote.uniswapfoundation.org/delegates). Connect your Wallet, browse delegates, and click "Delegate" on your chosen delegate.

![img](https://docs.uniswap.org/assets/images/Delegate_Selection-b37109958d87602455383f332d1eb3bf.png)

![img](https://docs.uniswap.org/assets/images/Delegate_Button-5bf388398ee481d5a91efe52b75c591a.png)

You can also delegate to yourself if you wish to participate in voting directly. After connecting your wallet, click your wallet address, then "view my profile." From there, you can click "Delegate" on your own profile to delegate your voting power to yourself.

Once you click this button, you will see a screen that gives you the option to self delegate, or add a delegate address. If you wish to delegate your UNI voting power to your own address, click “Self Delegate”. You can also update your delegation at any time.

![img](https://docs.uniswap.org/assets/images/Delegate_To_Self-b903241667ba6cd85b2816271fe17d80.png)

When you click “Self Delegate”, a transaction will pop up in your wallet. If this doesn’t happen, double check that you have connected your wallet, turn off any popup blockers, and try again. Click "Confirm". When the transaction has processed, you will see that the updated voting power on your profile. Note that delegating your voting power is an event that is captured on chain, so setting and updating your delegation costs gas.

An important note: much like voter registration in a larger democracy, for UNI to be used in a vote it must be delegated before both the voting period. This means if you want your vote to count, you must delegate it in anticipation of any proposal you may be interested in.

If you are unsure of how best to vote and are interested in delegating your UNI voting power to another party, you can visit the [Delegation Pitch](https://gov.uniswap.org/c/delegation-pitch/6) section of the Governance Forum. Here parties participating in Uniswap Governance pitch their platform and voting agenda for users to read and discuss.

## Voting

If you have self delegated and there is an active proposal, you are ready to vote in Uniswap Governance.

To cast your vote, navigate to the proposals page and click on an active proposal.

![img](https://docs.uniswap.org/assets/images/Proposals_Overview-45a7f1bc8cab6113e2f7388e7621b3ea.png)

After reviewing the attached details and deciding your opinion, choose “Vote For”, or “Vote Against”.

Once you’ve chosen, a window will pop up allowing you to execute the vote.

When you click to cast your vote, your wallet will pop up asking you to confirm your transaction. Click “submit” or "confirm", wait a bit, and check that the transaction has been confirmed. You can view your votes from your profile, or on the proposal itself.

![img](https://docs.uniswap.org/assets/images/Vote_Confirmation-cee3fef4d1ab95d386e284f6404d5647.png)

That’s it! Once your transaction has been confirmed, you will have cast your vote and participated in Uniswap Governance.



# Adversarial Circumstances

This document explores some adversarial circumstances which Uniswap Governance may encounter in the future. Its goal is to help those interested in Uniswap Governance understand the reasoning behind some of its design, its limitations, and potential avenues for growth.

## Scenario 1

A good faith proposal is brought to vote but is found to have an exploitable edge case. A bad faith actor uses a series of DeFi leveraging strategies to quickly buy enough UNI during the voting period to sway the vote in favor of the proposal, passing it and exploiting the vulnerability.

### Circumvention

UNI voting power must be delegated to an address either entirely before a proposal has been submitted or during the proposal delay period. For now, the proposal delay is set to one block, which is about 15 seconds. A proposal delay of one block leaves no opportunity for a third party to find an exploitable edge case and opportunistically purchase uni, self delegate and sway the vote.

In the future, Uniswap Governance may vote to increase the proposal delay. While there are obvious benefits to an increased proposal delay, It may introduce some potential adverse outcomes such as opportunistic edge case exploitation.

## Scenario 2

A bad faith proposal is crafted and submitted to vote, which is unambiguously not in the best interest of Uniswap Governance. Multiple parties collude ahead of time to corner the UNI market to force the proposal through, gain access to the UNI reserves, and drain the funds.

### Circumvention

Since UNI is a freely tradable asset, anyone can attempt a governance takeover via market buying. That said, to force-pass a bad faith vote would require a minimum of 40 million UNI. If not outright impossible, this amount would be prohibitively expensive and likely cost more when accounting for price fluctuation than the net gain from the attack.

If a group somehow achieved a bad faith takeover, Timelock's delay would give affected agents time to withdraw their assets from the protocol. This would also be an opportunity to fork the protocol, a path that would likely be taken by the remaining good-faith actors.

## Scenario 3

A single party uses a flash loan to push through a proposal, potentially creating a pseudo-DDOS attack by spamming governance with proposals and preventing effective use.

### Circumvention

A delegated balance of 2.5 million UNI is required to submit a vote, but the balance check is set exactly one block in the past. This prevents any flash loan proposals from being created, as flash loans cannot execute outside of a single block.

The proposer must also maintain a minimum balance of 2.5 million UNI throughout the voting period, or anyone may cancel the proposal. This balance maintenance check prevents many highly leveraged proposal techniques that may span several blocks.

## Scenario 4

A bad faith proposal is created, which will genuinely incentivize bad faith voting.

Example: "The treasury will be drained. Any votes in favor will be sent the balance of the treasury. Any votes opposed will be locked from the funds of the treasury."

### Circumvention

No mechanism explicitly prevents this type of scenario, but market forces disincentivize it.

Because the treasury is comprised of UNI tokens exclusively, the market would react appropriately if a vote were to pass that would jeopardize the economic viability of Uniswap Governance and the UNI token. By the time the vote would pass, UNI's price would have fallen so low as to make the attack fruitless.

UNI acting as the only asset of the governance treasury disincentivizes this form of bad faith voting. Uniswap Governance may choose in the future to diversify governance assets. While there are many benefits to this path, some fringe possibilities such as incentivized bad faith voting may appear.



# Glossary

- **UNI:** An ERC-20 token that designates the weight of a user's voting rights. The more UNI a user has in their wallet, the more weight their delegation or vote on a proposal holds.
- **Delegation:** UNI holders cannot vote or create proposals until they delegate their voting rights to an address. Delegation can be given to one address at a time, including the holder's own address. Note that delegation does not lock tokens; it simply adds votes to the chosen delegation address.
- **Proposal:** A proposal is executable code that modifies the governance contract or treasury and how they work. In order to create a proposal, a user must have at least 0.25% (2.5M UNI) of all UNI delegated to their address. Proposals are stored in the "proposals" mapping of the Governor smart contract. All proposals are subject to a 7-day voting period. If the proposer does not maintain their vote weight balance throughout the voting period, the proposal may be canceled by anyone.
- **Quorum:** In order for a vote to pass, it must achieve quorum of 4% of all UNI (40M) voting in the affirmative. The purpose of the quorum is to ensure that the only measures that pass have adequate voter participation.
- **Voting:** Users can vote for or against single proposals once they have voting rights delegated to their address. Votes can be cast while a proposal is in the "Active" state. Votes can be submitted immediately using "castVote" or submitted later with "castVoteBySig" (For more info on castVoteBySig and offline signatures, see EIP-712). If the majority of votes (and a 4% quorum of UNI) vote for a proposal, the proposal may be queued in the Timelock.
- **Voting Period:** Once a proposal has been put forward, Uniswap community members will have a seven day period (the Voting Period) to cast their votes.
- **Timelock:** All governance and other administrative actions are required to sit in the Timelock for a minimum of 2 days, after which they can be implemented.

[Concepts](https://docs.uniswap.org/concepts/overview)[Research](https://docs.uniswap.org/concepts/research)

# Research

The [Uniswap Foundation](https://www.uniswapfoundation.org/) supports the protocol's growth and decentralization through strategic research initiatives, empowering our community with grants and resources to conduct groundbreaking research and develop practical implementations that advance the frontier DeFi. Featured research from our community:

## Layer 2 be or Layer not 2 be: Scaling on Uniswap v3

Authors: Austin Adams

> This research paper analyzes how cheaper and faster blockchain networks impact Uniswap v3's performance compared to Ethereum mainnet, revealing that reduced transaction costs lead to better gas-adjusted execution and more efficient capital deployment by liquidity providers. Faster block times and lower costs enable increased arbitrage activity, resulting in higher fee returns for liquidity providers, though there's evidence that 2-second block times may not be optimal compared to a first-come-first-served model. Evidence suggests that many current AMM limitations stem from blockchain constraints rather than protocol design, and these issues can be significantly improved through faster, cheaper transactions.

- [Layer 2 be or Layer not 2 be: Scaling on Uniswap v3 [Mar 2024\]](https://arxiv.org/abs/2403.09494)

## Who Wins Ethereum Block Building Auctions and Why?

Authors: Burak Öz, Danning Sui, Thomas Thiery, Florian Matthes

> The MEV-Boost block auction contributes approximately 90% of all Ethereum blocks. Between October 2023 and March 2024, only three builders produced 80% of them, highlighting the concentration of power within the block builder market. To foster competition and preserve Ethereum's decentralized ethos and censorship-resistance properties, understanding the dominant players' competitive edges is essential. This identifies features that play a significant role in builders' ability to win blocks and earn profits by conducting a comprehensive empirical analysis of MEV-Boost auctions over a six-month period.

- [Who Wins Ethereum Block Building Auctions and Why? [Jul 2024\]](https://arxiv.org/abs/2407.13931)

## MEV Capture and Decentralization in Execution Tickets

Authors: Jonah Burian, Davide Crapis, Fahad Saleh

> Provides an economic model of Execution Tickets and uses it to study the ability of the Ethereum protocol to capture MEV from block construction, demonstrating that Execution Tickets extract all MEV when all buyers are homogeneous, risk neutral and face no capital costs. We also show that MEV capture decreases with risk aversion and capital costs. Moreover, when buyers are heterogeneous, MEV capture can be especially low and a single dominant buyer can extract much of the MEV. This adverse effect can be partially mitigated by the presence of a Proposer Builder Separation (PBS) mechanism, which gives ET buyers access to a market of specialized builders, but in practice centralization vectors still persist. With PBS, ETs are concentrated among those with the highest ex-ante MEV extraction ability and lowest cost of capital. We show how it is possible that large investors that are not builders but have substantial advantage in capital cost can come to dominate the ET market.

- [MEV Capture and Decentralization in Execution Tickets [Aug 2024\]](https://arxiv.org/abs/2408.11255)

## What Drives Liquidity on Decentralized Exchanges? Evidence from the Uniswap Protocol

Authors: Alex Evans

> Geometric mean market makers (G3Ms), such as Uniswap and Balancer, comprise a popular class of automated market makers (AMMs) defined by the following rule: the reserves of the AMM before and after each trade must have the same (weighted) geometric mean. This paper extends several results known for constant-weight G3Ms to the general case of G3Ms with time-varying and potentially stochastic weights. These results include the returns and no-arbitrage prices of liquidity pool (LP) shares that investors receive for supplying liquidity to G3Ms. Using these expressions, we show how to create G3Ms whose LP shares replicate the payoffs of financial derivatives. The resulting hedges are model-independent and exact for derivative contracts whose payoff functions satisfy an elasticity constraint. These strategies allow LP shares to replicate various trading strategies and financial contracts, including standard options. G3Ms are thus shown to be capable of recreating a variety of active trading strategies through passive positions in LP shares.

- [What Drives Liquidity on Decentralized Exchanges? Evidence from the Uniswap Protocol [Oct 2024\]](https://arxiv.org/abs/2410.19107)

## The Evolution of Decentralized Exchange: Risks, Benefits, and Oversight

Authors: Campbell R. Harvey, Joel Hasbrouck, Fahad Saleh

> A decentralized exchange or DEX is an application deployed on a blockchain that allows investors to exchange digital assets at pricing terms determined by a preset exchange rate formula. This technology has several unique features, including accessibility to all investors, transparency of pricing, and simultaneity of execution and settlement. Notably, trading via a DEX is feasible for any asset tokenized on a blockchain. In turn, given that assets such as stocks and bonds could be tokenized easily, it is particularly important to understand the risks posed by DEXs. This paper examines both the benefits and risks to investors from DEXs, explores the role of private and public liquidity pools and analyzes possible regulatory approaches.

- [The Evolution of Decentralized Exchange: Risks, Benefits, and Oversight [Oct 2024\]](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4861942)

## Research Initiatives: Get Involved

- [TLDR (The Latest in DeFi Research):](https://www.thelatestindefi.org/) empowers engineers, academics, and students through research fellowships with grants and expert mentorship, culminating in an annual conference to showcase groundbreaking work.
- [CBER CtCe (Crafting the Cryptoeconomy):](https://x.com/UniswapFND/status/1859719158763749514) developed to generate and promote practical yet rigorous research in cryptoeconomics by connecting researchers, economists and practitioners through workshops, grants and conferences.
- [DEX Analytics Portal:](https://dexanalytics.org/) accurate, verified, and ergonomic DEX and Uniswap datasets to save researchers time.

# Resources

This page will be periodically updated with helpful resources for calculations and software design as they are made available.

- [**Uniswap v2 Visualization**](https://www.desmos.com/calculator/j8eppi5vvu)
- [**Uniswap v3 Visualization**](https://www.desmos.com/calculator/q2kxfue441)
- [**Uniswap v3 (Multiple Positions) Visualization**](https://www.desmos.com/calculator/oduetjzfp4)
- [**v2 / v3 Calculations**](https://docs.google.com/spreadsheets/d/1VH-lbF9RDUpVozGeA3BtWwypjW66MjcD1DnOYzcHmzk/edit#gid=0)

# Glossary

## Automated Market Maker

An automated market maker is a smart contract on Ethereum that holds liquidity reserves. Users can trade against these reserves at prices determined by a fixed formula. Anyone may contribute liquidity to these smart contracts, earning pro-rata trading fees in return.

## Asset

While a digital asset can take many forms, the Uniswap Protocol supports ERC-20 token pairs, and represents a position in the form of an NFT (ERC-721).

## Concentrated Liquidity

Liquidity that is allocated within a determined price range.

## Constant Product Formula

The automated market making algorithm used by Uniswap. In v1 and v2, this was x*y=k.

## Core

Smart contracts that are considered foundational, and are essential for Uniswap to exist. Upgrading to a new version of core would require deploying an entirely new set of smart contracts on Ethereum and would be considered a new version of the Uniswap Protocol.

## ERC20

ERC20 tokens are fungible tokens on Ethereum. Uniswap supports all standard ERC20 implementations.

## Factory

A smart contract that deploys a unique smart contract for any ERC20/ERC20 trading pair.

## Flash Swap

A trade that uses the tokens purchased before paying for them.

## Invariant

The “k” value in the constant product formula X*Y=K

## Liquidity Provider / "LP"

A liquidity provider is someone who deposits ERC20 tokens into a given liquidity pool. Liquidity providers take on price risk and are compensated with trading fees.

## Liquidity

Digital assets that are stored in a Uniswap pool contract, and are able to be traded against by traders.

## Mid Price

The price between the available buy and sell prices. In Uniswap v1 and v2, this is the ratio of the two ERC20 token reserves. In V3, this is the ratio of the two ERC20 token reserves available within the current active tick.

## Observation

An instance of historical price and liquidity data of a given pair.

## Pair

A smart contract deployed from a Uniswap v1 or v2 factory contract that enables trading between two ERC20 tokens. Pair contracts are now called Pools in v3.

## Periphery

External smart contracts that are useful, but not required for Uniswap to exist. New periphery contracts can always be deployed without migrating liquidity.

## Pool

A contract deployed by the V3 factory that pairs two ERC-20 assets. Different pools may have different fees despite containing the same token pair. Pools were previously called Pairs before the introduction of multiple fee options.

## Position

An instance of liquidity defined by upper and lower tick. And the amount of liquidity contained therein.

## Price Impact

The difference between the mid-price and the execution price **caused by your trade size relative to the pool’s liquidity**. This is an expected result of the constant product formula in AMMs.

## Protocol Fees

Fees that are rewarded to the protocol itself, rather than to liquidity providers.

## Range

Any interval between two ticks of any distance.

## Range Order

An approximation of a limit order, in which a single asset is provided as liquidity across a specified range, and is continuously swapped to the destination address as the spot price crosses the range.

## Reserves

The liquidity available within a pair. This was more commonly referenced before concentrated liquidity was introduced.

## Slippage

The total difference between the expected price at the time of submitting a transaction and the actual execution price, which may include price impact and other market movements that occur before the transaction is mined.

## Spot Price

The current price of a token relative to another within a given pair.

## Swap Fees

The fees collected upon swapping which are rewarded to liquidity providers.

## Tick Interval

The price space between two nearest ticks.

## Tick

The boundaries between discrete areas in price space.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)

# Overview

Uniswap v4 inherits all of the capital efficiency gains of Uniswap v3, but provides flexibility via *hooks* and gas optimizations across the entire lifecycle.

For additional information, see the [Uniswap v4 whitepaper](https://app.uniswap.org/whitepaper-v4.pdf)

## Hooks

Developers can attach solidity logic to the *swap lifecycle* through Hooks. The logic is executed before and/or after major operations such as pool creation, liquidity addition and removal, swapping, and donations. Hooks are deployed contracts, and are called by the Uniswap v4 PoolManager, for permissionless execution.

The flexibility of hooks can enable:

- Limit orders
- Custom oracles
- Fee management
- Automated liquidity management

## Dynamic Fees

Uniswap v4 supports dynamic fees, allowing pools to adjust their fees up or down. While other AMMs may have hard-coded logic for dynamic fees, v4 provides no opinionated calculation of the fee. The frequency of *liquidity fee* updates is also flexible and determined by the developer. Fee updates can occur on every swap, every block, or on an arbitrary schedule (weekly, monthly, yearly, etc).

Dynamic fees open up the design space for fee optimization, value redistribution, and research.

## Singleton Design

Architecturally, all pool state and operations are managed by a single contract -- `PoolManager.sol`. The singleton design provides major gas savings. For example, creating a pool is now a state update instead of the deployment of a new contract. Swapping through multiple pools no longer requires transferring tokens for intermediate pools.

## Flash Accounting

By leveraging EIP-1153 Transient Storage, v4 provides an optimization referred to as *flash accounting*. Swapping, liquidity modification, and donations incur *balance changes*, i.e. tokens to be sent in and tokens to be taken out. With *flash accounting* these balance changes are efficiently recorded in transient storage and netted against each other. This system allows users to only pay the final balance change, without the need for resolving intermediate balance changes.

## Native ETH

Uniswap v4 supports native token assets (Ether), without the need to wrap/unwrap the native token to Wrapped Ether (WETH9).

## Custom Accounting

The flexibility of custom accounting allows developers to alter token amounts for swaps and liquidity modifications. The feature opens up the design space for hooks to charge fees or forgo the underlying concentrated liquidity model.

Example use-cases:

- Custom curves, opt-out of the concentrated liquidity curve in favor of an entirely independent pricing mechanism
- Hook swap fees, charge and collect fees on swaps
- Liquidity withdrawal fees, penalize and/or redistribute fee revenue

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 Protocol[Deployments](https://docs.uniswap.org/contracts/v4/deployments)

# Deployments

The Uniswap Protocol is made up of multiple contracts on many networks.

The latest version of `@uniswap/v4-core`, `@uniswap/v4-periphery`, and `@uniswap/universal-router` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

## Mainnet Deployments

### Ethereum: 1

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x000000000004444c5dc75cB358380D2e3dE08A90`](https://etherscan.io/address/0x000000000004444c5dc75cB358380D2e3dE08A90) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xd1428ba554f4c8450b763a0b2040a4935c63f06c`](https://etherscan.io/address/0xd1428ba554f4c8450b763a0b2040a4935c63f06c) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e`](https://etherscan.io/address/0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x52f0e24d1c21c8a0cb1e5a5dd6198556bd9e1203`](https://etherscan.io/address/0x52f0e24d1c21c8a0cb1e5a5dd6198556bd9e1203) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x7ffe42c4a5deea5b0fec41c94c136cf115597227`](https://etherscan.io/address/0x7ffe42c4a5deea5b0fec41c94c136cf115597227) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x66a9893cc07d91d95644aedd05d03f95e1dba8af`](https://etherscan.io/address/0x66a9893cc07d91d95644aedd05d03f95e1dba8af) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Unichain: 130

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x1f98400000000000000000000000000000000004`](https://uniscan.xyz/address/0x1f98400000000000000000000000000000000004) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x9fb28449a191cd8c03a1b7abfb0f5996ecf7f722`](https://uniscan.xyz/address/0x9fb28449a191cd8c03a1b7abfb0f5996ecf7f722) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4529a01c7a0410167c5740c487a8de60232617bf`](https://uniscan.xyz/address/0x4529a01c7a0410167c5740c487a8de60232617bf) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x333e3c607b141b18ff6de9f258db6e77fe7491e0`](https://uniscan.xyz/address/0x333e3c607b141b18ff6de9f258db6e77fe7491e0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x86e8631a016f9068c3f085faf484ee3f5fdee8f2`](https://uniscan.xyz/address/0x86e8631a016f9068c3f085faf484ee3f5fdee8f2) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xef740bf23acae26f6492b10de645d6b98dc8eaf3`](https://uniscan.xyz/address/0xef740bf23acae26f6492b10de645d6b98dc8eaf3) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://uniscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Optimism: 10

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x9a13f98cb987694c9f086b1f5eb990eea8264ec3`](https://optimistic.etherscan.io/address/0x9a13f98cb987694c9f086b1f5eb990eea8264ec3) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xedd81496169c46df161b8513a52ffecaaaa66743`](https://optimistic.etherscan.io/address/0xedd81496169c46df161b8513a52ffecaaaa66743) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x3c3ea4b57a46241e54610e5f022e5c45859a1017`](https://optimistic.etherscan.io/address/0x3c3ea4b57a46241e54610e5f022e5c45859a1017) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x1f3131a13296fb91c90870043742c3cdbff1a8d7`](https://optimistic.etherscan.io/address/0x1f3131a13296fb91c90870043742c3cdbff1a8d7) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xc18a3169788f4f75a170290584eca6395c75ecdb`](https://optimistic.etherscan.io/address/0xc18a3169788f4f75a170290584eca6395c75ecdb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x851116d9223fabed8e56c0e6b8ad0c31d98b3507`](https://optimistic.etherscan.io/address/0x851116d9223fabed8e56c0e6b8ad0c31d98b3507) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimistic.etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Base: 8453

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x498581ff718922c3f8e6a244956af099b2652b2b`](https://basescan.org/address/0x498581ff718922c3f8e6a244956af099b2652b2b) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x25d093633990dc94bedeed76c8f3cdaa75f3e7d5`](https://basescan.org/address/0x25d093633990dc94bedeed76c8f3cdaa75f3e7d5) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x7c5f5a4bbd8fd63184577525326123b519429bdc`](https://basescan.org/address/0x7c5f5a4bbd8fd63184577525326123b519429bdc) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x0d5e0f971ed27fbff6c2837bf31316121532048d`](https://basescan.org/address/0x0d5e0f971ed27fbff6c2837bf31316121532048d) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xa3c0c9b65bad0b08107aa264b0f3db444b867a71`](https://basescan.org/address/0xa3c0c9b65bad0b08107aa264b0f3db444b867a71) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x6ff5693b99212da76ad316178a184ab56d299b43`](https://basescan.org/address/0x6ff5693b99212da76ad316178a184ab56d299b43) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://basescan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Arbitrum One: 42161

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://arbiscan.io/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xe2023f3fa515cf070e07fd9d51c1d236e07843f4`](https://arbiscan.io/address/0xe2023f3fa515cf070e07fd9d51c1d236e07843f4) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xd88f38f930b7952f2db2432cb002e7abbf3dd869`](https://arbiscan.io/address/0xd88f38f930b7952f2db2432cb002e7abbf3dd869) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://arbiscan.io/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://arbiscan.io/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xa51afafe0263b40edaef0df8781ea9aa03e381a3`](https://arbiscan.io/address/0xa51afafe0263b40edaef0df8781ea9aa03e381a3) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://arbiscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Polygon: 137

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x67366782805870060151383f4bbff9dab53e5cd6`](https://polygonscan.com/address/0x67366782805870060151383f4bbff9dab53e5cd6) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0892771f0c1b78ad6013d6e5536007e1c16e6794`](https://polygonscan.com/address/0x0892771f0c1b78ad6013d6e5536007e1c16e6794) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1ec2ebf4f37e7363fdfe3551602425af0b3ceef9`](https://polygonscan.com/address/0x1ec2ebf4f37e7363fdfe3551602425af0b3ceef9) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0xb3d5c3dfc3a7aebff71895a7191796bffc2c81b9`](https://polygonscan.com/address/0xb3d5c3dfc3a7aebff71895a7191796bffc2c81b9) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a`](https://polygonscan.com/address/0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x1095692a6237d83c6a72f3f5efedb9a670c49223`](https://polygonscan.com/address/0x1095692a6237d83c6a72f3f5efedb9a670c49223) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://polygonscan.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Blast: 81457

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x1631559198a9e474033433b2958dabc135ab6446`](https://blastscan.io/address/0x1631559198a9e474033433b2958dabc135ab6446) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0747ad2b2e1f5761b1dcf0d8672bd1ffc3676f97`](https://blastscan.io/address/0x0747ad2b2e1f5761b1dcf0d8672bd1ffc3676f97) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4ad2f4cca2682cbb5b950d660dd458a1d3f1baad`](https://blastscan.io/address/0x4ad2f4cca2682cbb5b950d660dd458a1d3f1baad) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x6f71cdcb0d119ff72c6eb501abceb576fbf62bcf`](https://blastscan.io/address/0x6f71cdcb0d119ff72c6eb501abceb576fbf62bcf) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x12a88ae16f46dce4e8b15368008ab3380885df30`](https://blastscan.io/address/0x12a88ae16f46dce4e8b15368008ab3380885df30) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xeabbcb3e8e415306207ef514f660a3f820025be3`](https://blastscan.io/address/0xeabbcb3e8e415306207ef514f660a3f820025be3) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://blastscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Zora: 7777777

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x0575338e4c17006ae181b47900a84404247ca30f`](https://explorer.zora.energy/address/0x0575338e4c17006ae181b47900a84404247ca30f) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x7d64630bbb4993b5578dbd65e400961c9e68d55a`](https://explorer.zora.energy/address/0x7d64630bbb4993b5578dbd65e400961c9e68d55a) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xf66c7b99e2040f0d9b326b3b7c152e9663543d63`](https://explorer.zora.energy/address/0xf66c7b99e2040f0d9b326b3b7c152e9663543d63) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x5edaccc0660e0a2c44b06e07ce8b915e625dc2c6`](https://explorer.zora.energy/address/0x5edaccc0660e0a2c44b06e07ce8b915e625dc2c6) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x385785af07d63b50d0a0ea57c4ff89d06adf7328`](https://explorer.zora.energy/address/0x385785af07d63b50d0a0ea57c4ff89d06adf7328) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x3315ef7ca28db74abadc6c44570efdf06b04b020`](https://explorer.zora.energy/address/0x3315ef7ca28db74abadc6c44570efdf06b04b020) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://explorer.zora.energy/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Worldchain: 480

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0xb1860d529182ac3bc1f51fa2abd56662b7d13f33`](https://worldscan.org/address/0xb1860d529182ac3bc1f51fa2abd56662b7d13f33) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x7da419153bd420b689f312363756d76836aeace4`](https://worldscan.org/address/0x7da419153bd420b689f312363756d76836aeace4) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xc585e0f504613b5fbf874f21af14c65260fb41fa`](https://worldscan.org/address/0xc585e0f504613b5fbf874f21af14c65260fb41fa) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x55d235b3ff2daf7c3ede0defc9521f1d6fe6c5c0`](https://worldscan.org/address/0x55d235b3ff2daf7c3ede0defc9521f1d6fe6c5c0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x51d394718bc09297262e368c1a481217fdeb71eb`](https://worldscan.org/address/0x51d394718bc09297262e368c1a481217fdeb71eb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743`](https://worldscan.org/address/0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://worldscan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Ink: 57073

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://explorer.inkonchain.com/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36`](https://explorer.inkonchain.com/address/0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1b35d13a2e2528f192637f14b05f0dc0e7deb566`](https://explorer.inkonchain.com/address/0x1b35d13a2e2528f192637f14b05f0dc0e7deb566) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://explorer.inkonchain.com/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://explorer.inkonchain.com/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x112908dac86e20e7241b0927479ea3bf935d1fa0`](https://explorer.inkonchain.com/address/0x112908dac86e20e7241b0927479ea3bf935d1fa0) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://explorer.inkonchain.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Soneium: 1868

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://soneium.blockscout.com/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36`](https://soneium.blockscout.com/address/0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1b35d13a2e2528f192637f14b05f0dc0e7deb566`](https://soneium.blockscout.com/address/0x1b35d13a2e2528f192637f14b05f0dc0e7deb566) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://soneium.blockscout.com/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://soneium.blockscout.com/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x4cded7edf52c8aa5259a54ec6a3ce7c6d2a455df`](https://soneium.blockscout.com/address/0x4cded7edf52c8aa5259a54ec6a3ce7c6d2a455df) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://soneium.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Avalanche: 43114

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x06380c0e0912312b5150364b9dc4542ba0dbbc85`](https://snowscan.xyz/address/0x06380c0e0912312b5150364b9dc4542ba0dbbc85) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x2b1aed9445b05ac1a3b203eccc1e25dd9351f0a9`](https://snowscan.xyz/address/0x2b1aed9445b05ac1a3b203eccc1e25dd9351f0a9) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xb74b1f14d2754acfcbbe1a221023a5cf50ab8acd`](https://snowscan.xyz/address/0xb74b1f14d2754acfcbbe1a221023a5cf50ab8acd) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0xbe40675bb704506a3c2ccfb762dcfd1e979845c2`](https://snowscan.xyz/address/0xbe40675bb704506a3c2ccfb762dcfd1e979845c2) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xc3c9e198c735a4b97e3e683f391ccbdd60b69286`](https://snowscan.xyz/address/0xc3c9e198c735a4b97e3e683f391ccbdd60b69286) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x94b75331ae8d42c1b61065089b7d48fe14aa73b7`](https://snowscan.xyz/address/0x94b75331ae8d42c1b61065089b7d48fe14aa73b7) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://snowscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### BNB Smart Chain: 56

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x28e2ea090877bf75740558f6bfb36a5ffee9e9df`](https://bscscan.com/address/0x28e2ea090877bf75740558f6bfb36a5ffee9e9df) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xf0432f360703ec3d33931a8356a75a77d8d380e1`](https://bscscan.com/address/0xf0432f360703ec3d33931a8356a75a77d8d380e1) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x7a4a5c919ae2541aed11041a1aeee68f1287f95b`](https://bscscan.com/address/0x7a4a5c919ae2541aed11041a1aeee68f1287f95b) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x9f75dd27d6664c475b90e105573e550ff69437b0`](https://bscscan.com/address/0x9f75dd27d6664c475b90e105573e550ff69437b0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xd13dd3d6e93f276fafc9db9e6bb47c1180aee0c4`](https://bscscan.com/address/0xd13dd3d6e93f276fafc9db9e6bb47c1180aee0c4) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x1906c1d672b88cd1b9ac7593301ca990f94eae07`](https://bscscan.com/address/0x1906c1d672b88cd1b9ac7593301ca990f94eae07) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://bscscan.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Celo: 42220

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x288dc841A52FCA2707c6947B3A777c5E56cd87BC`](https://celoscan.io/address/0x288dc841A52FCA2707c6947B3A777c5E56cd87BC) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x5727E22b25fEEe05E8dFa83C752B86F19D102D8A`](https://celoscan.io/address/0x5727E22b25fEEe05E8dFa83C752B86F19D102D8A) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xf7965f3981e4d5bc383bfbcb61501763e9068ca9`](https://celoscan.io/address/0xf7965f3981e4d5bc383bfbcb61501763e9068ca9) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x28566da1093609182dff2cb2a91cfd72e61d66cd`](https://celoscan.io/address/0x28566da1093609182dff2cb2a91cfd72e61d66cd) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xbc21f8720babf4b20d195ee5c6e99c52b76f2bfb`](https://celoscan.io/address/0xbc21f8720babf4b20d195ee5c6e99c52b76f2bfb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xcb695bc5d3aa22cad1e6df07801b061a05a0233a`](https://celoscan.io/address/0xcb695bc5d3aa22cad1e6df07801b061a05a0233a) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://celoscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

## Testnet Deployments

### Unichain Sepolia: 1301

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x00b036b58a818b1bc34d502d3fe730db729e62ac`](https://sepolia.uniscan.xyz/address/0x00b036b58a818b1bc34d502d3fe730db729e62ac#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xf70536b3bcc1bd1a972dc186a2cf84cc6da6be5d`](https://sepolia.uniscan.xyz/address/0xf70536b3bcc1bd1a972dc186a2cf84cc6da6be5d#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xf969aee60879c54baaed9f3ed26147db216fd664`](https://sepolia.uniscan.xyz/address/0xf969aee60879c54baaed9f3ed26147db216fd664#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xc199f1072a74d4e905aba1a84d9a45e2546b6222`](https://sepolia.uniscan.xyz/address/0xc199f1072a74d4e905aba1a84d9a45e2546b6222#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x56dcd40a3f2d466f48e7f48bdbe5cc9b92ae4472`](https://sepolia.uniscan.xyz/address/0x56dcd40a3f2d466f48e7f48bdbe5cc9b92ae4472#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol) | [`0x9140a78c1a137c7ff1c151ec8231272af78a99a4`](https://sepolia.uniscan.xyz/address/0x9140a78c1a137c7ff1c151ec8231272af78a99a4#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x5fa728c0a5cfd51bee4b060773f50554c0c8a7ab`](https://sepolia.uniscan.xyz/address/0x5fa728c0a5cfd51bee4b060773f50554c0c8a7ab#code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.uniscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Sepolia: 11155111

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0xE03A1074c86CFeDd5C142C4F04F1a1536e203543`](https://sepolia.etherscan.io/address/0xE03A1074c86CFeDd5C142C4F04F1a1536e203543#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b`](https://sepolia.etherscan.io/address/0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x429ba70129df741B2Ca2a85BC3A2a3328e5c09b4`](https://sepolia.etherscan.io/address/0x429ba70129df741B2Ca2a85BC3A2a3328e5c09b4#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xe1dd9c3fa50edb962e442f60dfbc432e24537e4c`](https://sepolia.etherscan.io/address/0xe1dd9c3fa50edb962e442f60dfbc432e24537e4c#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x61b3f2011a92d183c7dbadbda940a7555ccf9227`](https://sepolia.etherscan.io/address/0x61b3f2011a92d183c7dbadbda940a7555ccf9227#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol) | [`0x9b6b46e2c869aa39918db7f52f5557fe577b6eee`](https://sepolia.etherscan.io/address/0x9b6b46e2c869aa39918db7f52f5557fe577b6eee#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x0c478023803a644c94c4ce1c1e7b9a087e411b0a`](https://sepolia.etherscan.io/address/0x0c478023803a644c94c4ce1c1e7b9a087e411b0a#code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Base Sepolia: 84532

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408`](https://sepolia.basescan.org/address/0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x492e6456d9528771018deb9e87ef7750ef184104`](https://sepolia.basescan.org/address/0x492e6456d9528771018deb9e87ef7750ef184104#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4b2c77d209d3405f41a037ec6c77f7f5b8e2ca80`](https://sepolia.basescan.org/address/0x4b2c77d209d3405f41a037ec6c77f7f5b8e2ca80#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x571291b572ed32ce6751a2cb2486ebee8defb9b4`](https://sepolia.basescan.org/address/0x571291b572ed32ce6751a2cb2486ebee8defb9b4#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba`](https://sepolia.basescan.org/address/0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol) | [`0x8b5bcc363dde2614281ad875bad385e0a785d3b9`](https://sepolia.basescan.org/address/0x8b5bcc363dde2614281ad875bad385e0a785d3b9#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x37429cd17cb1454c34e7f50b09725202fd533039`](https://sepolia.basescan.org/address/0x37429cd17cb1454c34e7f50b09725202fd533039#code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.basescan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Arbitrum Sepolia: 421614

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0xFB3e0C6F74eB1a21CC1Da29aeC80D2Dfe6C9a317`](https://sepolia.arbiscan.io/address/0xFB3e0C6F74eB1a21CC1Da29aeC80D2Dfe6C9a317#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xefd1d4bd4cf1e86da286bb4cb1b8bced9c10ba47`](https://sepolia.arbiscan.io/address/0xefd1d4bd4cf1e86da286bb4cb1b8bced9c10ba47#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xAc631556d3d4019C95769033B5E719dD77124BAc`](https://sepolia.arbiscan.io/address/0xAc631556d3d4019C95769033B5E719dD77124BAc#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x9d467fa9062b6e9b1a46e26007ad82db116c67cb`](https://sepolia.arbiscan.io/address/0x9d467fa9062b6e9b1a46e26007ad82db116c67cb#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x7de51022d70a725b508085468052e25e22b5c4c9`](https://sepolia.arbiscan.io/address/0x7de51022d70a725b508085468052e25e22b5c4c9#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol) | [`0xf3a39c86dbd13c45365e57fb90fe413371f65af8`](https://sepolia.arbiscan.io/address/0xf3a39c86dbd13c45365e57fb90fe413371f65af8#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x9a8ca723f5dccb7926d00b71dec55c2fea1f50f7`](https://sepolia.arbiscan.io/address/0x9a8ca723f5dccb7926d00b71dec55c2fea1f50f7#code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.arbiscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### interop-alpha-0: 420120000

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96`](https://optimism-interop-alpha-0.blockscout.com/address/0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96?tab=contract_source_code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a`](https://optimism-interop-alpha-0.blockscout.com/address/0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a?tab=contract_source_code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4498FE0b1DF6B476453440664A16E269B7587D0F`](https://optimism-interop-alpha-0.blockscout.com/address/0x4498FE0b1DF6B476453440664A16E269B7587D0F?tab=contract_source_code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375`](https://optimism-interop-alpha-0.blockscout.com/address/0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375?tab=contract_source_code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x7C594D9B533ac43D3595dd4117549111Ec48F8B2`](https://optimism-interop-alpha-0.blockscout.com/address/0x7C594D9B533ac43D3595dd4117549111Ec48F8B2?tab=contract_source_code) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0ebb8526647744204cda2edb3f6bded2ec56403f`](https://optimism-interop-alpha-0.blockscout.com/address/0x0ebb8526647744204cda2edb3f6bded2ec56403f?tab=contract_source_code) |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/transparent/TransparentUpgradeableProxy.sol) | [`0x73162af50bf62750ff1b28c926e092b55022324d`](https://optimism-interop-alpha-0.blockscout.com/address/0x73162af50bf62750ff1b28c926e092b55022324d?tab=contract_source_code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimism-interop-alpha-0.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3?tab=contract_source_code) |

### interop-alpha-1: 420120001

| Contract                                                     | Address                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96`](https://optimism-interop-alpha-1.blockscout.com/address/0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96?tab=contract_source_code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a`](https://optimism-interop-alpha-1.blockscout.com/address/0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a?tab=contract_source_code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4498FE0b1DF6B476453440664A16E269B7587D0F`](https://optimism-interop-alpha-1.blockscout.com/address/0x4498FE0b1DF6B476453440664A16E269B7587D0F?tab=contract_source_code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375`](https://optimism-interop-alpha-1.blockscout.com/address/0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375?tab=contract_source_code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x7C594D9B533ac43D3595dd4117549111Ec48F8B2`](https://optimism-interop-alpha-1.blockscout.com/address/0x7C594D9B533ac43D3595dd4117549111Ec48F8B2?tab=contract_source_code) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0ebb8526647744204cda2edb3f6bded2ec56403f`](https://optimism-interop-alpha-1.blockscout.com/address/0x0ebb8526647744204cda2edb3f6bded2ec56403f?tab=contract_source_code) |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/transparent/TransparentUpgradeableProxy.sol) | [`0x73162af50bf62750ff1b28c926e092b55022324d`](https://optimism-interop-alpha-1.blockscout.com/address/0x73162af50bf62750ff1b28c926e092b55022324d?tab=contract_source_code) |
| [Permit2](https://github.com/Uniswap/permit2)                | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimism-interop-alpha-1.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3?tab=contract_source_code) |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[v4 vs v3](https://docs.uniswap.org/contracts/v4/concepts/v4-vs-v3)

# v4 vs v3

While Uniswap v4's underlying concentrated liquidity is the same as Uniswap v3, there are some key differences in the architecture and accounting.

## Singleton Design

### Pool Creation

**v4**: The singleton contract facilitates the creation of a pool and also stores its state. This pattern reduces costs when creating a pool and doing multi-hop swaps. Because pools are *contract state* and not entirely new *contracts* themselves, pool creation is significantly cheaper.

**v3**: A factory contract is responsible for pool creation. The pool is a separate contract instance that manages its own state. Pool initialization is costly because contract creation is gas-intensive

### Flash Accounting

**v4**: The singleton uses *flash accounting*, meaning a caller that unlocks the PoolManager is allowed to cause balance-changing operations (multiple swaps, multiple liquidity modifications, etc) and only needs to perform token transfers at the very end of the sequence.

**v3**: Because flash accounting is missing from v3, it is the responsibility of the integrating contract to perform token transfers, after each individual call, to each individual pool contract

## Liquidity Fee Accounting

**v4**: Accrued fees act like a credit when modifying liquidity. Increasing liquidity will convert the fee revenue to liquidity inside the position while decreasing liquidity will automatically require the withdrawal of unclaimed fee revenue.

An additional parameter *salt* can be provided when creating liquidity. The *salt* is used to distinguish positions of the same range on the same pool. This separation may be preferred to simplify fee accounting. If two users share the same range and state in `PoolManager`, integrating contracts must be careful in managing fees

**v3**: Liquidity positions of the same range and pool will share the same state. While believed to be more gas efficient at the time, integrating contracts will need to handle fee management since the state is shared on the core pool contract

## Native ETH

**v4**: Pool pairs support native tokens, in doing so ETH swappers and liquidity providers benefit from gas cost reductions from cheaper transfers and removal of additional wrapping costs.

**v3**: ETH needs to be wrapped first before being paired with other tokens. This results in higher gas costs because of wrapping and transferring a wrapped native token.

## Subscribers

Only v4: Owners can now set a subscriber for their positions. A subscriber contract will get notified every time the position's liquidity or owner changes. Subscribers enable staking / liquidity-mining, but users do not need to transfer their ERC-721 token.

**v3**: Staking in v3 requires users to transfer their ERC-721 token to a contract, putting the underlying assets at risk for malicious behavior.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[ERC-6909](https://docs.uniswap.org/contracts/v4/concepts/erc6909)

# ERC-6909

Uniswap v4 uses [ERC-6909](https://eips.ethereum.org/EIPS/eip-6909) to further improve gas-efficiency on token claims and redemptions.

ERC-6909 is a minimal and gas-efficient standard for managing multiple ERC-20 tokens from a single contract. It provides a simplified alternative to the more complex ERC-1155 multi-token standard.

### ERC-6909 vs ERC-1155

ERC-6909 offers several advantages over ERC-1155:

1. Simplified interface: ERC-6909 removes unnecessary safe transfer callbacks and batching constraints presented in ERC-1155.
2. Improved transfer delegation: ERC-6909 provides a more efficient system for transfer delegation.
3. Gas efficiency: ERC-6909 reduces gas costs for deployment, transfers, and burning operations.
4. Reduced code size: Implementing ERC-6909 results in smaller contract sizes compared to ERC-1155.

However, it's worth noting that ERC-6909 does introduce a `totalSupply` variable, which leads to an additional disk write on mint and burn operations.

## How it works

Instead of choosing to move tokens in/out of the `PoolManager`, developers can opt-in and leave the ERC-20 tokens within the `PoolManager`. In exchange, the `PoolManager` can **mint them an ERC-6909 token representing their claim**. In subsequent interactions requiring *paying* tokens, users will not need to transfer ERC-20 tokens into the `PoolManager` - users can simply *burn* some (or all) of their claim tokens they have

Doing *real* ERC-20 token transfers requires calls to external smart contracts - incurring gas overhead compared to internal accounting. Secondly, these external smart contracts have their own custom logic within their `transfer` functions - for example USDC's blocked-address list - which is a further gas overhead. Thus, minting and burning ERC-6909 tokens are more gas-efficient because they don't require external function calls and have a constant-size gas overhead regardless of the underlying ERC-20 token.

This mechanism therefore helps further reduce gas costs. All these gas cost reductions overall make pools much more competitive based on the fees they charge.

## Examples

### High-frequency traders / MEV bots

These users are often conducting a lot of swaps in relatively short durations of time, while staying within the Uniswap Protocol. These power-users can trade using ERC-6909 tokens for improved gas-efficiency.

### Liquidity management

ERC-6909 does not only benefit swappers. For power-users that may be opening and closing liquidity positions frequently, liquidity managers can opt-in and receive their capital as ERC-6909.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[Hooks](https://docs.uniswap.org/contracts/v4/concepts/hooks)

# Hooks

Uniswap v4 introduces Hooks, a system that allows developers to customize and extend the behavior of liquidity pools.

Hooks are external smart contracts that can be attached to individual pools. Every pool can have one hook but a hook can serve an infinite amount of pools to intercept and modify the execution flow at specific points during pool-related actions.

## Key Concepts

### Pool-Specific Hooks

- Each liquidity pool in Uniswap v4 can have its own hook contract attached to it. Hooks are optional for Uniswap v4 pools.
- The hook contract is specified when creating a new pool in the `PoolManager.initialize` function.
- Having pool-specific hooks allows for fine-grained control and customization of individual pools.

## Core Hook Functions

Uniswap v4 provides a set of core hook functions that can be implemented by developers. Developers do not have to implement every hook, you can mix&match them to whatever your liking is. You can use one or all of them!

- Hook contracts specify the permissions that determine which hook functions they implement, which is encoded in the address of the contract.
- The `PoolManager` uses these permissions to determine which hook functions to call for a given pool based on its Key.

### Initialize Hooks

- `beforeInitialize`: Called before a new pool is initialized.
- `afterInitialize`: Called after a new pool is initialized.
- These hooks allow developers to perform custom actions or validations during pool initialization, but these hooks can only be invoked once.

### Liquidity Modification Hooks

The liquidity modification hooks are extremely granular for security purposes.

- `beforeAddLiquidity`: Called before liquidity is added to a pool.
- `afterAddLiquidity`: Called after liquidity is added to a pool.
- `beforeRemoveLiquidity`: Called before liquidity is removed from a pool.
- `afterRemoveLiquidity`: Called after liquidity is removed from a pool.

### Swap Hooks

- `beforeSwap`: Called before a swap is executed in a pool.
- `afterSwap`: Called after a swap is executed in a pool.

### Donate Hooks

- `beforeDonate`: Called before a donation is made to a pool.
- `afterDonate`: Called after a donation is made to a pool.
- Donate hooks provide a way to customize the behavior of token donations to liquidity providers.

## Innovation and Potential

The introduction of hooks in Uniswap v4 opens up a world of possibilities for developers to innovate and build new DeFi protocols. Some potential use cases include:

- Customized AMMs with different pricing curves than xy = k.
- Yield farming and liquidity mining protocols that incentivize liquidity provision.
- Derivative and synthetic asset platforms built on top of Uniswap v4 liquidity.
- Lending hooks integrated with Uniswap v4 pools.

As a hook developer you can easily bootstrap the codebase of an entirely new DeFi protocol through hook designs, which subsequently drives down your audit costs and allows you to develop faster. However, it's important to note that just because you made a hook, that does not mean you will get liquidity routed to your hook from the Uniswap frontend.



# Subscribers

Subscribers, new in Uniswap v4, allow for liquidity-position owners to opt-in to a contract that receives *notifications*. The new design is intended to support *liquidity mining*, additional rewards given to in-range liquidity providers. Through notification logic, position owners do not need to risk their liquidity position and its underlying assets. In Uniswap v3, *liquidity mining* was supported by fully transferring the liquidity position to an external contract; this old design would give the external contract full ownership and control of the liquidity position.

When a position owner *subscribes* to a contract, the contract will receive notifcations when:

- The position is initially subscribed
- The position increases or decreases its liquidity
- The position is transferred
- The position is unsubscribed

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[PoolManager](https://docs.uniswap.org/contracts/v4/concepts/PoolManager)

# PoolManager

In Uniswap v3, each liquidity pool was represented by a separate smart contract deployed through the Uniswapv3Factory contract. While this approach provided flexibility, it also led to increased gas costs for pool creation and multi-hop swaps.

Uniswap v4 addresses this issue by introducing the Singleton design pattern. The PoolManager contract now serves as a single entry point for all liquidity pools. Instead of deploying separate contracts for each pool, the pool state and logic are encapsulated within the PoolManager itself.

## Purpose

The primary purpose of the `PoolManager` is to:

- Efficiently manage liquidity pools
- Facilitate token swaps
- Reduce gas costs compared to the factory-based approach in Uniswap v3
- Enable extensibility through hooks

## Architecture

### Singleton Design

- Uniswap v4 uses a Singleton design pattern for the `PoolManager`
- All pool state and logic are encapsulated within the `PoolManager` contract

### Locking Mechanism

- The `PoolManager` uses a locking mechanism to allow for *flash accounting* (also known as deferred balance accounting)
- When unlocked, the calling contract can perform various operations and zero-out outstanding balances before returning control to the `PoolManager` for final solvency checks

### Pool State

- The

   

  ```
  Pool.State
  ```

   

  struct contains information such as:

  - Current price
  - Liquidity
  - Tick bitmap
  - Fee growth
  - Position information

### Libraries

- The pool logic is implemented using Solidity libraries to keep the `PoolManager` contract modular and gas-efficient
- These libraries are:
  - `Pool`: Contains core pool functionality, such as swaps and liquidity management
  - `Hooks`: Handles the execution of hook functions
  - `Position`: Manages liquidity positions within a pool

## Core Functionality

### Pool Creation

- New pools are created by calling the `initialize` function on the `PoolManager`
- The pool creator specifies the token pair, fee tier, tick spacing, and optional hook contract address
- The `PoolManager` initializes the pool state and associates it with a unique `PoolId`

### Swaps

- Swaps are initiated through the `swap` function on the `PoolManager`, typically via a swap router contract

- The

   

  ```
  PoolManager
  ```

   

  executes the following steps:

  1. Checks if the pool is valid and initialized
  2. Executes the `beforeSwap` hook, if applicable
  3. Performs the actual swap, updating the pool state and charging fees
  4. Executes the `afterSwap` hook, if applicable
  5. Calculates the net token amounts owed to the user and the pool, represented by the `BalanceDelta` struct

- Swaps utilize flash accounting, where tokens are moved into the `PoolManager`, and only the final output tokens are withdrawn

### Liquidity Management

- Liquidity providers can add or remove liquidity using the `modifyLiquidity` function on the `PoolManager`. However, you wouldn't call this directly from your application, you would call this from a periphery contract to handle the locking & unlocking a particular pool.

- The

   

  ```
  PoolManager
  ```

   

  executes the following steps:

  1. Checks if the pool is valid and initialized
  2. Determines if the modification is an addition or removal of liquidity
  3. Executes the appropriate `beforeAddLiquidity` or `beforeRemoveLiquidity` hook, if applicable
  4. Performs the actual liquidity modification and updates the pool state
  5. Emits the `ModifyLiquidity` event
  6. Executes the appropriate `afterAddLiquidity` or `afterRemoveLiquidity` hook, if applicable
  7. Calculates the balance delta and returns it to the caller

### Flash Accounting

- The `PoolManager` employs flash accounting to reduce gas costs and simplify multi-hop swaps
- Tokens are moved into the `PoolManager` contract, and all subsequent actions are performed within the contract's context
- Only the final output tokens are withdrawn from the `PoolManager` at the end of the transaction

### Transient Storage

- The `PoolManager` utilizes transient storage (EIP-1153) to store temporary data during complex operations
- Transient storage reduces gas costs by avoiding regular storage operations for data only needed within a single transaction

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[Dynamic Fees](https://docs.uniswap.org/contracts/v4/concepts/dynamic-fees)

# Dynamic Fees

Uniswap v4 introduces dynamic fees, allowing for flexible and responsive fee structures managed through hooks. This feature enables pools to adapt fees to changing market conditions, potentially improving liquidity provider profitability and overall market efficiency.

## What are Dynamic Fees?

Dynamic fees in Uniswap v4 are a specific type of swap fee paid by swappers that directly accrue to liquidity providers. These fees are distinct from protocol fees and hook fees (Optional fees that can be implemented by custom hooks), and represent a significant advancement over the fee structures in previous Uniswap versions.

Unlike the static fee tiers in Uniswap v3 (0.05%, 0.30%, 1.0%) or the single fee in v2, dynamic fees in v4 offer much more flexibility. Dynamic fees can:

- Adjust in real-time based on various market conditions
- Change on a per-swap basis
- Allow for any fee percentage (e.g., 4.9 bips, 10 bips)
- Be updated at various intervals (yearly, per block, or per transaction)

This dynamic nature allows for more efficient fee pricing, potentially benefiting both liquidity providers and traders by adapting to current market conditions. By allowing fees to fluctuate based on market dynamics, Uniswap v4 aims to optimize liquidity provision and trading across a wide range of market scenarios.

## Motivation and Benefits of Dynamic Fees

1. **Improved Pricing of Volatility:** Adapt fees to market volatility, similar to traditional exchanges adjusting bid-ask spreads.
2. **Order Flow Discrimination:** Price different types of trades (e.g., arbitrage vs. uninformed) more accurately.
3. **Improved Market Efficiency and Stability:** Fees can adjust to reflect real-time market conditions, optimizing for both liquidity providers and traders. Dynamic fees could help dampen extreme market movements by adjusting incentives in real-time.
4. **Enhanced Capital Efficiency and Liquidity Provider Returns:** By optimizing fees, pools can attract more liquidity and facilitate more efficient trading. More accurate fee pricing could lead to better returns for liquidity providers, potentially attracting more capital to pools.
5. **Better Risk Management:** During high volatility, fees can increase to protect liquidity providers from impermanent loss.
6. **Customizable Strategies:** Enable complex fee strategies for specific token pairs or market segments.

## Dynamic Fees Use Cases

1. **Volatility-Based Fees:** Adjust fees based on the historical or realized volatility of the asset pair.
2. **Volume-Based Fees:** Lower fees during high-volume periods to attract more trades, and increase fees during low-volume periods to compensate liquidity providers.
3. **Time-Based Fees:** Implement different fee structures for different times of day or days of the week, based on historical trading patterns.
4. **Market Depth-Based Fees:** Adjust fees based on the current liquidity depth in the pool.
5. **Cross-Pool Arbitrage Mitigation:** Dynamically adjust fees to discourage harmful arbitrage between different pools or exchanges.
6. **Gas Price-Responsive Fees:** Adjust fees based on network congestion and gas prices to ensure profitability for liquidity providers.
7. **Event-Driven Fees:** Implement special fee structures during significant market events or token-specific occurrences.
8. **Lookback approach:** Set the fee to match the most profitable fee tier of external pools with the same asset pair over a recent period.
9. **Price oracle approach:** Use an external price oracle to determine the correct asset price and adjust fees based on how trades move the pool price relative to this external price.
10. **Price momentum approach:** Analyze recent price history and asymmetrically adjust fees based on trade direction.
11. **Asset composition approach:** Lower fees for trades that balance the pool and higher fees for trades that imbalance it.
12. **Transaction-source based approach:** Provide lower fees for transactions routed through certain aggregators or sources less likely to be arbitrage trades.

## Dynamic Fees Mechanism

In Uniswap v4, the dynamic fee capability of a pool is determined at pool creation and is immutable. This means that whether a pool uses dynamic fees or not is set when the pool is initially created and cannot be changed afterwards. For pools that do use dynamic fees, Uniswap v4 supports two primary methods for updating the fee:

1. **Periodic Updates via PoolManager:** Fees can be updated by calling the `updateDynamicLPFee` function on the PoolManager contract at specified intervals.
2. **Per-Swap Updates via beforeSwap Hook:** Fees can be dynamically set for each swap by returning the fee from the `beforeSwap` hook. This allows hooks to override the LP fee for each swap in dynamic fee pools.

These methods offer flexibility in implementing various fee strategies.

Below is an example of how to set dynamic fees using the `beforeSwap` hook:

![img](https://docs.uniswap.org/assets/images/Uniswap_V4_Dynamic_Fees_Step_1-474b99ad2e0664b70b6838af49623050.jpg)

Before a swap occurs, the `beforeSwap` hook is invoked to determine the fee based on the defined logic. This hook calls the `updateDynamicLPFee` function on the PoolManager contract to update the fee.

![img](https://docs.uniswap.org/assets/images/Uniswap_V4_Dynamic_Fees_Step_2-dd9459c1205604362fcc04afbd9770f6.jpg)

The `updateDynamicLPFee` function in the PoolManager contract updates the pool's fee accordingly.

For more detailed information on implementing these methods, please refer to our [Dynamic Fees Implementation Guide](https://uniswap-docs-staging.vercel.app/documentation/featured-guides/hooks/v4/guides-for-solidity-contracts/dynamic-fee-pools).

## Considerations and Best Practices

- The optimal fee depends on at least two factors: **asset volatility** and **volume of uninformed flow.**
- For volatile pairs in systems like Uniswap v3, which don't discriminate between flows, low fee-tier pools are only sensible when uninformed flow is large and asset volatility is relatively low.
- Performance implications of frequent fee updates should be carefully considered.
- Security measures should be implemented to prevent manipulation of fee-setting mechanisms.
- Balance responsiveness with gas costs to optimize for both performance and cost-effectiveness.

For more detailed implementation guidance and best practices, refer to our [Dynamic Fees Implementation Guide](https://uniswap-docs-staging.vercel.app/documentation/featured-guides/hooks/v4/guides-for-solidity-contracts/dynamic-fee-pools).



# Integrated Routing with UniswapX

The [Uniswap Interface](https://app.uniswap.org/) will be ramping up support for hooks in its standard routing system progressively over time. Hook builders looking to get immediate access to flow from the interface can do so by running a UniswapX filler for their hooked pools.

At a high level, hook builders' filler implementations will need to do the following:

1. (On Mainnet) Subscribe to the UniswapX RFQ system and submit fillable bids from orders they receive
2. Listen to the public feed for orders they won or that are open to be filled publicly
3. Execute those orders against pools that use their hooks

Developers should check [UniswapX Documentation](https://docs.uniswap.org/contracts/uniswapx/overview) to get started.



# v4 Fee Structure Guide

## Overview of Fee Types

In Uniswap v4, there are three main types of fees to understand:

- **LP Fee**: Fees earned by liquidity providers
- **Protocol Fee**: Fees collected by the protocol
- **Swap Fee**: Total fee paid by swappers (calculated by applying protocol fee and LP fee sequentially)

------

## LP Fees

LP fees are set by the pool initializer at pool creation and may be static or dynamic.

**Fee Range:**

- Maximum LP Fee: 100%
- Minimum LP Fee: 0%
- **Granularity**: Fees are set at pip-level precision

### Static LP Fees

- **Immutable** once set during pool initialization
- **Unlimited fee options** in v4 (major improvement from v3)
- In **v3**, LP fee options were limited to: 0.01%, 0.05%, 0.30%, and 1.00%

### Dynamic LP Fees

Dynamic fees offer more flexibility and real-time adjustability:

- A dynamic fee pool signals this capability by setting its LP fee to `0x800000` (where the first bit = 1)
- **Only the pool's hook** can update the dynamic fee—no additional permissions required
- A hook **cannot** update fees if the pool's fee is not set to `0x800000`

------

## Protocol Fees

Protocol fees are configured **per pool** with the following characteristics:

- Controlled by the **protocol fee controller** (set by the pool manager owner)

- **Maximum protocol fee**: 0.1% (1,000 pips)

- **Granularity**: Fees are set at pip-level precision (not basis points)

- **Unit conversion**: 1 basis point = 100 pips

- Directional fees

  : Separate fees can be set for:

  - token0 → token1 swaps
  - token1 → token0 swaps

------

## Swap Fees

### Key Change from v3 to v4

**v3 behavior**: Swap fee = LP fee (protocol fee was a percentage taken from LP fees)

**v4 behavior**: Swap fee = effective total fee after applying both protocol and LP fees sequentially

### Application Order

1. **Protocol fee** applied first to the input amount
2. **LP fee** applied second to the remaining input (after protocol fee deduction)

**Impact on LP Earnings:**

Note that this sequential application means introducing or increasing protocol fees will reduce LP earnings even if swap volume remains constant, since LPs now earn fees on a smaller base amount.

### Fee Cap

- **Total swap fee capped at 100%** of input amount
- **Important**: If swap fee = 100%, exact output swaps become impossible (entire input consumed by fees)

### Fee Calculation Formula

```solidity
// Method 1: Sequential application
uint256 swapFee = protocolFee + (lpFee * (1_000_000 - protocolFee)) / 1_000_000; (rounded up)

// Method 2: Mathematically equivalent
uint256 swapFee = protocolFee + lpFee - (protocolFee * lpFee) / 1_000_000;
```



### Mathematical Derivation

Starting with input amount:

```text
amountIn
```



**Step 1**: Protocol fee takes:

```text
amountIn × (protocolFee / 1_000_000)
```



**Step 2**: Remaining after protocol fee:

```text
amountIn × (1 - protocolFee / 1_000_000)
```



**Step 3**: LP fee applies to remaining:

```text
lpFee × (remaining amount)
```



**Final formula**:

```text
swapFee = protocolFee + (lpFee × (1 - protocolFee / 1_000_000))
```



Which simplifies to:

```text
swapFee = protocolFee + lpFee - (protocolFee × lpFee) / 1_000_000
```



## Example Calculation

**Given:**

- `protocolFee = 50` pips → 0.005%
- `lpFee = 3000` pips → 0.30%

**Calculation:**

```solidity
swapFee = 50 + 3000 - (50 × 3000) / 1_000_000
        = 50 + 3000 - 150 / 1_000_000
        = 50 + 3000 - 0.15
        = 3049.85 pips
```



**Result:** 3049.85 pips = **0.304985%** total swap fee

------

## Key Takeaways

- **Sequential application**: Protocol fees are deducted first, then LP fees apply to the remainder
- **Dynamic flexibility**: v4 introduces unlimited static fee tiers and dynamic fee capabilities
- **Directional control**: Protocol fees can differ by swap direction
- **Fee interaction**: The combined effect is slightly less than simple addition due to sequential application

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolConcepts[Security](https://docs.uniswap.org/contracts/v4/concepts/security)

# Security

When building on Uniswap v4, security should be a primary consideration. This section covers emergency response resources and security best practices specific to v4 implementations.

## Emergency Response

### SEAL 911 Emergency Hotline

If you encounter a security incident (exploit, vulnerability, or other urgent security matter) while working with Uniswap v4, the SEAL 911 Emergency Hotline provides immediate access to security experts.

**Emergency Contact**: https://t.me/seal_911_bot

SEAL 911 is a community-operated Telegram bot that connects you directly with vetted security responders who can provide immediate assistance during security incidents.

#### How It Works

- Send a message through the bot during a security emergency
- Automatic alert routing to a vetted group of white hat security professionals
- Immediate response from trusted security experts in the space

#### Additional Resources

- [SEAL 911 GitHub Repository](https://github.com/security-alliance/seal-911)
- [Security Alliance Website](https://www.securityalliance.org/seal-911)

note

SEAL 911 is a third-party service operated by the Security Alliance. Exercise appropriate judgment when sharing sensitive information during emergency situations.

## v4-Specific Security Considerations

### Hook Security

When developing custom hooks for v4, ensure proper validation and access controls. Malicious or poorly implemented hooks can compromise pool security.

### Flash Accounting

v4's flash accounting system requires careful implementation to prevent exploitation. Always ensure proper settlement of deltas.

### Pool Manager Interactions

Direct interactions with the PoolManager require thorough understanding of the locking mechanism and callback patterns.

## Audits

Uniswap's V4 core contracts have undergone a handful of extensive security reviews by multiple providers, with some reviews still ongoing. Below is a list of completed and draft reports. The full list can be found in the respective repositories' [audits directory](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits):

> [Open Zeppelin report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/OpenZeppelin_audit_core.pdf) from July 17th 2024.

> [Certora draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_Certora_audit_core.pdf) from July 2024.

> [Trail of Bits report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/TrailOfBits_audit_core.pdf) from September 5th 2024.

> [Spearbit draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_Spearbit_audit_core.pdf) from September 5th 2024.

> [ABDK draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_ABDK_audit_core.pdf) from September 5th 2024.

Similarly, the V4 periphery contracts have been reviewed by various audit providers, and the full list is inside the periphery repository's [audits directory](https://github.com/Uniswap/v4-periphery/tree/main/audits):

> [Open Zeppelin report](https://github.com/Uniswap/v4-periphery/blob/main/audits/OpenZeppelin_audit_periphery_universal_router.pdf) from September 5th 2024.

> [Spearbit draft report](https://github.com/Uniswap/v4-periphery/blob/main/audits/DRAFT_Spearbit_audit_periphery.pdf) from September 5th 2024.

> [ABDK draft report](https://github.com/Uniswap/v4-periphery/blob/main/audits/DRAFT_ABDK_audit_periphery_universal_router.pdf) from September 5th 2024.

## Bug Bounty Program

In November 2024 Uniswap announced a [$15.5 million dollar bug bounty](https://blog.uniswap.org/v4-bug-bounty) for their V4 contracts. You can view the full [bounty page](https://cantina.xyz/bounties/f9df94db-c7b1-434b-bb06-d1360abdd1be) on Cantina.

## Additional Security Resources

- Review the [v4 Core contracts](https://docs.uniswap.org/contracts/v4/reference/core/) for implementation details
- Follow security best practices outlined in the [Hooks documentation](https://docs.uniswap.org/contracts/v4/concepts/04-hooks.mdx)
- Test thoroughly using the provided [test contracts](https://docs.uniswap.org/contracts/v4/reference/core/test/)

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstart[Create Pool](https://docs.uniswap.org/contracts/v4/quickstart/create-pool)

# Create Pool

## Context

Creating a pool on Uniswap v4 is permissionless and enables the trading of an asset. Uniswap v4 is a popular destination for creating markets due to its:

- Proven track record and battle-tested codebase
- Concentrated liquidity, unlocking capital efficiency
- Flexibile pool design through dynamic fees and hooks
- Gas-efficient architecture
- Integrations with alternative trading venues

For more information, developers should see [Uniswap v4 Overview](https://docs.uniswap.org/contracts/v4/overview)

The guide covers two approaches to creating a pool:

1. Create a pool only
2. Create a pool and add initial liquidity, with one transaction

### Setup

Developing with Uniswap v4 *requires [foundry](https://book.getfoundry.sh/)*

Install the dependencies:

```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
```



## Guide: Create a Pool Only

To initialize a Uniswap v4 Pool *without initial liquidity*, developers should call [`PoolManager.initialize()`](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager#initialize)

Creating a pool without liquidity may be useful for "reserving" a pool for future use, when initial liquidity is not available, or when external market makers would provide the starting liquidity

### 1. Configure the Pool

```solidity
import {PoolKey} from "v4-core/src/types/PoolKey.sol";

PoolKey memory pool = PoolKey({
    currency0: currency0,
    currency1: currency1,
    fee: lpFee,
    tickSpacing: tickSpacing,
    hooks: hookContract
});
```



> For native token pairs (Ether), use `CurrencyLibrary.ADDRESS_ZERO` as `currency0`

[PoolKey](https://docs.uniswap.org/contracts/v4/reference/core/types/PoolKey) uniquely identifies a pool

- *Currencies* should be sorted, `uint160(currency0) < uint160(currency1)`
- *lpFee* is the fee expressed in pips, i.e. 3000 = 0.30%
- *tickSpacing* is the granularity of the pool. Lower values are more precise but may be more expensive to trade on
- *hookContract* is the address of the hook contract

A note on `tickSpacing`:

Lower tick spacing provides improved price precision; however, smaller tick spaces will cause swaps to cross ticks more often, incurring higher gas costs

As a reference, Uniswap v3 pools are configured with:

| Fee   | Fee Value | Tick Spacing |
| ----- | --------- | ------------ |
| 0.01% | 100       | 1            |
| 0.05% | 500       | 10           |
| 0.30% | 3000      | 60           |
| 1.00% | 10_000    | 200          |

### 2. Call `initialize`

Pools are initialized with a starting price

```solidity
IPoolManager(manager).initialize(pool, startingPrice);
```



- the

   

  startingPrice

   

  is expressed as sqrtPriceX96:

   

  ```
  floor(sqrt(token1 / token0) * 2^96)
  ```

  - i.e. `79228162514264337593543950336` is the starting price for a 1:1 pool

## Guide: Create a Pool & Add Liquidity

Uniswap v4's [PositionManager](https://docs.uniswap.org/contracts/v4/reference/periphery/PositionManager) supports atomic creation of a pool and initial liquidity using [*multicall*](https://docs.uniswap.org/contracts/v4/reference/periphery/base/Multicall_v4). Developers can create a trading pool, with liquidity, in a single transaction:

### 1. Initialize the parameters provided to `multicall()`

```solidity
bytes[] memory params = new bytes[](2);
```



- The first call, `params[0]`, will encode `initializePool` parameters
- The second call, `params[1]`, will encode a *mint* operation for `modifyLiquidities`

### 2. Configure the pool

```solidity
PoolKey memory pool = PoolKey({
    currency0: currency0,
    currency1: currency1,
    fee: lpFee,
    tickSpacing: tickSpacing,
    hooks: hookContract
});
```



> For native token pairs (Ether), use `CurrencyLibrary.ADDRESS_ZERO` as `currency0`

[PoolKey](https://docs.uniswap.org/contracts/v4/reference/core/types/PoolKey) uniquely identifies a pool

- *Currencies* should be sorted, `uint160(currency0) < uint160(currency1)`
- *lpFee* is the fee expressed in pips, i.e. 3000 = 0.30%
- *tickSpacing* is the granularity of the pool. Lower values are more precise but more expensive to trade
- *hookContract* is the address of the hook contract

### 3. Encode the [`initializePool`](https://docs.uniswap.org/contracts/v4/reference/periphery/base/PoolInitializer) parameters

Pools are initialized with a starting price

```solidity
import {IPoolInitializer_v4} from "v4-periphery/src/interfaces/IPoolInitializer_v4.sol";

params[0] = abi.encodeWithSelector(
    IPoolInitializer_v4.initializePool.selector,
    pool,
    startingPrice
);
```



- the

   

  startingPrice

   

  is expressed as

   

  sqrtPriceX96

  :

   

  ```
  floor(sqrt(token1 / token0) * 2^96)
  ```

  - `79228162514264337593543950336` is the starting price for a 1:1 pool

### 4. Initialize the *mint-liquidity* parameters

PositionManager's `modifyLiquidities` uses an encoded command system

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR));
```



- The first command `MINT_POSITION` creates a new liquidity position
- The second command `SETTLE_PAIR` indicates that tokens are to be paid by the caller, to create the position

### 5. Encode the `MINT_POSITION` parameters

```solidity
bytes[] memory mintParams = new bytes[](2);
mintParams[0] = abi.encode(pool, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData);
```



- *pool* the same `PoolKey` defined above, in pool-creation
- *tickLower* and *tickUpper* are the range of the position, must be a multiple of `pool.tickSpacing`
- *liquidity* is the amount of liquidity units to add, see `LiquidityAmounts` for converting token amounts to liquidity units
- *amount0Max* and *amount1Max* are the maximum amounts of token0 and token1 the caller is willing to transfer
- *recipient* is the address that will receive the liquidity position (ERC-721)
- *hookData* is the optional hook data

### 6. Encode the `SETTLE_PAIR` parameters

Creating a position on a pool requires the caller to transfer `currency0` and `currency1` tokens

```solidity
mintParams[1] = abi.encode(pool.currency0, pool.currency1);
```



### 7. Encode the [`modifyLiquidites`](https://docs.uniswap.org/contracts/v4/reference/periphery/PositionManager#modifyliquidities) call

```solidity
// Note: In production, deadlines should be calculated off-chain using real time
// For example: uint256 deadline = block.timestamp + 3600; // 1 hour from now
uint256 deadline = block.timestamp + 3600; // 1 hour deadline
params[1] = abi.encodeWithSelector(
    posm.modifyLiquidities.selector, abi.encode(actions, mintParams), deadline
);
```



### 8. Approve the tokens

`PositionManager` uses `Permit2` for token transfers

- Repeat for both tokens

```solidity
// approve permit2 as a spender
IERC20(token).approve(address(permit2), type(uint256).max);

// approve `PositionManager` as a spender
IAllowanceTransfer(address(permit2)).approve(token, address(positionManager), type(uint160).max, type(uint48).max);
```



### 9. Execute the multicall

The `multicall` is used to execute multiple calls in a single transaction

```solidity
PositionManager(posm).multicall(params);
```



For pools paired with native tokens (Ether), provide `value` in the contract call

```solidity
PositionManager(posm).multicall{value: ethToSend}(params);
```



> Excess Ether is **NOT** refunded unless developers encoded `SWEEP` in the `actions` parameter

For a full end-to-end script, developers should see [v4-template's scripts](https://github.com/uniswapfoundation/v4-template/tree/main/script)



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Setup](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/setup-liquidity)

# Setup

For users looking to interact with the canonical Uniswap v4 `PositionManager`, *v4-periphery* is a required dependency

Currently, developing with Uniswap v4 *requires [foundry](https://book.getfoundry.sh/)*

## Quickstart

*Use [v4-template](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation)*, which has pre-configured dependencies and tests for Uniswap v4

Clone the repository made from *v4-template*

```bash
git clone https://github.com/<your_username>/<your_repo>
```



Install dependencies

```bash
forge install
```



------

## Manual Setup

After cloning the repository, and installing foundry, developers can manually set up their Uniswap v4 environment:

1. Initialize a foundry project

   ```bash
   forge init . --force
   ```

   

2. Install dependencies

   ```bash
   forge install uniswap/v4-core
   forge install uniswap/v4-periphery
   ```

   

3. Set the `remappings.txt` to:

   ```text
   @uniswap/v4-core/=lib/v4-core/
   forge-gas-snapshot/=lib/v4-core/lib/forge-gas-snapshot/src/
   forge-std/=lib/v4-core/lib/forge-std/src/
   permit2/=lib/v4-periphery/lib/permit2/
   solmate/=lib/v4-core/lib/solmate/
   v4-periphery/=lib/v4-periphery/
   ```

   

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Mint Position](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/mint-position)

# Mint Position

Similar to Uniswap v3, liquidity positions are minted as ERC-721 tokens and depend on a *periphery* contract. v4's `PositionManager` contract will facilitate liquidity management

## Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding parameters.

## Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for minting a v4 liquidity position, in *solidity*

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```



### 2. Encode Actions

To mint a position, two actions are required:

- mint operation - the creation of the liquidity position
- settle pair - the two tokens to be paid by msg.sender

**If providing ETH liquidity, a third action is required:**

- sweep - to recover excess eth sent to the position manager

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR));

// For ETH liquidity positions
bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR), uint8(Actions.SWEEP));
```



### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2); // new bytes[](3) for ETH liquidity positions
```



The `MINT_POSITION` action requires the following parameters:

| Parameter    | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `poolKey`    | *PoolKey* | where the liquidity will be added to                         |
| `tickLower`  | *int24*   | the lower tick boundary of the position                      |
| `tickUpper`  | *int24*   | the upper tick boundary of the position                      |
| `liquidity`  | *uint256* | the amount of liquidity units to mint                        |
| `amount0Max` | *uint128* | the maximum amount of currency0 msg.sender is willing to pay |
| `amount1Max` | *uint128* | the maximum amount of currency1 msg.sender is willing to pay |
| `recipient`  | *address* | the address that will receive the liquidity position (ERC-721) |
| `hookData`   | *bytes*   | arbitrary data that will be forwarded to hook functions      |

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
PoolKey poolKey = PoolKey(currency0, currency1, 3000, 60, IHooks(hook));

params[0] = abi.encode(poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData);
```



The `SETTLE_PAIR` action requires the following parameters:

- `currency0` - *Currency*, one of the tokens to be paid by msg.sender
- `currency1` - *Currency*, the other token to be paid by msg.sender

```solidity
params[1] = abi.encode(currency0, currency1);
```



The `SWEEP` action requires the following parameters:

- `currency` - *Currency*, token to sweep - most commonly native Ether: `CurrencyLibrary.ADDRESS_ZERO`
- `recipient` - *address*, where to send excess tokens

```solidity
params[2] = abi.encode(currency, recipient);
```



### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```



## Additional notes:

- To obtain balance changes, callers should read token balances before and after the `.modifyLiquidities()` call

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Increase Liquidity](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/increase-liquidity)

# Increase Liquidity

### Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding parameters.

Increasing liquidity assumes the position already exists and the user wants to add more tokens to the position.

### Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for increasing a position's liquidity, in *solidity*.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```



### 2. Encode Actions

To increase a position's liquidity, the first action must be:

- *increase* operation - the addition of liquidity to an existing position.

For *delta resolving* operations, developers may need to choose between `SETTLE_PAIR`, `CLOSE_CURRENCY`, or `CLEAR_OR_TAKE` actions.

> In Uniswap v4, fee revenue is automatically credited to a position on increasing liquidity

> There are some cases, where the fee revenue can entirely "pay" for a liquidity increase, and remainder tokens need to be collected

If increasing the liquidity requires the transfer of both tokens:

- *settle pair* - pays a pair of tokens, to increase liquidity

**If increasing the liquidity for ETH positions, a third action is required:**

- *sweep* - to recover excess eth sent to the position manager

Otherwise:

- *close currency* - automatically determines if a currency should be settled or taken.
- OR *clear or take* - if the token amount to-be-collected is below a threshold, opt to forfeit the dust. Otherwise, claim the tokens

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
```



If both tokens need to be sent:

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.SETTLE_PAIR));
```



If increasing liquidity for ETH positions:

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.SETTLE_PAIR), uint8(Actions.SWEEP));
```



If converting fees to liquidity, and expect excess fees to be collected

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.CLOSE_CURRENCY), uint8(Actions.CLOSE_CURRENCY));
```



If converting fees to liquidity, forfeiting dust:

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.CLEAR_OR_TAKE), uint8(Actions.CLEAR_OR_TAKE));
```



### 3. Encoded Parameters

When settling pair (for non-ETH positions):

```solidity
bytes[] memory params = new bytes[](2);
```



Otherwise:

```solidity
bytes[] memory params = new bytes[](3);
```



The `INCREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `tokenId`    | *uint256* | position identifier                                          |
| `liquidity`  | *uint256* | the amount of liquidity to add                               |
| `amount0Max` | *uint128* | the maximum amount of currency0 liquidity msg.sender is willing to pay |
| `amount1Max` | *uint128* | the maximum amount of currency1 liquidity msg.sender is willing to pay |
| `hookData`   | *bytes*   | arbitrary data that will be forwarded to hook functions      |

```solidity
params[0] = abi.encode(tokenId, liquidity, amount0Max, amount1Max, hookData);
```



The `SETTLE_PAIR` action requires the following parameters:

- `currency0` - *Currency*, one of the tokens to be paid by msg.sender
- `currency1` - *Currency*, the other token to be paid by msg.sender

In the above case, the parameter encoding is:

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1);
```



The `SWEEP` action requires the following parameters:

- `currency` - *Currency*, token to sweep - most commonly native Ether: `CurrencyLibrary.ADDRESS_ZERO`
- `recipient` - *address*, where to send excess tokens

In this case, the parameter encoding is:

```solidity
params[2] = abi.encode(currency, recipient);
```



The `CLOSE_CURRENCY` action requires only one `currency` parameter and the encoding is:

```solidity
params[1] = abi.encode(currency0)
params[2] = abi.encode(currency1)
```



The `CLEAR_OR_TAKE` action requires one `currency` and:

- `amountMax` - *uint256*, the maximum threshold to concede dust, otherwise taking the dust.

In this case, the parameter encoding is:

```solidity
params[1] = abi.encode(currency0, amount0Max);
params[2] = abi.encode(currency1, amount1Max);
```



### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Decrease Liquidity](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/decrease-liquidity)

# Decrease Liquidity

### Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding parameters.

Decreasing liquidity assumes the position already exists and the user wants to remove tokens from the position.

### Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for decreasing a position's liquidity, in *solidity*.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```



### 2. Encode Actions

To decrease a position's liquidity, the first action must be:

- *decrease* operation - the subtraction of liquidity to an existing position.

For *delta resolving* operations, developers may need to choose between `TAKE_PAIR`, `CLOSE_CURRENCY`, or `CLEAR_OR_TAKE` actions.

> In Uniswap v4, fee revenue is automatically debited to a position on decreasing liquidity

If decreasing the liquidity requires the transfer of both tokens:

- *take pair* - receives a pair of tokens, to decrease liquidity

Otherwise:

- *clear or take* - if the token amount to-be-collected is below a threshold, opt to forfeit the dust. Otherwise, claim the tokens

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
```



If both tokens need to be sent:

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));
```



If converting fees to liquidity, forfeiting dust:

```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.CLEAR_OR_TAKE), uint8(Actions.CLEAR_OR_TAKE));
```



### 3. Encoded Parameters

When taking pair:

```solidity
bytes[] memory params = new bytes[](2);
```



Otherwise:

```solidity
bytes[] memory params = new bytes[](3);
```



The `DECREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `tokenId`    | *uint256* | position identifier                                          |
| `liquidity`  | *uint256* | the amount of liquidity to remove                            |
| `amount0Min` | *uint128* | the minimum amount of currency0 liquidity msg.sender is willing to receive |
| `amount1Min` | *uint128* | the minimum amount of currency1 liquidity msg.sender is willing to receive |
| `hookData`   | *bytes*   | arbitrary data that will be forwarded to hook functions      |

```solidity
params[0] = abi.encode(tokenId, liquidity, amount0Min, amount1Min, hookData);
```



The `TAKE_PAIR` action requires the following parameters:

- `currency0` - *Currency*, one of the tokens to be received
- `currency1` - *Currency*, the other token to be received
- `recipient` - *Recipient*, the recipient to receive the tokens

In the above case, the parameter encoding is:

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1, recipient);
```



The `CLEAR_OR_TAKE` action requires one `currency` and:

- `amountMax` - *uint256*, the maximum threshold to concede dust, otherwise taking the dust.

In this case, the parameter encoding is:

```solidity
params[1] = abi.encode(currency0, amount0Max);
params[2] = abi.encode(currency1, amount1Max);
```



### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Collect Fees](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/collect)

# Collect Fees

### Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/setup-liquidity)

## Guide

In order to collect fees, the integrator must execute encoded actions using the `PositionManager` contract. **Note** that there is no `COLLECT` command, instead developers must decrease liquidity with a zero liquidity change.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```



### 2. Encode actions

To collect fees, the following operations are required:

- decrease liquidity - collect fees from the core contract
- take pair - transfer the fee revenue, as both tokens, to a recipient

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));
```



### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2);
```



The `DECREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `tokenId`    | *uint256* | position identifier                                          |
| `liquidity`  | *uint256* | the amount of liquidity to withdraw                          |
| `amount0Min` | *uint128* | the minimum amount of currency0 liquidity msg.sender is expecting to get back |
| `amount1Min` | *uint128* | the minimum amount of currency1 liquidity msg.sender is expecting to get back |
| `hookData`   | *bytes*   | arbitrary data that will be forwarded to hook functions      |

**Note** that in order to collect fees we will default `liquidity`, `amount0Min` and `amount1Min` to 0. Because fee collection can not be manipulated in a front-run attack, it is safe to set the slippage values `amount0Min, amount1Min` to `0`.

```solidity
/// @dev collecting fees is achieved with liquidity=0, the second parameter
params[0] = abi.encode(tokenId, 0, 0, 0, hookData);
```



The `TAKE_PAIR` action requires the following parameters:

- `currency0` - *Currency*, one of the tokens to be paid by msg.sender
- `currency1` - *Currency*, the other token to be paid by msg.sender
- `recipient` - *address*, destination of the fee revenue for both tokens

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1, recipient);
```



### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```



## Additional notes:

- To obtain the amount of fees received, callers should read token balances before and after the `.modifyLiquidities()` call.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Burn Position](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/burn-liquidity)

# Burn Position

### Context

To liquidate a position, the *burn* functionality can be invoked. The funds in the position will be withdrawn and all the information of the underlying token will be cleared. Burning the position is a cost effective way to exit as a liquidity provider.

### Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide to burn a position.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```



### 2. Encode Actions

To burn a position, two actions are required:

- burn operation - clears position entirely, withdrawing funds
- take pair - sends withdrawn funds to the recipient

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.BURN_POSITION), uint8(Actions.TAKE_PAIR));
```



### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2);
```



The `BURN_POSITION` action requires the following parameters:

| Parameter    | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `tokenId`    | *uint256* | position identifier                                          |
| `amount0Min` | *uint128* | the minimum amount of currency0 liquidity msg.sender is expecting to get back |
| `amount1Min` | *uint128* | the minimum amount of currency1 liquidity msg.sender is expecting to get back |
| `hookData`   | *bytes*   | arbitrary data that will be forwarded to hook functions      |

```solidity
params[0] = abi.encode(tokenId, amount0Min, amount1Min, hookData);
```



The `TAKE_PAIR` action requires the following parameters:

| Parameter   | Type       | Description                          |
| ----------- | ---------- | ------------------------------------ |
| `currency0` | *Currency* | first token currency                 |
| `currency1` | *Currency* | second token currency                |
| `recipient` | *address*  | address that will receive the tokens |

```solidity
params[1] = abi.encode(currency0, currency1, recipient);
```



### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

posm.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartManage Liquidity[Batch Modify](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/batch-liquidity)

# Batch Modify

### Context

As seen in previous guides, `PositionManager` is a command-based contract. This design is conducive to batching complex liquidity operations. For example, developers can encode efficient logic to move liquidity between two positions on entirely different Pools.

### Setup

See the [setup guide](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/00-setup-liquidity.mdx)

## Guide

Below is a general reference guide for batch-operating on multiple liquidity positions, in *solidity*. This guide does *not* focus on a specific batch sequence, and is intended to be a general guide for `PositionManager`'s command-based interface.

### 1. Encoded Actions

Actions are divided into two types: *liquidity-operations* and *delta-resolving*.

- *liquidity-operations* - actions which that incur a *balance-change*, a change in the pool's liquidity
- *delta-resolving* - actions which facilitate token transfers, such as *settling* and *taking*

The *ordering* of `actions` determines the sequence of operations. The minimum number of actions is roughly two actions; and the maximum is limited by block gas limit. Additionally, *liquidity-operations* do not have to happen prior to *delta-resolving* actions. Developers can mix / alternate between the two types of actions.

> **However** is good practice to perform *liquidity-operations* before *delta-resolving* actions. Minimizing token transfers and leveraging [*flash accounting*](https://docs.uniswap.org/contracts/v4/concepts/02-flash-accounting.mdx) is more gas efficient

Example: `Action.Y` happens after `Action.X` but before `Action.Z`

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.X), uint8(Actions.Y), uint8(Actions.Z), ...);
```



**A Note on Special Actions**:

`PositionManager` supports a few *delta-resolving* actions beyond the standard `SETTLE` and `TAKE` actions

- `CLOSE_CURRENCY` - automatically determines if a currency should be settled (paid) or taken. Used for cases where callers may not know the final delta
- `CLEAR_OR_TAKE`- forfeit tokens if the amount is below a specified threshold, otherwise take the tokens. Used for cases where callers may expect to produce dust
- `SWEEP` - return any excess token balances to a recipient. Used for cases where callers may conversatively overpay tokens

### 2. Encoded Parameters

Each action has its own parameters to encode. Generally:

- *liquidity-operations* - encode tokenIds, liquidity amounts, and slippage
- *delta-resolving* - encode currencies, amounts, and recipients

Because actions are ordered, the parameters "zip" with their corresponding actions. The second parameter corresponds to the second action. Every action has its own encoded parameters

```solidity
bytes[] memory params = new bytes[](3);

params[0] = abi.encode(...); // parameters for the first action
params[1] = abi.encode(...); // parameters for the second action
params[2] = abi.encode(...); // parameters for the third action
```



### 3. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

posm.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstart[Swap](https://docs.uniswap.org/contracts/v4/quickstart/swap)

# Swap

## Swapping on Uniswap v4

The `Universal Router` is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 `PoolManager`, handling the intricacies of swap execution.

Although it's technically possible to interact directly with the PoolManager contract for swaps, this approach is not recommended due to its complexity and potential inefficiencies. Instead, the Universal Router is the preferred method, as it abstracts away these complexities. By using the Universal Router, developers and users can ensure a more straightforward, efficient, and standardized approach to executing swaps on v4 pools, aligning with best practices for Uniswap interactions.

## Configuring Universal Router for Uniswap v4 Swaps

Set up a foundry project and install the necessary dependencies:

```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
forge install uniswap/permit2
forge install uniswap/universal-router
forge install uniswap/v3-core
forge install uniswap/v2-core
forge install OpenZeppelin/openzeppelin-contracts
```



In the `remappings.txt`, add the following:

```text
@uniswap/v4-core/=lib/v4-core/
@uniswap/v4-periphery/=lib/v4-periphery/
@uniswap/permit2/=lib/permit2/
@uniswap/universal-router/=lib/universal-router/
@uniswap/v3-core/=lib/v3-core/
@uniswap/v2-core/=lib/v2-core/
@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/
[...]
```



### Step 1: Set Up the Project

First, we need to set up our project and import the necessary dependencies. We'll create a new Solidity contract for our example.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { UniversalRouter } from "@uniswap/universal-router/contracts/UniversalRouter.sol";
import { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";
import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";
import { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";
import { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { StateLibrary } from "@uniswap/v4-core/src/libraries/StateLibrary.sol";

contract Example {
    using StateLibrary for IPoolManager;

    UniversalRouter public immutable router;
    IPoolManager public immutable poolManager;
    IPermit2 public immutable permit2;

    constructor(address _router, address _poolManager, address _permit2) {
        router = UniversalRouter(payable(_router));
        poolManager = IPoolManager(_poolManager);
        permit2 = IPermit2(_permit2);
    }

    // We'll add more functions here
}
```



In this step, we're importing the necessary contracts and interfaces:

- `UniversalRouter`: This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols.
- `Commands`: This library contains the command definitions used by the UniversalRouter.
- `IPoolManager`: This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools.
- `IPermit2`: This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality.
- `StateLibrary`: This provides optimized functions for interacting with the PoolManager's state. By using `StateLibrary`, we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.

### Step 2: Implement Token Approval with Permit2

`UniversalRouter` integrates with [Permit2](https://github.com/Uniswap/permit2), to enable users to have more safety, flexibility, and control over their ERC20 token approvals.

Before we can execute swaps, we need to ensure our contract can transfer tokens. We’ll implement a function to approve the Universal Router to spend tokens on behalf of our contract.

Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:

```solidity
function approveTokenWithPermit2(
	address token,
	uint160 amount,
	uint48 expiration
) external {
    IERC20(token).approve(address(permit2), type(uint256).max);
    permit2.approve(token, address(router), amount, expiration);
}
```



This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time.

### Step 3: Implementing a Swap Function

#### 3.1: Function Signature

First, let’s define our function signature:

```solidity
function swapExactInputSingle(
    PoolKey calldata key, // PoolKey struct that identifies the v4 pool
    uint128 amountIn, // Exact amount of tokens to swap
    uint128 minAmountOut, // Minimum amount of output tokens expected
    uint256 deadline // Timestamp after which the transaction will revert
) external returns (uint256 amountOut) {
    // Implementation will follow
}
```



**Important note:**

1. The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks.
2. When swapping tokens involving native ETH, we use `Currency.wrap(address(0))` to represent ETH in the `PoolKey` struct.

```solidity
struct PoolKey {
    /// @notice The lower currency of the pool, sorted numerically.
    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));
    Currency currency0;
    /// @notice The higher currency of the pool, sorted numerically
    Currency currency1;
    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000
    uint24 fee;
    /// @notice Ticks that involve positions must be a multiple of tick spacing
    int24 tickSpacing;
    /// @notice The hooks of the pool
    IHooks hooks;
}
```



#### 3.2: Encoding the Swap Command

When encoding a swap command for the Universal Router, we need to choose between two types of swaps:

1. Exact Input Swaps:

Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens.

1. Exact Output Swaps:

Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement.

Next, we encode the swap command:

```solidity
bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
```



Here, we're using `V4_SWAP`, which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands.

Check the complete list of [commands](https://docs.uniswap.org/contracts/universal-router/technical-reference#command).

#### 3.3: Action Encoding

Now, let’s encode the actions for the swap:

```solidity
// Encode V4Router actions
bytes memory actions = abi.encodePacked(
    uint8(Actions.SWAP_EXACT_IN_SINGLE),
    uint8(Actions.SETTLE_ALL),
    uint8(Actions.TAKE_ALL)
);
```



These actions define the sequence of operations that will be performed in our v4 swap:

1. `SWAP_EXACT_IN_SINGLE`: This action specifies that we want to perform an exact input swap using a single pool.
2. `SETTLE_ALL`: This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers.
3. `TAKE_ALL`: This final action collects all output tokens after the swap is complete.

The sequence of these actions is important as they define the complete flow of our swap operation from start to finish.

#### 3.4: Preparing the Swap Inputs

For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:

```solidity
bytes[] memory params = new bytes[](3);

// First parameter: swap configuration
params[0] = abi.encode(
    IV4Router.ExactInputSingleParams({
        poolKey: key,
        zeroForOne: true,            // true if we're swapping token0 for token1
        amountIn: amountIn,          // amount of tokens we're swapping
        amountOutMinimum: minAmountOut, // minimum amount we expect to receive
        hookData: bytes("")             // no hook data needed
    })
);

// Second parameter: specify input tokens for the swap
// encode SETTLE_ALL parameters
params[1] = abi.encode(key.currency0, amountIn);

// Third parameter: specify output tokens from the swap
params[2] = abi.encode(key.currency1, minAmountOut);
```



Each encoded parameter corresponds to a specific action in our swap:

1. The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details
2. The second parameter defines what tokens we're putting into the swap
3. The third parameter defines what tokens we expect to receive from the swap

The sequence of these parameters must match the sequence of actions we defined earlier (`SWAP_EXACT_IN_SINGLE`, `SETTLE_ALL`, and `TAKE_ALL`).

#### 3.5: Executing the Swap

Now we can execute the swap using the Universal Router:

```solidity
bytes[] memory inputs = new bytes[](1);

// Combine actions and params into inputs
inputs[0] = abi.encode(actions, params);

// Execute the swap
uint256 deadline = block.timestamp + 20;
router.execute(commands, inputs, deadline);
```



This prepares and executes the swap based on our encoded commands, actions, and parameters.

> **Note**: Never use block.timestamp or type(uint256).max as the deadline parameter.

#### 3.6: (Optional) Verifying the Swap Output

After the swap, we need to verify that we received at least the minimum amount of tokens we specified:

```solidity
amountOut = key.currency1.balanceOf(address(this));
require(amountOut >= minAmountOut, "Insufficient output amount");
```



#### 3.7: Returning the Result

Finally, we return the amount of tokens we received:

```solidity
return amountOut;
```



This allows the caller of the function to know exactly how many tokens were received in the swap.

Here's the complete swap function that combines all the steps we've covered:

```solidity
function swapExactInputSingle(
    PoolKey calldata key,
    uint128 amountIn,
    uint128 minAmountOut
) external returns (uint256 amountOut) {
    // Encode the Universal Router command
    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
    bytes[] memory inputs = new bytes[](1);

    // Encode V4Router actions
    bytes memory actions = abi.encodePacked(
        uint8(Actions.SWAP_EXACT_IN_SINGLE),
        uint8(Actions.SETTLE_ALL),
        uint8(Actions.TAKE_ALL)
    );

    // Prepare parameters for each action
    bytes[] memory params = new bytes[](3);
    params[0] = abi.encode(
        IV4Router.ExactInputSingleParams({
            poolKey: key,
            zeroForOne: true,
            amountIn: amountIn,
            amountOutMinimum: minAmountOut,
            hookData: bytes("")
        })
    );
    params[1] = abi.encode(key.currency0, amountIn);
    params[2] = abi.encode(key.currency1, minAmountOut);

    // Combine actions and params into inputs
    inputs[0] = abi.encode(actions, params);

    // Execute the swap
    uint256 deadline = block.timestamp + 20;
    router.execute(commands, inputs, deadline);

    // Verify and return the output amount
    amountOut = key.currency1.balanceOf(address(this));
    require(amountOut >= minAmountOut, "Insufficient output amount");
    return amountOut;
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartHooks[Set Up Local Environment](https://docs.uniswap.org/contracts/v4/quickstart/hooks/setup)

# Set Up Local Environment

Before writing the hook let's first have a local environment properly configured e.g. deploying pool manager, utility routers and test tokens.

At the end of this guide a development environment will be set up to be used to build the rest of the examples in the Guides section of the docs.

To get started as quickly as possible for building Uniswap v4 hooks, there is a `Quick Start` section below to clone a boilerplate and get building. To start from scratch and learn the underlying concepts, jump to the `Start from Scratch` section.

## Quick Start

The Uniswap [v4-template repo](https://github.com/uniswapfoundation/v4-template) provides a basic foundry environment with required imports already pre-loaded. Click on [`Use this template`](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation) to create a new repository with it.

Or simply clone it and install the dependencies:

```bash
git clone https://github.com/uniswapfoundation/v4-template.git
cd v4-template
# requires foundry
forge install
forge test
```



Then hop to the [Local Node via Anvil](https://docs.uniswap.org/contracts/v4/quickstart/hooks/setup#local-node-via-anvil) to complete the set up and start developing.

------

## Start from Scratch

In the following sections, let's walk through the steps to create the same environment set up as the boilerplate from scratch and learn the underlying concepts.

### Setting up Foundry

First thing is to set up a new Foundry project.

If there is no Foundry installed - follow the [Foundry Book](https://book.getfoundry.sh/getting-started/installation) for installation.

Once Foundry is setup, initialize a new project:

```bash
forge init counter-hook
cd counter-hook
```



Then install the Uniswap `v4-core` and `v4-periphery` contracts as dependencies:

```bash
forge install Uniswap/v4-core && forge install Uniswap/v4-periphery
```



Next, set up the remappings so that the shorthand syntax for importing contracts from the dependencies work nicely:

```bash
forge remappings > remappings.txt
```



> If there is something wrong with the inferred remappings, please replace with the following in `remappings.txt`:

```text
@uniswap/v4-core/=lib/v4-core/
forge-gas-snapshot/=lib/v4-core/lib/forge-gas-snapshot/src/
forge-std/=lib/v4-core/lib/forge-std/src/
permit2/=lib/v4-periphery/lib/permit2/
solmate/=lib/v4-core/lib/solmate/
v4-core/=lib/v4-core/
v4-periphery/=lib/v4-periphery/
```



After that, remove the default Counter contract and its associated test and script file that Foundry initially set up. To do that, either manually delete those files, or just run the following:

```bash
rm ./**/Counter*.sol
```



Finally, since v4 uses transient storage which is only available after Ethereum's cancun hard fork and on Solidity versions >= 0.8.24 - some config must be set in `foundry.toml` config file.

To do that, add the following lines to `foundry.toml`:

```toml
# foundry.toml

solc_version = "0.8.26"
evm_version = "cancun"
ffi = true
```



Awesome! Now it's all set to start building the hook! Let’s run a quick test to confirm everything is set up properly.

### Compile a Basic Hook Contract

To confirm that the environment is configured correctly let's write a basic Counter Hook contract. Create a new file, `./src/CounterHook.sol` and paste the following code into it:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract CounterHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        beforeSwapCount[key.toId()]++;
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
        internal
        override
        returns (bytes4, int128)
    {
        afterSwapCount[key.toId()]++;
        return (BaseHook.afterSwap.selector, 0);
    }

    function _beforeAddLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeAddLiquidityCount[key.toId()]++;
        return BaseHook.beforeAddLiquidity.selector;
    }

    function _beforeRemoveLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeRemoveLiquidityCount[key.toId()]++;
        return BaseHook.beforeRemoveLiquidity.selector;
    }
}
```



To compile the Counter Hook contracts in the `./src` folder, use the foundry build command:

```bash
forge build
```



If the environment is compiled correctly it will display a message:

```text
Compiler run successful!
```



### Local Node via Anvil

Other than writing unit tests, [Anvil](https://book.getfoundry.sh/anvil/) can be used to deploy and test hooks.

With the local node up and running, use the `--rpc-url 127.0.0.1:8545` flag in tests to point the Foundry testing suite to that local node:

```bash
# start anvil, a local EVM chain
anvil

# in a new terminal
# foundry script for deploying v4 & hooks to anvil
forge script script/Anvil.s.sol \
    --rpc-url http://localhost:8545 \
    --private-key <test_wallet_private_key> \
    --broadcast

# test on the anvil local node
forge test --rpc-url 127.0.0.1:8545
```



## Next Steps

With the environment set up ready to be built on. Jump over to the guides section to learn about the Uniswap functions that can be integrated with Hook. Remember to add all contracts (.sol files) to the `./src` folder and their subsequent tests to the `./test` folder. Then test them against the local anvil node by running:

```bash
forge test --rpc-url 127.0.0.1:8545
```



## Appendix: OpenZeppelin Hooks Library

> [OpenZeppelin Hooks Library](https://docs.openzeppelin.com/uniswap-hooks/1.x/), included in [v4-template](https://github.com/uniswapfoundation/v4-template), provides secure and modular reference implementations for Uniswap v4 Hooks!

If you're starting from scratch, you can install the OpenZeppelin Hooks library:

```bash
$ forge install OpenZeppelin/uniswap-hooks
```



The library includes:

- **BaseHook**: Core scaffolding with security checks and permission management
- **BaseCustomAccounting**: For implementing hook-owned liquidity and custom token accounting
- **BaseCustomCurve**: For replacing default concentrated liquidity math with custom swap logic
- **BaseAsyncSwap**: For implementing non-atomic and asynchronous swaps
- **BaseDynamicFee**: For implementing dynamic fee pools
- **BaseOverrideFee**: For implementing dynamic fees on every swap
- **BaseDynamicAfterFee**: For implementing post-swap fee adjustments based on actual swap output

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartHooks[Swap Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/swap)

# Swap Hooks

Swaps are the most common interaction with the Uniswap protocol. When it comes to swap there are two hook functions available to customize and extend its behavior:

- `beforeSwap`
- `afterSwap`

As the names suggest `beforeSwap`/`afterSwap` are functions called before or after a swap is executed on a pool.

This guide will go through the parameters for `beforeSwap` and `afterSwap`, and a simple example of a swap hook.

Note: The swap hook is not production ready code, and is implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, here we will use `>=0.8.24` for the solidity version as transient storage is used.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
```



Import the relevant dependencies from `v4-core` and `v4-periphery`:

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
```



Create a contract called `SwapHook`, use `PoolIdLibrary` to attach functions of computing `poolId` for `PoolKey`. Declare two mappings as counters for `beforeSwap` and `afterSwap`.

```solidity
contract SwapHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}
```



Override `getHookPermissions()` from `BaseHook` to return a struct of permissions to signal which hook functions are to be implemented. It will also be used at deployment to validate the hook address correctly represents the expected permissions.

```solidity
function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: false,
        afterAddLiquidity: false,
        beforeRemoveLiquidity: false,
        afterRemoveLiquidity: false,
        beforeSwap: true,
        afterSwap: true,
        beforeDonate: false,
        afterDonate: false,
        beforeSwapReturnDelta: false,
        afterSwapReturnDelta: false,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
```



## beforeSwap

Here the example shows that every time **before** a swap is executed in a pool, `beforeSwapCount` for that pool will be incremented by one.

```solidity
function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    override
    returns (bytes4, BeforeSwapDelta, uint24)
{
    beforeSwapCount[key.toId()]++;
    return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
}
```



### `beforeSwap` Parameters

When triggering the `beforeSwap` hook function, there are some parameters we can make use of to customize or extend the behavior of `swap`. These parameters are described in [`beforeSwap`](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks#beforeswap) from `IHooks`.

A brief overview of the parameters:

- `sender` The initial `msg.sender` for the `PoolManager.swap` call - typically a swap router
- `key` The key for the pool
- `params` The parameters for the swap i.e. [`SwapParams`](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IPoolManager`
- `hookData` Arbitrary data handed into the `PoolManager` by the swapper to be passed on to the hook

## afterSwap

Similiar as above, every time **after** a swap is executed in a pool, `afterSwapCount` for that pool will be incremented by one.

```solidity
function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    internal
    override
    returns (bytes4, int128)
{
    afterSwapCount[key.toId()]++;
    return (BaseHook.afterSwap.selector, 0);
}
```



### `afterSwap` Parameters

When triggering the `afterSwap` hook function, there are some parameters we can make use of to customize or extend the behavior of `swap`. These parameters are described in [`afterSwap`](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IHooks`.

A brief overview of the parameters:

- `sender` The initial `msg.sender` for the `PoolManager.swap` call - typically a swap router
- `key` The key for the pool
- `params` The parameters for the swap i.e. [`SwapParams`](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IPoolManager`
- `delta` The amount owed to the caller (positive) or owed to the pool (negative)
- `hookData` Arbitrary data handed into the `PoolManager` by the swapper to be passed on to the hook

## A Complete Swap Hook Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract SwapHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        beforeSwapCount[key.toId()]++;
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
        internal
        override
        returns (bytes4, int128)
    {
        afterSwapCount[key.toId()]++;
        return (BaseHook.afterSwap.selector, 0);
    }
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartHooks[Liquidity Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/liquidity)

# Liquidity Hooks

This guide will walk through on an example of adding and removing liquidity. There are four hook functions available to customize and extend these behavior:

- `beforeAddLiquidity`
- `afterAddLiquidity`
- `beforeRemoveLiquidity`
- `afterRemoveLiquidity`

As the names suggest `beforeAddLiquidity`/`afterAddLiquidity` are functions called before or after liquidity is added to a pool. Similarly `beforeRemoveLiquidity`/`afterRemoveLiquidity` are functions called before or after liquidity is removed from a pool.

This guide will go through the parameters and examples specifically for `beforeAddLiquidity` and `beforeRemoveLiquidity`.

Note: The liquidity examples are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, since transient storage is used the solidity version will be `>=0.8.24`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
```



Import the relevant dependencies from `v4-core` and `v4-periphery`:

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
```



Create a contract called LiquidityHook, use `PoolIdLibrary` to attach functions of computing ID of a pool to `PoolKey`. Declare two mappings to act as counters when calling `beforeAddLiquidity` and `beforeRemoveLiquidity`.

```solidity
contract LiquidityHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}
```



Override `getHookPermissions` from `BaseHook.sol` to return a struct of permissions to signal which hook functions are to be implemented. It will also be used at deployment to validate the address correctly represents the expected permissions.

```solidity
function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: true,
        afterAddLiquidity: false,
        beforeRemoveLiquidity: true,
        afterRemoveLiquidity: false,
        beforeSwap: false,
        afterSwap: false,
        beforeDonate: false,
        afterDonate: false,
        beforeAddLiquidityReturnDelta: false,
        afterSwapReturnDelta: false,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
```



## beforeAddLiquidity

Here the example shows that every time **before** liquidity is added to a pool, `beforeAddLiquidityCount` for that pool will be incremented by one.

```solidity
function _beforeAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata
) internal override returns (bytes4) {
    beforeAddLiquidityCount[key.toId()]++;
    return BaseHook.beforeAddLiquidity.selector;
}
```



### `beforeAddLiquidity` Parameters

When triggering the `beforeAddLiquidity` hook function, there are some parameters we can make use of to customize or extend the behavior of `modifyLiquidity`. These parameters are described in `beforeAddLiquidity` from [`IHooks.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IHooks.sol#L47).

A brief overview of the parameters:

- `sender` The initial `msg.sender` for the add liquidity call
- `key` The key for the pool
- `params` The parameters for adding liquidity i.e. `ModifyLiquidityParams` from [`IPoolManager.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IPoolManager.sol#L125C12-L125C33)
- `hookData` Arbitrary data handed into the `PoolManager` by the liquidity provider to be be passed on to the hook

## beforeRemoveLiquidity

Similiar as above, every time **before** liquidity is removed from a pool, `beforeRemoveLiquidityCount` for that pool will be incremented by one.

```solidity
function _beforeRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata
) internal override returns (bytes4) {
    beforeRemoveLiquidityCount[key.toId()]++;
    return BaseHook.beforeRemoveLiquidity.selector;
}
```



### `beforeRemoveLiquidity` Parameters

When triggering the `beforeRemoveLiquidity` hook function, there are some parameters we can make use of to customize or extend the behavior of `modifyLiquidity`. These parameters are described in `beforeRemoveLiquidity` from [`IHooks.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IHooks.sol#L78).

A brief overview of the parameters:

- `sender` The initial msg.sender for the remove liquidity call
- `key` The key for the pool
- `params` The parameters for removing liquidity i.e. `ModifyLiquidityParams` from [`IPoolManager.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IPoolManager.sol#L125C12-L125C33)
- `hookData` Arbitrary data handed into the `PoolManager` by the liquidity provider to be be passed on to the hook

## A Complete Liquidity Hook Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract LiquidityHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeAddLiquidityReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeAddLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeAddLiquidityCount[key.toId()]++;
        return BaseHook.beforeAddLiquidity.selector;
    }

    function _beforeRemoveLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeRemoveLiquidityCount[key.toId()]++;
        return BaseHook.beforeRemoveLiquidity.selector;
    }
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstartHooks[AsyncSwap Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/async-swap)

# AsyncSwap Hooks

One feature enabled by [custom accounting](https://docs.uniswap.org/contracts/v4/guides/custom-accounting) is‌ AsyncSwap swap. This feature allows hook developers to replace the v4 (v3-style) swap logic.

This means developers can replace Uniswap's internal core logic for how to handle swaps. Two emergent use-cases are possible with custom accounting:

1. Asynchronous swaps and swap-ordering. Delay the v4 swap logic for fulfillment at a later time.
2. Custom Curves. Replace the v4 swap logic with different swap logic. The custom logic is flexible and developers can implement symmetric curves, asymmetric curves, or custom quoting.

> AsyncSwap is typically described as taking the full input to replace the internal swap logic, partially taking the input is better described as *custom accounting*

Note: The flexibility of AsyncSwap means hook developers can implement harmful behavior (such as taking all swap amounts for themselves, charging extra fees, etc.). Hooks with AsyncSwap behavior should be examined very closely by both developers and users.

## Configure a AsyncSwap Hook

To enable AsyncSwap, developers will need the hook permission `BEFORE_SWAP_RETURNS_DELTA_FLAG`

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
// ...

contract AsyncSwapHook is BaseHook {
    // ...

    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // ...
}
```



## beforeSwap

AsyncSwap only works on exact-input swaps and the *beforeSwap* **must** take the input currency and return [`BeforeSwapDelta`](https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta). The hook should `IPoolManager.mint` itself the corresponding tokens equal to the amount of the input (`amountSpecified`). It should then return a `BeforeSwapDelta` where `deltaSpecified = -amountSpecified` (the positive amount).

The funds' movements are as follows:

1. User initiates a swap, specifying -100 tokenA as input
2. The hook's beforeSwap takes 100 tokenA for itself, and returns a value of 100 to PoolManager.
3. The PoolManager accounts the 100 tokens against the swap input, leaving 0 tokens remaining
4. The PoolManager does not execute swap logic, as there are no tokens left to swap
5. The PoolManager transfers the delta from the hook to the swap router, in step 2 the hook created a debt (that must be paid)
6. The swap router pays off the debt using the user's tokens

```solidity
contract AsyncSwapHook is BaseHook {
     // ...

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        // AsyncSwap only works on exact-input swaps
        if (params.amountSpecified < 0) {
            // take the input token so that v3-swap is skipped...
            Currency input = params.zeroForOne ? key.currency0 : key.currency1;
            uint256 amountTaken = uint256(-params.amountSpecified);
            poolManager.mint(address(this), input.toId(), amountTaken);

            // to AsyncSwap the exact input, we return the amount that's taken by the hook
            return (BaseHook.beforeSwap.selector, toBeforeSwapDelta(amountTaken.toInt128(), 0), 0);
        }
        else {
            return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO, 0);
        }

    }
}
```



## Testing

To verify the AsyncSwap behaved properly, developers should test the swap and that token balances match expected behavior.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {Deployers} from "v4-core/test/utils/Deployers.sol";
// ...

contract AsyncSwapTest is Test, Deployers {
    // ...

    function setUp() public {
        // ... 
    }

    function test_asyncSwap() public {
        assertEq(hook.beforeSwapCount(poolId), 0);

        uint256 balance0Before = currency0.balanceOfSelf();
        uint256 balance1Before = currency1.balanceOfSelf();

        // Perform a test swap //
        int256 amount = -1e18;
        bool zeroForOne = true;
        BalanceDelta swapDelta = swap(poolKey, zeroForOne, amount, ZERO_BYTES);
        // ------------------- //

        uint256 balance0After = currency0.balanceOfSelf();
        uint256 balance1After = currency1.balanceOfSelf();

        // user paid token0
        assertEq(balance0Before - balance0After, 1e18);

        // user did not recieve token1 (AsyncSwap)
        assertEq(balance1Before, balance1After);
    }
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolQuickstart[Subscriber](https://docs.uniswap.org/contracts/v4/quickstart/subscriber)

# Subscriber

### Context

For developers looking to support custom *liquidity mining*, Subscriber contracts can be used to receive notifications about position modifications or transfers.

## Guide

### 1. Implement the [`ISubscriber`](https://github.com/Uniswap/v4-periphery/blob/main/src/interfaces/ISubscriber.sol) interface

Can also refer to [MockSubscriber](https://github.com/Uniswap/v4-periphery/blob/main/test/mocks/MockSubscriber.sol) for an actual implementation example.

```solidity
import {ISubscriber} from "v4-periphery/src/interfaces/ISubscriber.sol";

contract MySubscriber is ISubscriber {
    uint256 public notifySubscribeCount;
    uint256 public notifyUnsubscribeCount;
    uint256 public notifyModifyLiquidityCount;
    uint256 public notifyBurnCount;
    // other implementations...

    function notifySubscribe(uint256, bytes memory) external onlyByPosm {
        notifySubscribeCount++;
    }

    function notifyUnsubscribe(uint256) external onlyByPosm {
        notifyUnsubscribeCount++;
    }

    function notifyModifyLiquidity(uint256, int256, BalanceDelta) external onlyByPosm {
        notifyModifyLiquidityCount++;
    }

    function notifyBurn(uint256, address, PositionInfo, uint256, BalanceDelta)
        external
        onlyByPosm
    {
        notifyBurnCount++;
    }
}
```



### 2. A caveat on `unsubscribe()`

To prevent gas griefing during unsubscription, Uniswap v4 sets a fixed variable [`unsubscribeGasLimit`](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/INotifier#unsubscribegaslimit) when calling a subscriber’s `notifyUnsubscribe()` function.

Without this limit, malicious subscribers could prevent liquidity providers from unsubscribing. If `notifyUnsubscribe()` were to consume too much gas, it would cause the unsubscription transaction to revert, thus leading to a denial-of-service

With the gas limit in place, if the subscriber’s notification fails, the unsubscription will still succeed and only the notification to the subscriber is skipped.

From [`_unsubscribe()`](https://github.com/Uniswap/v4-periphery/blob/main/src/base/Notifier.sol#L80) on `Notifier`:

```solidity
if (address(_subscriber).code.length > 0) {
    // require that the remaining gas is sufficient to notify the subscriber
    // otherwise, users can select a gas limit where .notifyUnsubscribe hits OutOfGas yet the
    // transaction/unsubscription can still succee
    if (gasleft() < unsubscribeGasLimit) GasLimitTooLow.selector.revertWith();
    try _subscriber.notifyUnsubscribe{gas: unsubscribeGasLimit}(tokenId) {} catch {}
}
```



### 3. Opt-in to a subscriber contract

To opt-in to a subscriber contract, call [`subscribe()`](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/INotifier#subscribe) on `PositionManager`.

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

IPositionManager posm = IPositionManager(<address>);
ISubscriber mySubscriber = ISubscriber(<address>);

bytes memory optionalData = ...;
posm.subscribe(tokenId, mySubscriber, optionalData);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuidesHooks[Building Your First Hook](https://docs.uniswap.org/contracts/v4/guides/hooks/your-first-hook)

# Building Your First Hook

## Introduction

Uniswap introduced the v4 of their protocol introducing several new concepts such as hooks, flash accounting, singleton architecture and more. The most interesting of these for developers is hooks, and that’s what we’ll be learning about today.

In this guide, we’ll be conceptualizing, understanding and building a basic points hook, which will give you some idea of how to build your own hook.

## What are we building?

Let’s start by conceptualizing what we’re building today and why. Let’s say you have a token named `TOKEN` that you want to incentivize people to buy. One way of doing so is awarding people points when they buy your token. Prior to v4, you’d have to do this off-chain or via your own helper contract outside of the swap logic, but in v4 you can enable universal access using hooks.

Let’s start by defining when users will be rewarded with these points:

1. When the user swaps `ETH` into `TOKEN` they will get awarded points equal to how much `ETH` they swapped the token with.
2. When the user adds liquidity, we award them with points equal to the amount of `ETH` they added.

In order to keep track of these points, we’ll mint the `POINTS` token to the user, this has an added benefit for the user to be able to track it in their wallet.

## Hook Design

Let’s figure out how our hook will work.

From the Uniswap v4 Documentation, there are several hooks available for developers to integrate with. In our use case, we specifically need the ability to read swaps and figure out what amounts they are swapping for and who they are.

For our hook, we’ll be using `afterSwap` and `afterAddLiquidity` hooks. Why these instead of the `before...` hooks? We’ll dig deeper into this later in this guide.

*Note: To initiate the swap in the first place, this is where [`UniversalRouter`](https://docs.uniswap.org/contracts/universal-router/overview) comes into play where we will pass in the [`V4_SWAP`](https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol#L35) command to `UniversalRouter.execute`.*

## Let’s create our hook!

We’ll call this hook `PointsHook` and create it in such a way that any pool paired with `TOKEN` can use it.

### Setting things up

The Uniswap [v4-template repo](https://github.com/uniswapfoundation/v4-template) provides a basic foundry environment with required imports already pre-loaded. Click on [`Use this template`](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation) to create a new repository with it.

Or simply clone it and install the dependencies:

```bash
git clone https://github.com/uniswapfoundation/v4-template.git
cd v4-template
# requires foundry
forge install
forge test
```



After that let's create a new contract `PointsHook.sol` in `src` folder with the following codes:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract PointsHook is BaseHook {
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: true,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: false,
                afterSwap: true,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }
}
```



The above code does the following:

- import the relevant dependencies
- initialize the constructor by passing in the instance of PoolManager
- override `getHookPermissions` from `BaseHook.sol` to return a struct of permissions to signal which hook functions are to be implemented. It will also be used at deployment to validate the address correctly represents the expected permissions.

Awesome! Now it's all set to start building the hook!

### Basic Structure

So far, we’ve created the file named `PointsHook.sol` which only contains the outline of a hook contract. Let’s add our `afterSwap` and `afterAddLiquidity` hooks to it.

```solidity
contract PointsHook is BaseHook {
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: true,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: false,
                afterSwap: true,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }

    function _afterSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        return (BaseHook.afterSwap.selector, 0);
    }

    function _afterAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) internal override returns (bytes4, BalanceDelta) {
        return (BaseHook.afterAddLiquidity.selector, delta);
    }
}
```



You’ll notice that both hooks return their own selector in the functions, this is a pattern used by the protocol to signal “successful” invocation. We’ll talk about rest of the return parameters when we start adding the functionality.

Most of the code at this point should be self-explanatory. It’s not doing anything yet, but it’s a great place to start adding the functionality we need.

### Points Logic

First, let’s setup the `POINTS` token that we’ll reward users with via creating another contract `PointsToken.sol` and import relevant dependencies like `ERC20` and `Owned`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import {ERC20} from "solmate/src/tokens/ERC20.sol";
import {Owned} from "solmate/src/auth/Owned.sol";

contract PointsToken is ERC20, Owned {
    constructor() ERC20("Points Token", "POINTS", 18) Owned(msg.sender) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}
```



Let’s make it so that our hook can mint some!

```solidity
contract PointsHook is BaseHook {
    PointsToken public pointsToken;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {
        pointsToken = new PointsToken();
    }

    [...]
}
```



Next, we need to calculate how many points to assign based on the `ETH` value of the swap or liquidity action. We’ll be awarding `POINTS` in 1:1 ratio for the `ETH`, so if the user swapped 1 `ETH`, we’ll give them 1 `POINTS`. Let’s also create a function to award these to the user.

```solidity
    function getPointsForAmount(
        uint256 amount
    ) internal pure returns (uint256) {
        return amount; // 1:1 with ETH
    }

    function awardPoints(address to, uint256 amount) internal {
        pointsToken.mint(to, getPointsForAmount(amount));
    }
```



### Hook Logic

Now we need to actually get the value that the user is swapping or adding liquidity with. We’ll be using the two hooks to achieve that functionality.

#### Getting the user address

Before we go into the logic for the hook, we have a side quest! How do we actually get the address of the user? The `PositionManager` doesn’t pass the user address directly to the hook, mainly because of the complexity of getting that data in the first place.

You’d have noticed, both of our hooks have a `hookData` field at the end. This allows any arbitrary data to be passed to the hook at the time of invocation, and we’ll use this field to encode the user address.

Let’s create some helper functions to encode and decode this data:

```solidity
    function getHookData(address user) public pure returns (bytes memory) {
        return abi.encode(user);
    }

    function parseHookData(
        bytes calldata data
    ) public pure returns (address user) {
        return abi.decode(data, (address));
    }
```



#### Hook Logic: `afterSwap`

In order for us to award these points to the user, we need a few things and we also need to create a few conditions.

Let’s start with the most basic ones. We want the user to be swapping in the `ETH/TOKEN` pool and be buying the `TOKEN` in order to get awarded these `POINTS` token. Next, we need to figure out who the user is and how much ETH they are spending, and finally award the points accordingly.

```solidity
    function _afterSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata swapParams,
        BalanceDelta delta,
        bytes calldata hookData
    ) internal override onlyPoolManager returns (bytes4, int128) {
        // We only award points in the ETH/TOKEN pools.
        if (!key.currency0.isAddressZero()) {
            return (BaseHook.afterSwap.selector, 0);
        }

        // We only award points if the user is buying the TOKEN
        if (!swapParams.zeroForOne) {
            return (BaseHook.afterSwap.selector, 0);
        }

        // Let's figure out who's the user
        address user = parseHookData(hookData);

        // How much ETH are they spending?
        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));

        // And award the points!
        awardPoints(user, ethSpendAmount);

        return (BaseHook.afterSwap.selector, 0);
    }
```



That middle section about figuring out how much `ETH` the user spent seems a little fishy, what’s going on there? Let’s break it down.

When `amountSpecified` is less than 0, it means this is an `exact input for output` swap, essentially where the user is coming in with an exact amount of ETH. In the other case, it’s an `exact output for input` swap, where the user is expecting a specific amount out. In our case, we get this from the precalculated `delta` that Uniswap V4 gives us as a part of the `afterSwap` hook.

#### Hook Logic: `afterAddLiquidity`

Similar to what we did for the `afterSwap` hook, now we need to award users for adding liquidity. We’ll do the exact same thing here, except we’ll award the points based on the added liquidity.

```solidity
    function _afterAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) internal override onlyPoolManager returns (bytes4, BalanceDelta) {
        // We only award points in the ETH/TOKEN pools.
        if (!key.currency0.isAddressZero()) {
            return (BaseHook.afterAddLiquidity.selector, delta);
        }

        // Let's figure out who's the user
        address user = parseHookData(hookData);

        // How much ETH are they spending?
        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));

        // And award the points!
        awardPoints(user, ethSpendAmount);

        return (BaseHook.afterAddLiquidity.selector, delta);
    }
```



note

It is important to note that the delta should be passed to awardPoints function as it avoids amount errors in case of partial fills.

## Testing

We’re using Foundry for building our hook, and we’ll continue using it to write our tests. One of the great things about Foundry is that you can write tests in Solidity itself instead of context switching between another language.

### Test Suite

The v4-template repo you cloned already has an existing base test file, let’s start by copying it into `PointsHook.t.sol`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {Fixtures} from "./utils/Fixtures.sol";
import {EasyPosm} from "./utils/EasyPosm.sol";

import {StateLibrary} from "v4-core/src/libraries/StateLibrary.sol";
import {Hooks, IHooks} from "v4-core/src/libraries/Hooks.sol";
import {PointsHook} from "../src/PointsHook.sol";
import {PointsToken} from "../src/PointsToken.sol";

import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId} from "v4-core/src/types/PoolId.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {TickMath} from "v4-core/src/libraries/TickMath.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {LiquidityAmounts} from "v4-core/test/utils/LiquidityAmounts.sol";

contract PointsHookTest is Test, Fixtures {
    using EasyPosm for IPositionManager;
    using StateLibrary for IPoolManager;

    PointsHook hook;
    PointsToken pointsToken;
    PoolId poolId;

    uint256 tokenId;
    int24 tickLower;
    int24 tickUpper;

    function setUp() public {
        // creates the pool manager, utility routers, and test tokens
        deployFreshManagerAndRouters();
        deployMintAndApprove2Currencies();

        deployAndApprovePosm(manager);

        // Deploy the hook to an address with the correct flags
        address flags = address(
            uint160(Hooks.AFTER_SWAP_FLAG | Hooks.AFTER_ADD_LIQUIDITY_FLAG) ^
                (0x4444 << 144) // Namespace the hook to avoid collisions
        );
        bytes memory constructorArgs = abi.encode(manager); //Add all the necessary constructor arguments from the hook
        deployCodeTo("PointsHook.sol:PointsHook", constructorArgs, flags);
        hook = PointsHook(flags);
        pointsToken = hook.pointsToken();

        // Create the pool
        key = PoolKey(
            Currency.wrap(address(0)),
            currency1,
            3000,
            60,
            IHooks(hook)
        );
        poolId = key.toId();
        manager.initialize(key, SQRT_PRICE_1_1);

        // Provide full-range liquidity to the pool
        tickLower = TickMath.minUsableTick(key.tickSpacing);
        tickUpper = TickMath.maxUsableTick(key.tickSpacing);

        deal(address(this), 200 ether);

        (uint256 amount0, uint256 amount1) = LiquidityAmounts
            .getAmountsForLiquidity(
                SQRT_PRICE_1_1,
                TickMath.getSqrtPriceAtTick(tickLower),
                TickMath.getSqrtPriceAtTick(tickUpper),
                uint128(100e18)
            );

        (tokenId, ) = posm.mint(
            key,
            tickLower,
            tickUpper,
            100e18,
            amount0 + 1,
            amount1 + 1,
            address(this),
            block.timestamp,
            hook.getHookData(address(this))
        );
    }

    function test_PointsHook_Swap() public {
        // [code here]
    }
}
```



So far this test setup is fairly simple, we create a bunch of tokens and deploy v4 along with the position manager inside our test. Then, we create a pool with our hook and add some liquidity using the position manager.

Now, let’s write our test. We’ll start by testing the points awarded during the swap.

```solidity
    function test_PointsHook_Swap() public {
        // We already have some points because we added some liquidity during setup.
        // So, we'll subtract those from the total points to get the points awarded for this swap.
        uint256 startingPoints = pointsToken.balanceOf(address(this));

        // Let's swap some ETH for the token.
        bool zeroForOne = true;
        int256 amountSpecified = -1e18; // negative number indicates exact input swap!
        BalanceDelta swapDelta = swap(
            key,
            zeroForOne,
            amountSpecified,
            hook.getHookData(address(this))
        );

        uint256 endingPoints = pointsToken.balanceOf(address(this));

        // Let's make sure we got the right amount of points!
        assertEq(
            endingPoints - startingPoints,
            uint256(-amountSpecified),
            "Points awarded for swap should be 1:1 with ETH"
        );
    }
```



This test case is fairly straightforward and simply swaps 1 ETH for the target token and compares if we got the right amount of points awarded for it.

Next, we should test our liquidity addition.

```solidity
function test_PointsHook_Liquidity() public {
        // We already have some points because we added some liquidity during setup.
        // So, we'll subtract those from the total points to get the points awarded for this swap.
        uint256 startingPoints = pointsToken.balanceOf(address(this));

        uint128 liqToAdd = 100e18;

        (uint256 amount0, uint256 amount1) = LiquidityAmounts
            .getAmountsForLiquidity(
                SQRT_PRICE_1_1,
                TickMath.getSqrtPriceAtTick(tickLower),
                TickMath.getSqrtPriceAtTick(tickUpper),
                liqToAdd
            );

        posm.mint(
            key,
            tickLower,
            tickUpper,
            liqToAdd,
            amount0 + 1,
            amount1 + 1,
            address(this),
            block.timestamp,
            hook.getHookData(address(this))
        );

        uint256 endingPoints = pointsToken.balanceOf(address(this));

        // Let's make sure we got the right amount of points!
        assertApproxEqAbs(endingPoints - startingPoints, uint256(liqToAdd), 10);
    }
```



This test case looks very similar to the `afterSwap` one, except we’re testing based on the liquidity added. You’ll notice at the end we’re testing for approximate equality within 10 points. This is to account for minor differences in actual liquidity added due to ticks and pricing.

## Next Steps

Congratulations on building your very first hook! You could explore further by going to [Hook Deployment](https://docs.uniswap.org/contracts/v4/guides/hooks/05-hook-deployment.mdx) to learn about how hook flags work and see how we will deploy a hook in action.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuidesHooks[Hook Deployment](https://docs.uniswap.org/contracts/v4/guides/hooks/hook-deployment)

# Hook Deployment

## Hook Flags

As mentioned in [Concept of Hooks](https://docs.uniswap.org/contracts/v4/concepts/hooks), hook contracts indicate their implemented functions by **encoding its behavior in the address of the contract**. The `PoolManager` uses these permissions to determine which hook functions to call for a given pool. See `PoolManager` deployment addresses [here](https://docs.uniswap.org/contracts/v4/deployments).

Each hook function e.g. `beforeSwap` - corresponds to a certain *flag*. For example, the `beforeSwap` function is correlated to the [`BEFORE_SWAP_FLAG`](https://github.com/Uniswap/v4-core/blob/main/src/libraries/Hooks.sol#L37) which has a value of `1 << 7`.

These flags represent specific bits in the address of the hook smart contract - and the value of the bit (a one or a zero) represents whether that flag is true or false. An example:

Addresses on Ethereum are 20 bytes long (160 bits). So for example the address:

```text
0x00000000000000000000000000000000000000C0
```



represented in binary is:

```solidity
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 
0000 0000 0000 0000 0000 0000 1100 0000
```



In binary it goes from right-to-left - so the trailing 8 bits of this address are `1100 0000` where:

1st Bit to 6th Bit = `0`

7th Bit and 8th Bit = `1`

The `AFTER_SWAP` flag is represented by the 7th bit - which is set to `1` for the example contract address. In the `PoolManager` swap execution flow, it will observe the flag and make a call to the hook's `afterSwap` function.

Similarly, the 8th bit which is also a `1`, actually corresponds to the `BEFORE_SWAP` i.e. the `beforeSwap` hook function - which will also be called by the `PoolManager` during a `swap` workflow.

A full list of all flags can be found [here](https://github.com/Uniswap/v4-core/blob/main/src/libraries/Hooks.sol).

## Hook Miner

Because of encoded addresses, hook developers must *mine* an address to a their particular pattern.

For local testing, `deployCodeTo` cheatcode in Foundry can be used to deploy hook contract to any address.

But when deploying hooks to an actual network, address mining is required to find the proper deployment address There is a helper library [`HookMiner.sol`](https://github.com/Uniswap/v4-periphery/blob/main/src/utils/HookMiner.sol) that can be used to mine for correct addresses.

Let's see it in action for a Foundry script. We will make use of the example - Points Hook from [Building Your First Hook](https://docs.uniswap.org/contracts/v4/guides/hooks/01-your-first-hook.md).

First we set up the contract for Foundry script and import the relevant dependencies:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {HookMiner} from "v4-periphery/src/utils/HookMiner.sol";

import {Constants} from "./base/Constants.sol";
import {PointsHook} from "../src/PointsHook.sol";

/// @notice Mines the address and deploys the PointsHook.sol Hook contract
contract PointsHookScript is Script, Constants {
    function setUp() public {}

    function run() public {
```



Specify the flags needed to be encoded in the address:

```solidity
uint160 flags = uint160(
    Hooks.AFTER_ADD_LIQUIDITY_FLAG | Hooks.AFTER_SWAP_FLAG
);
```



Mine the address by finding a `salt` that produces a hook address with the desired `flags`, use the Foundry deterministic deployer when deploying via Foundry script. For most chains, CREATE2_DEPLOYER contract address is [0x4e59b44847b379578588920ca78fbf26c0b4956c](https://book.getfoundry.sh/guides/deterministic-deployments-using-create2#getting-started).

```solidity
bytes memory constructorArgs = abi.encode(POOLMANAGER);
(address hookAddress, bytes32 salt) =
    HookMiner.find(CREATE2_DEPLOYER, flags, type(PointsHook).creationCode, constructorArgs);
```



**CREATE2_DEPLOYER**

- `CREATE2_DEPLOYER` is the address that will deploy the hook. In `forge test`, this will be the test contract `address(this)` or the pranking address.
- In `forge script`, this should be `0x4e59b44847b379578588920cA78FbF26c0B4956C` (CREATE2 Deployer Proxy)

Refer to this for more details on deploying contracts with CREATE2: [Deploying Contracts with CREATE2](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)

Deploy the hook using CREATE2 with the `salt`, and compare the deployed address with the address mined:

```solidity
vm.broadcast();
PointsHook pointsHook = new PointsHook{salt: salt}(IPoolManager(POOLMANAGER));
require(address(pointsHook) == hookAddress, "PointsHookScript: hook address mismatch");
```



## A Complete Foundry Script Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {HookMiner} from "v4-periphery/src/utils/HookMiner.sol";

import {Constants} from "./base/Constants.sol";
import {PointsHook} from "../src/PointsHook.sol";

/// @notice Mines the address and deploys the PointsHook.sol Hook contract
contract PointsHookScript is Script, Constants {
    function setUp() public {}

    function run() public {
        // hook contracts must have specific flags encoded in the address
        uint160 flags = uint160(
            Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_SWAP_FLAG | Hooks.BEFORE_ADD_LIQUIDITY_FLAG
                | Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG
        );

        // Mine a salt that will produce a hook address with the correct flags
        bytes memory constructorArgs = abi.encode(POOLMANAGER);
        (address hookAddress, bytes32 salt) =
            HookMiner.find(CREATE2_DEPLOYER, flags, type(PointsHook).creationCode, constructorArgs);

        // Deploy the hook using CREATE2
        vm.broadcast();
        PointsHook pointsHook = new PointsHook{salt: salt}(IPoolManager(POOLMANAGER));
        require(address(pointsHook) == hookAddress, "PointsHookScript: hook address mismatch");
    }
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Unlock Callback & Deltas](https://docs.uniswap.org/contracts/v4/guides/unlock-callback)

# Unlock Callback & Deltas

### Refresher

In order to have access to the liquidity inside the `PoolManager`, it needs to be *unlocked* to begin with. After being unlocked, any number of operations can be executed, which at the end of must be *locked* again. At this point, if there are any *non-zero deltas*, meaning the PoolManager is owed or owes tokens back to some address, the whole execution reverts. Otherwise, both parties have paid or received the right amount of tokens and the operations have successfully carried out.

## Unlocking the PoolManager

### Implementing the unlock callback

Prior to unlocking the PoolManager, the integrating contract must implement the `unlockCallback` function. This function will be called by the PoolManager after being unlocked. An easy way to do this is to inherit the `SafeCallback` abstract contract.

```solidity
import {SafeCallback} from "v4-periphery/src/base/SafeCallback.sol";

contract IntegratingContract is SafeCallback {
    constructor(IPoolManager _poolManager) SafeCallback(_poolManager) {}
}
```



### Calling the unlock function

After implementing the callback, the integrating contract can now invoke the `unlock()` function. It receives a *bytes* parameter that is further passed to your callback function as an argument. This parameter is used to encode the sequence of operations to be executed in the context of the `PoolManager`.

```solidity
bytes memory unlockData = abi.encode(encode_operations_here);
bytes memory unlockResultData = poolManager.unlock(unlockData);
```



Next, we must override the `_unlockCallback` function inherited from the `SafeCallback` contract. In your implementation, you should decode your operations and continue with the desired logic.

```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory) {
    (...) = abi.decode(data, (...));
}
```



## Operations

There are **9** operations that can be done in the `PoolManager` which fall in two categories: *liquidity-accessing* and *delta-resolving*.

### Deltas

Deltas are the `PoolManager`'s method to keep track of token amounts it needs to receive, respectively to distribute. A negative delta signals that the `PoolManager` is owed tokens, while a positive one expresses a token balance that needs to be paid to its user.

### Liquidity-accessing

*Liquidity-accessing* operations will create non-zero *deltas* and produce a state transition of the selected pool. They are the following:

- *modify liquidity* - used to increase or decrease liquidity; increasing liquidity will result in a negative token delta, while decreasing yields a positive one
- *swap* - used to trade one token for another; will result in a negative tokenA delta and a positive tokenB delta
- *donate* - used to provide direct token revenue to positions in range; will result in a negative delta for the pool's tokens the user wishes to provide

### Delta-resolving

*Delta-resolving* operations are used to even out the deltas created by the *liquidity-accessing* operations. They are the following:

- *settle* - used following token transfers to the manager or burning of ERC6909 claims to resolve negative deltas
- *take* - transfer tokens from the manager, used to resolve positive deltas but also provide token loans, producing negative deltas
- *mint* - used to create ERC6909 claims, creating a negative delta that needs to be resolved by transferring the corresponding token and *settling* afterwards
- *burn* - removes ERC6909 claims, creating a positive delta for tokens to be transferred back to the owner or used in settling negative balances
- *clear* - used to zero out positive token deltas, helpful to forfeit insignificant token amounts in order to avoid paying further transfer costs

### Handling Deltas for Liquidity Modifications

#### When it happens

- **Building custom routers** that pre-calculate token amounts.
- **Estimating values** for user interfaces or simulations.

#### Why It Happens

- **Pre-calculated amounts** (e.g., from `LiquidityAmounts.getAmountsForLiquidity()`) use static math.

- Actual deltas

   

  (from

   

  ```
  modifyLiquidity()
  ```

  ) reflect real-time pool state, including:

  - Tick crossings during execution.
  - Rounding in fixed-point arithmetic (`Q128.128`).

#### Why LiquidityAmounts ≠ Liquidity Delta

The discrepancy occurs because:

- **Price Movement:** The pool's price changes between pre-calculation and execution
- **Tick Crossings:** Transactions may cross ticks, changing liquidity math
- **Rounding:** Static calculations use idealized math while execution uses Q128.128 fixed-point

#### 📊 Price Movement Example

When ETH/USDC price changes during transaction execution:

```solidity
// Static math calculation
LiquidityAmounts.getAmountsForLiquidity(
    sqrtRatioX96: 3000, // Fixed price
    ...
);

// Interacts with the pool and uses actual execution (reflects real-time price)
poolManager.modifyLiquidity(
    sqrtRatioX96: 3001, // Updated price
    ...
);
```



getAmountsForLiquidity() assumes static 3000 price modifyLiquidity() reflects actual 3001 price

#### Key Impact

| Scenario                   | Risk                                           |
| -------------------------- | ---------------------------------------------- |
| **Underestimating deltas** | Transactions revert with `CurrencyNotSettled`. |
| **Overestimating deltas**  | Users overpay and lose funds to residual dust. |
| **No slippage check**      | Significant financial losses.                  |

#### Best Practices for Custom Routers

1. **Never settle without validating against slippage**

   Supposing slippage tolerance is 50 (basis point)

   ```solidity
       require(
           actualAmount0 >= expectedAmount0 * (10_000 - slippageTolerance) / 10_000,
           "Slippage too high (token0)"
       );
       require(
           actualAmount1 >= expectedAmount1 * (10_000 - slippageTolerance) / 10_000,
           "Slippage too high (token1)"
       );
   ```

   

2. **Use Deltas for Settlement**
   Always derive final amounts from `modifyLiquidity()` deltas:

   ```solidity
        CallbackData memory _data = abi.decode(data, (CallbackData));
        (BalanceDelta delta, ) = poolManager.modifyLiquidity(
            _data.key,
            _data.params,
            hex""
        );
        
        _data.key.currency0.settle(poolManager, _data.key.hookAddress, delta.amount0() < 0
            ? uint256(uint128(-delta.amount0()))
            : uint256(uint128(delta.amount0())), false);
         _data.key.currency1.settle(poolManager, _data.key.hookAddress, delta.amount1() < 0
            ? uint256(uint128(-delta.amount1()))
            : uint256(uint128(delta.amount1())), false);
   ```

   

> ⚠️ **Custom Router Pitfall**
> When pre-calculating liquidity changes, always account for rounding differences.
> **Never** assume `getAmountsForLiquidity() == modifyLiquidity()` deltas. Enforce slippage post-execution.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Reading Pool State](https://docs.uniswap.org/contracts/v4/guides/read-pool-state)

# Reading Pool State

## Introduction

Unlike previous versions, v4 uses a different approach for storing and accessing pool data, which requires understanding the use of [`StateLibrary`](https://docs.uniswap.org/contracts/v4/reference/core/libraries/StateLibrary) and [`extsload`](https://docs.uniswap.org/contracts/v4/reference/core/Extsload).

## Understanding the PoolManager Architecture

### The Singleton Design

In Uniswap v4, all pools are managed by a single `PoolManager` contract, unlike v3 where each pool was a separate contract. This design offers simplified management since all pools are now accessible through a single contract.

This approach significantly reduces deployment costs, simplifies protocol upgrades, and enables more efficient cross-pool interactions. It also allows for easier implementation of new features across all pools simultaneously.

### Pools as Library Calls

In v4, pools are stored as complex structs, with Solidity libraries handling state changes. The `PoolManager` contract uses these libraries to perform operations on the pool state:

```solidity
contract PoolManager {
    using Pool for Pool.State;
    mapping(PoolId => Pool.State) internal pools;

    function swap(PoolId id, ...) external {
        pools[id].swap(...); // Library call
    }
}
```



This design allows all AMM logic to be encapsulated within the `PoolManager` contract.

## Reading Pool State in v4

In Uniswap v4, reading pool state involves a few key concepts and mechanisms that differ from previous versions. At the core of this new structure is a complex mapping within the PoolManager contract:

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```



This mapping represents a fundamental shift in pool data storage:

1. Each pool is identified by a unique `PoolId`.
2. The `Pool.State` is a struct that contains all the state variables for a single pool.
3. This struct itself contains several nested mappings and complex data structures.

For example, the `Pool.State` struct might look something like this (simplified for illustration):

```solidity
struct State {
    uint160 sqrtPriceX96;
    int24 tick;
    uint128 liquidity;
    uint256 feeGrowthGlobal0X128;
    uint256 feeGrowthGlobal1X128;
    mapping(int24 => TickInfo) ticks;
    mapping(bytes32 => Position.Info) positions;
    // ... other fields
}
```



This complex structure allows for efficient storage of multiple pools and their associated data within a single contract. However, it also means that traditional getter functions would be inefficient or impractical for accessing this data, especially for nested mappings like `ticks` and `positions`.

To address this, Uniswap V4 introduces the StateLibrary and the concept of using `extsload` for reading pool state. These mechanisms provide efficient ways to access the data stored in this complex structure.

### The StateLibrary and `extsload`

```solidity
abstract contract Extsload is IExtsload {
    /// @inheritdoc IExtsload
    function extsload(bytes32 slot) external view returns (bytes32) {
        assembly ("memory-safe") {
            mstore(0, sload(slot))
            return(0, 0x20)
        }
    }

    // [...]
}
```



The `StateLibrary` is a crucial component in Uniswap v4 for reading pool state. It utilizes the `extsload` function, which is an external wrapper for the `SLOAD` opcode. This allows for efficient reading of arbitrary storage slots.

**How `extsload` works:**

- It takes a storage slot as input.
- It reads the value stored in that slot directly, using `SLOAD`, from the contract's storage.
- It returns the value as a `bytes32`.

This method is more gas-efficient than traditional getter functions, especially when reading multiple storage slots.

Moreover, using `extsload` instead of hand-written Solidity view functions lowers the contract bytecode size. This optimization is particularly important for Uniswap v4, as the core contracts are nearly at Ethereum's contract size limit.

### TransientStateLibrary and `exttload`

```solidity
abstract contract Exttload is IExttload {
    /// @inheritdoc IExttload
    function exttload(bytes32 slot) external view returns (bytes32) {
        assembly ("memory-safe") {
            mstore(0, tload(slot))
            return(0, 0x20)
        }
    }

    // [...]
}
```



While `StateLibrary` deals with persistent storage, [`TransientStateLibrary`](https://docs.uniswap.org/contracts/v4/reference/core/libraries/transient-state-library) is used for handling transient storage. Transient storage, introduced in EIP-1153, is a way to store data that is only needed for the duration of a transaction, making it ideal for temporary data.

It uses the [`exttload`](https://docs.uniswap.org/contracts/v4/reference/core/Exttload) function, which is similar to `extsload`, but for transient storage; it is an external wrapper for the `TLOAD` opcode.

## Implementing a `PoolStateReader` Contract

Let's create a `PoolStateReader` contract that showcases different methods for reading pool state. For each function, we'll explain its purpose, how it works, and provide an example use case.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/types/PoolId.sol";

contract PoolStateReader {
    using PoolIdLibrary for PoolKey;

    IPoolManager public immutable poolManager;

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }

    // Functions will be implemented here
}
```



Before we start, we need to import `StateLibrary` from the libraries available in v4-core.

```solidity
import {StateLibrary} from "v4-core/libraries/StateLibrary.sol";
```



Let's focus on this important line that we should add:

```solidity
using StateLibrary for IPoolManager;
```



This line is crucial for our PoolStateReader contract because it allows us to call StateLibrary functions as if they were methods of the IPoolManager interface, like for instance now we will be able to do `poolManager.getSlot0()`.

Now we’re up for breaking down each wrapper function that we're going to be adding to our helper contract, explain the purpose of the pool manager function to read the state, and provide use cases to make sure we understand its utility:

### `getSlot0()`

```solidity
function getPoolState(PoolKey calldata key) external view returns (
    uint160 sqrtPriceX96,
    int24 tick,
    uint24 protocolFee,
    uint24 lpFee
) {
    return poolManager.getSlot0(key.toId());
}
```



**Explanation:**

This function retrieves the current state of the pool, including its price, tick, and fee settings. It uses the `getSlot0()` function from `StateLibrary`, which efficiently reads these values from a single storage slot.

- `sqrtPriceX96`: The current price, encoded as a square root and scaled by 2^96. This encoding allows for efficient price calculations in the Uniswap algorithm.
- `tick`: The current tick, representing the quantized price. Ticks are used to efficiently track and update liquidity positions.
- `protocolFee`: The current protocol fee, represented in hundredths of a bip (i.e., units of 0.0001%).
- `lpFee`: The current liquidity provider fee, also represented in hundredths of a bip.

**Use Case:**

This function is essential for any application that needs to know the current state of a Uniswap v4 pool. For example:

- A price oracle could use this to get the current price of the pool.
- A trading bot could use this to determine if a trade is profitable given the current price and fees.
- A liquidity management system could use the `tick` to decide where to place new liquidity.

### `getLiquidity()`

```solidity
function getPoolLiquidity(PoolKey calldata key) external view returns (uint128 liquidity) {
    return poolManager.getLiquidity(key.toId());
}
```



**Explanation:**

This function retrieves the current total liquidity in the pool. Liquidity in Uniswap v4 represents the amount of assets available for trading within the current price range.

**Use Case:**

Understanding the total liquidity is crucial for several scenarios:

- Assessing the depth of the market and potential slippage for large trades.
- Monitoring the depth and growth of a pool over time.

### `getPositionInfo`

```solidity
function getPositionInfo(
    PoolKey calldata key,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    bytes32 salt
) external view returns (
    uint128 liquidity,
    uint256 feeGrowthInside0LastX128,
    uint256 feeGrowthInside1LastX128
) {
    return poolManager.getPositionInfo(key.toId(), owner, tickLower, tickUpper, bytes32(salt));
}
```



**Explanation:**

This function retrieves information about a specific liquidity position. It returns:

- `liquidity`: The amount of liquidity in the position.
- `feeGrowthInside0LastX128` and `feeGrowthInside1LastX128`: The last recorded cumulative fees earned per unit of liquidity for each token.

**Use Case:**

This function is crucial for applications that need to manage or analyze individual liquidity positions:

- A liquidity management dashboard could use this to display a user's current positions and earned fees.
- An automated liquidity provision system could use this to decide when to rebalance or compound rewards.
- An analytics tool could use this to calculate the performance of different liquidity provision strategies.

### `getFeeGrowthGlobal`

```solidity
function getFeeGrowthGlobal(PoolKey calldata key) external view returns (
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
) {
    return poolManager.getFeeGrowthGlobal(key.toId());
}
```



**Explanation:**

This function retrieves the global fee growth for both tokens in the pool. These values represent the cumulative fees per unit of liquidity since the pool's inception.

**Use Case:**

Global fee growth is essential for several advanced operations:

- Calculating the fees earned by a position that has been held for a long time.
- Analyzing the overall fee generation of a pool over its lifetime.
- Comparing the performance of different pools or fee tiers.

------

For additional reference, see [`StateLibrary`](https://docs.uniswap.org/contracts/v4/reference/core/libraries/StateLibrary) and [`Extsload`](https://docs.uniswap.org/contracts/v4/reference/core/Extsload)



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Custom Accounting](https://docs.uniswap.org/contracts/v4/guides/custom-accounting)

# Custom Accounting

## Introduction

Uniswap v4 introduces a set of powerful, interconnected features that proposes a new way automated market makers (AMMs) can function. Custom accounting, hook fees, custom curves, and return deltas might seem like distinct concepts, but they form a cohesive system that enables unprecedented flexibility in decentralized exchange mechanisms.

These features are grouped together because they collectively represent the core of Uniswap v4’s customizability. They all relate to how pool state is managed and modified, working in tandem to allow developers to create highly tailored AMM experiences. From dynamic fee structures to unique bonding curves.

## Brief Overview of Concepts

Before we dive into the details of custom accounting, hook fees, custom curves, and return deltas, let’s explore how these features work in Uniswap v4.

### Delta Accounting in v4

As described in [Flash Accounting](https://docs.uniswap.org/contracts/v4/concepts/flash-accounting) Uniswap v4 tracks net token transfers with transient storage. Unlike previous versions that tracked absolute token balances, v4 records changes to these balances (*deltas*). This approach is at the core of v4’s enhanced flexibility and efficiency.

In the v4 architecture, the [`PoolManager`](https://docs.uniswap.org/contracts/v4/concepts/PoolManager) manages credits or debits per address. After a swap router contract interacts with the PoolManager, the core contract determines that the swap router owes input tokens and must claim output tokens. Token balances are tracked as accumulated deltas in transient storage; and only the final deltas incur token transfers

Delta accounting provides several key benefits:

1. More efficient state management, especially for complex operations involving multiple steps.
2. Easier integration with hooks, allowing for custom logic to be applied to state changes.
3. Improved gas efficiency for many operations, as it reduces the number of storage writes.

This system forms the foundation upon which other v4 features, such as hook fees and custom curves, are built. It allows for more complex pool behaviors while maintaining efficiency and flexibility.

### Hook Fees in v4

Hook fees are a feature in Uniswap v4 that allow hook developers to monetize their hooks or implement custom value distribution mechanisms. Unlike pool fees or dynamic fees, hook fees are entirely separate and are implemented through custom logic in the hook itself.

Key characteristics of hook fees in Uniswap v4:

**Separate from Pool Fees**

Hook fees are distinct from the standard pool fees. They can be implemented alongside pool fees without interfering with the core fee structure.

**Implemented in beforeSwap**

Hook fees are typically calculated and applied in the `beforeSwap` function, allowing them to modify the swap parameters before the core swap logic is executed.

**Use of BeforeSwapDelta**

Hook fees often utilize the [`BeforeSwapDelta`](https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta) mechanism to adjust swap amounts and transfer deltas from the hook to the swap router, enabling precise control over how the fee affects the swap.

**Flexible Implementation**

Developers have full control over how hook fees are calculated, collected, and distributed. This allows for complex fee structures tailored to specific use cases. In other words, developers can implement static fees, percentage-based fees, or even a fee that changes.

**Potential Use Cases**

- Monetization of hook development
- Implementation of withdrawal penalties (e.g., to penalize just-in-time liquidity provision)
- Custom value distribution for liquidity providers

Keep reading because at the bottom we are providing a step by step guide on how to implement hook fees.

### Custom Curves in v4

Custom Curves in Uniswap v4 represent a big change in AMM design flexibility. Unlike [Uniswap v2](https://docs.uniswap.org/contracts/v2/concepts/protocol-overview/how-uniswap-works) where the x*y=k formula was hardcoded, v4 allows developers to implement a wide variety of pricing models.

This is made possible through the hook system, particularly hooks that can interact with the swap process. Custom curves allow developers to eject the native concentrated liquidity pricing mechanism. These hooks can intercept swap requests, apply custom pricing logic, and return modified swap parameters. This enables the creation of pools with unique characteristics, such as:

- Stable asset pairs with minimal price impact
- Curves for special token types like rebasing tokens, RWAs, vault tokens

For example, creating a custom curve for a stable swap pool would involve designing a pricing function that maintains tighter price ranges when assets are near parity. This could be achieved by implementing a curve that's flatter in the middle (where assets are at their expected 1:1 ratio) and steeper at the edges (to discourage large imbalances).

This type of custom curve could significantly improve capital efficiency for stable asset pairs, reducing slippage for traders and potentially attracting more liquidity to the pool. It showcases how Uniswap v4's flexible architecture allows for tailored solutions to specific trading scenarios, opening up new possibilities in decentralized exchange design.

### Return Deltas in v4

Return deltas are a fundamental mechanism in Uniswap v4's custom accounting system. They allow for precise, programmatic adjustments to the outcomes of operations within the protocol.

Key aspects of return deltas:

1. **Dual Adjustment**: Return deltas simultaneously modify the balance changes (deltas) for both the hook contract and the swap router. This dual nature ensures that custom logic is accurately reflected across the entire system.
2. **Credits and Debts Modification**: By adjusting these deltas, return deltas effectively alter the credits and debts owed by the hook and the swap router. This allows for complex economic models to be implemented directly within the protocol.
3. **Native Pricing Bypass**: Return deltas enable hooks to implement custom curves that can completely bypass Uniswap's native pricing mechanism. This opens up possibilities for entirely new types of automated market makers within the Uniswap ecosystem.
4. **Hook Fee Implementation**: Through return deltas, hooks can implement their own fee structures, separate from the core protocol fees.

In essence, return deltas allow for bespoke modification of an operation's result -- enabling features that were previously impossible in earlier versions of the protocol.

## Implementing Hook Fees: A Step-by-Step Guide

In this guide, we'll walk through the process of implementing a custom fee hook in Uniswap v4. We'll not only show you how to write the code but also explain what's happening under the hood at each step.

### Step 1: Setting Up the Hook

First, let's create our basic hook structure:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BeforeSwapDelta, toBeforeSwapDelta} from "v4-core/src/types/BeforeSwapDelta.sol";

contract HookFeeExample is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;// 0.01% fee
    uint256 public constant FEE_DENOMINATOR = 100000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterAddLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }
}
```



Here, we're setting up our hook with a constant fee of 0.01% and enabling the `beforeSwap` and `beforeSwapReturnDelta` permissions.

### Step 2: Implementing the beforeSwap Function

Now, let's implement our `beforeSwap` function:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (bytes4, BeforeSwapDelta, uint24) {
    // Implementation details will be explained in the following sub-steps
}
```



#### Step 2.1: Calculate the swap amount and fee

We determine the absolute swap amount and calculate our fee based on it.

```solidity
uint256 swapAmount = params.amountSpecified < 0
    ? uint256(-params.amountSpecified)
    : uint256(params.amountSpecified);
uint256 feeAmount = (swapAmount * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;
```



#### Step 2.2: Collect the fee

We use `poolManager.take` to collect the fee. This creates a debt for our hook in the specified currency.

```solidity
Currency feeCurrency;

feeCurrency = params.amountSpecified < 0 == params.zeroForOne ? key.currency0 : key.currency1;

poolManager.take(feeCurrency, address(this), feeAmount);
```



note

> Using `poolManager.take()` requires an ERC20 balance on the PoolManager, i.e. via other liquidity pools. If the `.take()` amount exceeds the ERC20 balance, the code will revert. As a workaround, use either:
>
> 1. `poolManager.mint()` to obtain ERC6909, which are also more gas efficient
> 2. A custom swap router, where input tokens are transferred to PoolManager before the router calls `poolManager.swap()`

#### Step 2.3: Create the BeforeSwapDelta

This is where the magic happens. We create a `BeforeSwapDelta` that represents our fee. The `toBeforeSwapDelta` function takes two parameters:

- The specified delta: This is our fee amount. It's positive because we're adding it to the hook's balance.
- The unspecified delta: We set this to 0 as we're not affecting the other currency.

```solidity
BeforeSwapDelta returnDelta = toBeforeSwapDelta(
    int128(int256(feeAmount)), // Specified delta (fee amount)
    0 // Unspecified delta (no change)
);
```



#### Step 2.4: Return values

We return the function selector, our `returnDelta`, and 0 for the fee override.

```solidity
return (BaseHook.beforeSwap.selector, returnDelta, 0);
```



### Step 3: Understanding the BeforeSwapDelta Mechanism

Now, let's dive deeper into how the `BeforeSwapDelta` works and how it affects the overall swap process.

1. **Initial State**: Let's say a user wants to swap 100 USDC for USDT
   - Hook's delta: (0, 0)
   - User's swap request: -100 USDC (negative because they're selling)
2. **After Hook Execution**: Our hook has taken a 1 USDC fee (assuming 1% for simplicity):
   - Hook's delta: (-1 USDC, 0) // The hook now owes 1 USDC to the pool
   - BeforeSwapDelta returned: (1 USDC, 0) // This will be added to the hook's delta and subtracted from the swap delta
3. **PoolManager Processing**: The PoolManager applies our `BeforeSwapDelta` The pool then swaps 99 USDC for, let's say, 98 USDT.

```solidity
amountToSwap = params.amountSpecified + hookDelta.getSpecifiedDelta();
-99 USDC = -100 USDC + 1 USDC
```



1. **Delta Resolution**: The PoolManager then resolves the deltas:

```solidity
// Hook's new delta
newHookDelta = oldHookDelta + returnDelta
(0, 0) = (-1 USDC, 0) + (1 USDC, 0)

// Swap delta for router
swapDelta = (-99 USDC, 98 USDT) - (1 USDC, 0)
            = (-100 USDC, 98 USDT)
```



1. Final Outcome

   :

   - The hook's debt is cleared: It took 1 USDC as a fee, but "returned" it to the swap process.
   - The router (on behalf of the user) must pay 100 USDC (original amount including fee) and receives 98 USDT.

This process demonstrates how `BeforeSwapDelta` effectively "transfers" the hook's outstanding delta to the swap router, ensuring that the user pays the fee while the hook collects it, all within a single atomic transaction.

## Alternative: Charging Hook Fees in afterSwap

Charging hook fees in `afterSwap` is different from charging them in `beforeSwap` because `afterSwap` allows the hook to compute a fee on the actual output and collect it. This is best used in case of partial swaps, as `afterSwap` charges a fee on the **actual output** observed from `BalanceDelta` without overcharging the user.

### When to prefer afterSwap?

- You want fees to reflect **what actually transferred** (not the requested amount).
- Your swaps frequently **hit price limits** or **liquidity ceilings**.

### Step 1: Setting the permission flags

Enable `afterSwap` and `afterSwapReturnDelta` permissions in the hook:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {SwapParams} from "v4-core/src/types/PoolOperation.sol";

contract HookFeeAfterSwap is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;
    uint256 public constant FEE_DENOMINATOR     = 100_000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: false,
        beforeRemoveLiquidity: false,
        afterAddLiquidity: false,
        afterRemoveLiquidity: false,
        beforeSwap: false,
        afterSwap: true,
        beforeDonate: false,
        afterDonate: false,
        beforeSwapReturnDelta: false,
        afterSwapReturnDelta: true,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
}
```



### Step 2: Implementing `afterSwap` function:

In afterSwap, you do not build a BeforeSwapDelta. Instead, we read actual output from **BalanceDelta** and compute fee on that amount.

Unspecified currency (afterSwap)

The `int128` you return is for the **unspecified currency**. Map it like this:

- **exactIn** → unspecified = **output** token → take the fee in **output**; user receives less output.
- **exactOut** → unspecified = **input** token → take the fee in **input**; user must pay more input.

```solidity
function _afterSwap(
        address,
        PoolKey calldata key,
        SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        bool outputIsToken0 = params.zeroForOne ? false : true;

        int256 outputAmount = outputIsToken0 ? delta.amount0() : delta.amount1();
        if (outputAmount <= 0) {
            return (BaseHook.afterSwap.selector, 0);
        }

        uint256 feeAmount = (uint256(outputAmount) * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;

        require(feeAmount <= ((uint256(1) << 127) - 1), "fee too large");

        bool isExactIn = (params.amountSpecified < 0);

        Currency feeCurrency;
        if (isExactIn) {
            feeCurrency = outputIsToken0 ? key.currency0 : key.currency1;
        } else {
            bool inputIsToken0 = params.zeroForOne ? true : false;
            feeCurrency = inputIsToken0 ? key.currency0 : key.currency1;
        }

        poolManager.take(feeCurrency, address(this), feeAmount);

        return (BaseHook.afterSwap.selector, int128(int256(feeAmount)));
```



### Complete afterSwap contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {SwapParams} from "v4-core/src/types/PoolOperation.sol";

contract HookFeeAfterSwap is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;
    uint256 public constant FEE_DENOMINATOR     = 100_000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterAddLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: true,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    function _afterSwap(
        address ,
        PoolKey calldata key,
        SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        bool outputIsToken0 = params.zeroForOne ? false : true;

        int256 outputAmount = outputIsToken0 ? delta.amount0() : delta.amount1();
        if (outputAmount <= 0) {
            return (BaseHook.afterSwap.selector, 0);
        }

        uint256 feeAmount = (uint256(outputAmount) * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;

        require(feeAmount <= ((uint256(1) << 127) - 1), "fee too large");

        bool isExactIn = (params.amountSpecified < 0);

        Currency feeCurrency;
        if (isExactIn) {
            feeCurrency = outputIsToken0 ? key.currency0 : key.currency1;
        } else {
            bool inputIsToken0 = params.zeroForOne ? true : false;
            feeCurrency = inputIsToken0 ? key.currency0 : key.currency1;
        }

        poolManager.take(feeCurrency, address(this), feeAmount);

        return (BaseHook.afterSwap.selector, int128(int256(feeAmount)));
    }
}
```



## Conclusion

By implementing hook fees this way, we've leveraged Uniswap v4's delta accounting system to create a seamless fee collection mechanism. This approach allows for complex fee structures and behaviors without disrupting the core swap process or requiring separate fee transfers.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Swap routing](https://docs.uniswap.org/contracts/v4/guides/swap-routing)

# Swap routing

## Introduction to Universal Router for Uniswap v4 Swaps

Uniswap v4 introduces a new architecture where all pools are managed by a single PoolManager contract. While the underlying architecture uses a callback system for swaps, developers can still use the Universal Router to execute swaps on v4 pools, just as you would for v2 or v3.

## What is the Universal Router?

The Universal Router is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 `PoolManager`, handling the intricacies of swap execution.

While it’s technically possible to interact directly with the PoolManager contract for swaps, this approach is generally not recommended due to its complexity and potential inefficiencies. The Universal Router is designed to abstract away these complexities, providing a more straightforward and efficient method for executing swaps on v4 pools.

## UniversalRouter command encoding

The [Universal Router](https://docs.uniswap.org/contracts/universal-router/overview) uses a unique encoding system for its commands and inputs, which is crucial to understand when configuring it for v4 swaps.

When calling `UniversalRouter.execute()`, you provide two main parameters:

1. `bytes commands`: A string of bytes where each byte represents a single command to be executed.
2. `bytes[] inputs`: An array of byte strings, each containing the encoded parameters for its corresponding command.

The `commands[i]` byte corresponds to the `inputs[i]` parameters, allowing for a series of operations to be defined and executed in sequence.

Each command is encoded as a single byte (`bytes1`) with a specific structure:

```text
0 1 2 3 4 5 6 7
┌─┬─┬───────────┐
│f│r|  command  │
└─┴─┴───────────┘
```



- The first bit (`f`) is a flag that determines whether the command is allowed to revert without causing the entire transaction to fail. This enables partial execution of complex transactions.
- The second bit (`r`) is reserved for future use, providing flexibility for potential upgrades.
- The remaining 6 bits represent the specific command to be executed.

## Configuring Universal Router for Uniswap v4 Swaps

### Use Cases

Developers might need to configure the Universal Router for swapping on Uniswap v4 pools in several scenarios:

1. **Building a DEX aggregator**: If you’re creating a platform that finds the best rates across multiple DEXes, you’ll want to include Uniswap v4 pools in your options.
2. **Developing a trading bot**: Automated trading strategies often require the ability to execute swaps programmatically across various pools and versions.
3. **Creating a Dapp**: Many DeFi applications (lending platforms, yield aggregators, etc.) need to perform token swaps as part of their core functionality.

This guide focuses on how to interact with Universal Router from an on-chain contract.

### Step 1: Set Up the Project

First, we need to set up our project and install the necessary dependencies.

```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
forge install uniswap/permit2
forge install uniswap/universal-router
forge install OpenZeppelin/openzeppelin-contracts
```



In the `remappings.txt`, add the following:

```text
@uniswap/v4-core/=lib/v4-core/
@uniswap/v4-periphery/=lib/v4-periphery/
@uniswap/permit2/=lib/permit2/
@uniswap/universal-router/=lib/universal-router/
@openzeppelin/contracts/=lib/openzeppelin-contracts/
[...]
```



We’ll create a new Solidity contract for our example.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { IUniversalRouter } from "@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol";
import { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";
import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";
import { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";
import { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { StateLibrary } from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import { PoolKey } from "@uniswap/v4-core/src/types/PoolKey.sol";
import { Currency } from "@uniswap/v4-core/src/types/Currency.sol";

contract Example {
    using StateLibrary for IPoolManager;

    IUniversalRouter public immutable router;
    IPoolManager public immutable poolManager;
    IPermit2 public immutable permit2;

    constructor(address _router, address _poolManager, address _permit2) {
        router = IUniversalRouter(_router);
        poolManager = IPoolManager(_poolManager);
        permit2 = IPermit2(_permit2);
    }

    // We'll add more functions here
}
```



In this step, we’re importing the necessary contracts and interfaces:

- `UniversalRouter`: This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols.
- `Commands`: This library contains the command definitions used by the UniversalRouter.
- `IPoolManager`: This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools.
- `IPermit2`: This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality.
- `StateLibrary`: This provides optimized functions for interacting with the PoolManager’s state. By using `StateLibrary`, we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.

### Step 2: Implement Token Approval with Permit2

`UniversalRouter` integrates with [Permit2](https://github.com/Uniswap/permit2), to enable users to have more safety, flexibility, and control over their ERC20 token approvals.

Before we can execute swaps, we need to ensure our contract can transfer tokens. We’ll implement a function to approve the Universal Router to spend tokens on behalf of our contract.

Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:

```solidity
function approveTokenWithPermit2(
	address token,
	uint160 amount,
	uint48 expiration
) external {
    IERC20(token).approve(address(permit2), type(uint256).max);
    permit2.approve(token, address(router), amount, expiration);
}
```



This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time.

### Step 3: Implementing a Swap Function

#### 3.1: Function Signature

First, let’s define our function signature:

```solidity
function swapExactInputSingle(
    PoolKey calldata key, // PoolKey struct that identifies the v4 pool
    uint128 amountIn, // Exact amount of tokens to swap
    uint128 minAmountOut, // Minimum amount of output tokens expected
    uint256 deadline // Timestamp after which the transaction will revert
) external returns (uint256 amountOut) {
    // Implementation will follow
}
```



**Important note:**

1. The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks.
2. When swapping tokens involving native ETH, we use `Currency.wrap(address(0))` to represent ETH in the `PoolKey` struct.

```solidity
struct PoolKey {
    /// @notice The lower currency of the pool, sorted numerically.
    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));
    Currency currency0;
    /// @notice The higher currency of the pool, sorted numerically
    Currency currency1;
    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000
    uint24 fee;
    /// @notice Ticks that involve positions must be a multiple of tick spacing
    int24 tickSpacing;
    /// @notice The hooks of the pool
    IHooks hooks;
}
```



#### 3.2: Encoding the Swap Command

When encoding a swap command for the Universal Router, we need to choose between two types of swaps:

1. Exact Input Swaps:

Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens.

1. Exact Output Swaps:

Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement.

Next, we encode the swap command:

```solidity
bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
```



Here, we're using `V4_SWAP`, which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands.

Check the complete list of [commands](https://docs.uniswap.org/contracts/universal-router/technical-reference#command).

#### 3.3: Action Encoding

Now, let’s encode the actions for the swap:

```solidity
// Encode V4Router actions
bytes memory actions = abi.encodePacked(
    uint8(Actions.SWAP_EXACT_IN_SINGLE),
    uint8(Actions.SETTLE_ALL),
    uint8(Actions.TAKE_ALL)
);
```



These actions define the sequence of operations that will be performed in our v4 swap:

1. `SWAP_EXACT_IN_SINGLE`: This action specifies that we want to perform an exact input swap using a single pool.
2. `SETTLE_ALL`: This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers.
3. `TAKE_ALL`: This final action collects all output tokens after the swap is complete.

The sequence of these actions is important as they define the complete flow of our swap operation from start to finish.

#### 3.4: Preparing the Swap Inputs

For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:

```solidity
bytes[] memory params = new bytes[](3);

// First parameter: swap configuration
params[0] = abi.encode(
    IV4Router.ExactInputSingleParams({
        poolKey: key,
        zeroForOne: true,            // true if we're swapping token0 for token1
        amountIn: amountIn,          // amount of tokens we're swapping
        amountOutMinimum: minAmountOut, // minimum amount we expect to receive
        hookData: bytes("")             // no hook data needed
    })
);

// Second parameter: specify input tokens for the swap
// encode SETTLE_ALL parameters
params[1] = abi.encode(key.currency0, amountIn);

// Third parameter: specify output tokens from the swap
params[2] = abi.encode(key.currency1, minAmountOut);
```



Each encoded parameter serves a specific purpose:

1. The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details
2. The second parameter defines what tokens we're putting into the swap
3. The third parameter defines what tokens we expect to receive from the swap

These parameters work in conjunction with the actions we encoded earlier (`SWAP_EXACT_IN_SINGLE`, `SETTLE_ALL`, and `TAKE_ALL`) to execute our swap operation.

#### 3.5: Executing the Swap

Now we can execute the swap using the Universal Router. It's crucial to allow users to specify their own deadline for transaction execution:

```solidity
// Combine actions and params into inputs
inputs[0] = abi.encode(actions, params);

// Execute the swap with deadline protection
router.execute(commands, inputs, deadline);
```



This prepares and executes the swap based on our encoded commands, actions, and parameters.

> **Note**: Never use block.timestamp or type(uint256).max as the deadline parameter.

#### 3.6: (Optional) Verifying the Swap Output

After the swap, we need to verify that we received at least the minimum amount of tokens we specified:

```solidity
amountOut = IERC20(Currency.unwrap(key.currency1)).balanceOf(address(this));
require(amountOut >= minAmountOut, "Insufficient output amount");
```



#### 3.7: Returning the Result

Finally, we return the amount of tokens we received:

```solidity
return amountOut;
```



This allows the caller of the function to know exactly how many tokens were received in the swap.

Here's the complete swap function that combines all the steps we've covered:

```solidity
function swapExactInputSingle(
    PoolKey calldata key,
    uint128 amountIn,
    uint128 minAmountOut,
    uint256 deadline 
) external returns (uint256 amountOut) {
// Encode the Universal Router command
    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
    bytes[] memory inputs = new bytes[](1);

// Encode V4Router actions
    bytes memory actions = abi.encodePacked(
        uint8(Actions.SWAP_EXACT_IN_SINGLE),
        uint8(Actions.SETTLE_ALL),
        uint8(Actions.TAKE_ALL)
    );

// Prepare parameters for each action
    bytes[] memory params = new bytes[](3);
    params[0] = abi.encode(
        IV4Router.ExactInputSingleParams({
            poolKey: key,
            zeroForOne: true,
            amountIn: amountIn,
            amountOutMinimum: minAmountOut,
            hookData: bytes("")
        })
    );
    params[1] = abi.encode(key.currency0, amountIn);
    params[2] = abi.encode(key.currency1, minAmountOut);

// Combine actions and params into inputs
    inputs[0] = abi.encode(actions, params);

// Execute the swap
    router.execute(commands, inputs, deadline);

// Verify and return the output amount
    amountOut = IERC20(Currency.unwrap(key.currency1)).balanceOf(address(this));
    require(amountOut >= minAmountOut, "Insufficient output amount");
    return amountOut;
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[ERC-6909](https://docs.uniswap.org/contracts/v4/guides/ERC-6909)

# ERC-6909

## Introduction

Uniswap v4 uses [ERC-6909](https://docs.uniswap.org/contracts/v4/concepts/erc6909), a token standard that works alongside the protocol’s flash accounting system. This guide explains how ERC-6909 functions within v4, when to use mint versus burn operations, and how developers can implement them effectively.

## What is ERC-6909?

ERC-6909 is a token standard that enables efficient token management within a single contract through multiple token balances per user. Where ERC-20 requires separate approve and transfer calls for token interactions, ERC-6909 provides native support for multi-token operations through mint/burn mechanics that integrate with v4’s flash accounting system.

Here’s how the approaches differ:

```solidity
// Traditional ERC-20 approach
IERC20(tokenA).transferFrom(owner, poolManager, amount);

// ERC-6909 approach in v4
poolManager.burn(owner, currency.toId(), amount);
```



### Integration with Flash Accounting

While flash accounting tracks balance changes as deltas throughout a transaction, ERC-6909 provides an additional primitive to resolve deltas.

This enables:

1. Simplified transaction flows through direct mint/burn operations
2. Efficient handling of multi-step operations
3. Streamlined token management when using the PoolManager

### Gas Efficiency

ERC-6909 provides gas savings compared to ERC-20 tokens, making it particularly valuable for use cases requiring frequent token transfers like:

- Day trading operations
- MEV bot transactions
- Active liquidity management

This efficiency is especially beneficial when performing multiple token operations in rapid succession.

### Simplified Token Management

The traditional ERC-20 workflow requires careful management of allowances and transfers, often leading to complex transaction sequences and potential security concerns.

ERC-6909 takes a different approach by providing direct balance modifications through mint and burn operations.

By working through the PoolManager, all token operations are consolidated into a single interface. This means you don’t need to worry about managing multiple token approvals or keeping track of allowances across different contracts. Instead, you can focus on the core logic of your application while the PoolManager handles the token management aspects.

## Understanding ERC-6909 in v4

Let's explore how ERC-6909 is used across different v4 operations and understand when to use each of its operations.

### Operations and Token Movement

Different pool operations create different types of deltas that need to be resolved:

- **Swaps**: Create negative deltas for input tokens and positive deltas for output tokens
- **Adding Liquidity**: Creates negative deltas (tokens you need to provide)
- **Removing Liquidity**: Creates positive deltas (tokens you receive)
- **Donations**: Creates negative deltas (tokens you're donating)

### Using Mint and Burn

The choice between mint and burn operations depends on your token movement needs:

```solidity
// When you have positive deltas (withdrawing value from PoolManager):
poolManager.mint(currency, address(this), amount);

// When you have negative deltas (transferring value to PoolManager):
poolManager.burn(currency, address(this), amount);
```



This pattern is used throughout v4's operations:

- Use mint when withdrawing value from the pool (like receiving tokens from swaps)
- Use burn when transferring value to the pool (like providing tokens)

### Hook Integration

When building hooks, ERC-6909 operations help manage token movements within your hook's logic:

```solidity
function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    returns (bytes4, BeforeSwapDelta, uint24)
{
    poolManager.mint(key.currency0, address(this), amount);
    
    return (
      BaseHook.beforeSwap.selector,
      BeforeSwapDeltaLibrary.ZERO_DELTA,
      0
    );
}
```



Other common cases would be to use `mint` for fee collection or `burn` for token distribution.

## Implementation

Let's build a contract that handles donations in v4 using ERC-6909. We'll create a donation router that follows this flow:

1. Users call our donation function with their desired amounts
2. Our contract packages this data and uses the PoolManager's unlock pattern
3. In the callback, we unpack the data and execute the donation, handling token movements using ERC-6909

First, let's set up our contract with the necessary imports and create a struct to help us pass data between functions:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { PoolKey } from "@uniswap/v4-core/src/types/PoolKey.sol";
import { BalanceDelta } from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import { Currency } from "@uniswap/v4-core/src/types/Currency.sol";

contract DonationRouter {
    IPoolManager public immutable poolManager;

    // This struct helps us pack donation parameters to pass through
    // the unlock/callback pattern
    struct CallbackData {
        PoolKey key;
        uint256 amount0;
        uint256 amount1;
        bytes hookData;
    }

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }
}
```



Now let's implement the external donation function. Here we'll pack our parameters into the CallbackData struct and start the unlock process:

```solidity
/// @notice Donates tokens to a pool
/// @param key The pool to donate to
/// @param amount0 Amount of token0 to donate
/// @param amount1 Amount of token1 to donate
/// @param hookData Optional data to pass to hooks
function donate(
    PoolKey memory key,
    uint256 amount0,
    uint256 amount1,
    bytes memory hookData
) external returns (BalanceDelta delta) {
    // 1. Create a CallbackData struct with all our parameters
    CallbackData memory data = CallbackData({
        key: key,
        amount0: amount0,
        amount1: amount1,
        hookData: hookData
    });

    // 2. Encode our struct into bytes to pass through unlock
    bytes memory encodedData = abi.encode(data);
    
    // 3. Call unlock with our encoded data
    // 4. unlock will call our callback, which returns encoded delta
    // 5. Decode the returned bytes back into a BalanceDelta
    delta = abi.decode(
        poolManager.unlock(encodedData),
        (BalanceDelta)
    );
}
```



When the PoolManager calls our callback, we need to decode our data:

```solidity
function unlockCallback(
    bytes calldata rawData
) external returns (bytes memory) {
    // Only the PoolManager can trigger our callback
    require(msg.sender == address(poolManager));

    // Decode the bytes back into our CallbackData struct
    // (CallbackData) tells abi.decode what type to expect
    CallbackData memory data = abi.decode(rawData, (CallbackData));
```



Now `data` contains the same values we packed in donate():

- `data.key`: The pool to donate to
- `data.amount0`: Amount of first token
- `data.amount1`: Amount of second token
- `data.hookData`: Any hook data

And we can execute the donation:

```solidity
    // Execute the donation through PoolManager
    // This creates negative deltas for the tokens we're donating
    BalanceDelta delta = poolManager.donate(
        data.key,
        data.amount0,
        data.amount1,
        data.hookData
    );
```



After executing the donation through the PoolManager, we need to handle the token transfers. The donation creates negative deltas, which represent tokens that we owe to the PoolManager. This is where ERC-6909's burn operation comes into play.

Instead of using traditional token transfers, we can use ERC-6909's burn operation to settle this debt. We check each token's delta and, if negative, burn the corresponding amount of ERC-6909 tokens. And finally return the encoded delta. Let’s see how:

```solidity
 // Handle any negative deltas by burning ERC-6909 tokens
    if (delta.amount0() < 0) {
        poolManager.burn(
            data.key.currency0,
            address(this),
            uint256(-delta.amount0())
        );
    }
    if (delta.amount1() < 0) {
        poolManager.burn(
            data.key.currency1,
            address(this),
            uint256(-delta.amount1())
        );
    }

    // Encode and return the delta so donate() can decode it
    return abi.encode(delta);
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Position Manager](https://docs.uniswap.org/contracts/v4/guides/position-manager)

# Position Manager

## Introduction

The Position Manager in v4 provides a streamlined way to manage liquidity positions through a command-based interface. Unlike previous versions where each operation required separate function calls, v4’s Position Manager uses a batched command pattern that allows multiple operations to be executed in a single transaction.

## Command-Based Design

At its core, the Position Manager works by executing a sequence of commands:

```solidity
// Example: Minting a new position requires two commands
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,  // Create the position
    Actions.SETTLE_PAIR     // Provide the tokens
);
```



Each command (or action) represents a specific operation, and these actions can be:

- Liquidity Operations: Creating, modifying, or removing positions
- Delta-Resolving Operations: Handling token transfers and settlements

## How Commands Work Together

When executing operations through the Position Manager, you’ll always:

1. Define what actions to perform
2. Provide the parameters for each action
3. Execute them through a single function call

```solidity
// 1. Define actions
bytes memory actions = abi.encodePacked(action1, action2);

// 2. Encode parameters for each action
bytes[] memory params = new bytes[](2);
params[0] = abi.encode(/* parameters for action1 */);
params[1] = abi.encode(/* parameters for action2 */);

// 3. Execute through modifyLiquidities
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```



This design enables efficient operations by:

- Minimizing transaction costs through batching
- Allowing complex position management in single transactions
- Providing flexibility in how operations are combined

In the following sections, we’ll explore how to work with these commands and implement common liquidity management operations.

## Core Concepts

Before diving into specific operations, let’s understand the key concepts that make up the Position Manager’s architecture.

### Action Types

The Position Manager operates through a system of actions that work in pairs: when you perform a liquidity operation that changes position balances, you must also include actions to handle the resulting token movements.

### Understanding the Flow

When you execute a liquidity operation:

1. The operation creates deltas (token obligations)
2. These deltas represent tokens that need to be paid or received
3. Delta-resolving operations are then used to handle these token movements

### Liquidity Operations

[Actions](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/Actions) that modify positions in the pool:

```solidity
// Common liquidity operations
uint256 constant MINT_POSITION = 0x02;       // Creates negative deltas (tokens needed for position)
uint256 constant INCREASE_LIQUIDITY = 0x00;  // Creates negative deltas (tokens to add)
uint256 constant DECREASE_LIQUIDITY = 0x01;  // Creates positive deltas (tokens to receive)
uint256 constant BURN_6909 = 0x18;           // Creates positive deltas (tokens to receive)
```



Each operation creates specific deltas that must be resolved:

- Negative deltas when you need to provide tokens (mint, increase)
- Positive deltas when you’re receiving tokens (decrease, burn)

### Delta-Resolving Operations

Actions that handle the token transfers needed to resolve deltas:

```solidity
// Common delta-resolving operations
uint256 constant SETTLE_PAIR = 0x0d;    // For negative deltas: Pay two tokens to the pool
uint256 constant TAKE_PAIR = 0x11;      // For positive deltas: Receive two tokens from the pool
uint256 constant CLOSE_CURRENCY = 0x12; // Handles either direction based on final delta
uint256 constant CLEAR_OR_TAKE = 0x13;  // For small amounts: Take if worth it, else ignore
```



### Operation Order

Understanding how operations create and resolve deltas helps in ordering them efficiently:

```solidity
// Efficient: Group operations that create deltas, then resolve them together
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,      // First delta: -100 tokens
    Actions.INCREASE_LIQUIDITY, // Second delta: -50 tokens
    Actions.SETTLE_PAIR        // Resolve total: -150 tokens at once
);

// Less efficient: Resolving deltas multiple times
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,      // Delta: -100 tokens
    Actions.SETTLE_PAIR,        // Resolve: -100 tokens
    Actions.INCREASE_LIQUIDITY, // New delta: -50 tokens
    Actions.SETTLE_PAIR        // Resolve again: -50 tokens
);
```



Best practices for ordering:

1. Group liquidity operations that create similar deltas (e.g., all negative or all positive)
2. Resolve all deltas together at the end when possible
3. Use `CLOSE_CURRENCY` when you can't predict the final delta

## Working with Liquidity Positions

When building on v4, you’ll need to manage liquidity positions through the Position Manager. Let’s walk through each operation, starting with creating new positions.

### Minting New Positions

To create a new liquidity position in v4, you’ll need to:

1. Define your position parameters (pool, price range, amount)
2. Mint the position NFT
3. Provide the initial tokens

### **Understanding Position Parameters**

Before minting, you need to determine:

- Which pool you’re providing liquidity to
- Your price range (defined by tick bounds)
- How much liquidity to provide
- Maximum amounts of tokens you’re willing to spend

```solidity
// Example position parameters
PoolKey poolKey = // Your pool key
int24 tickLower = -887272;   // Price range lower bound
int24 tickUpper = 887272;    // Price range upper bound
uint128 liquidity = 1000000; // Liquidity amount
uint256 amount0Max = 1e18;   // Max 1 token0
uint256 amount1Max = 1e18;   // Max 1 token1
```



### **Implementation**

Let’s implement a function to mint new liquidity positions step by step:

```solidity
/// @notice Mints a new liquidity position
/// @param poolKey The pool to provide liquidity to
/// @param tickLower Lower bound of the price range
/// @param tickUpper Upper bound of the price range
/// @param liquidity Amount of liquidity to provide
/// @param amount0Max Maximum amount of token0 to spend
/// @param amount1Max Maximum amount of token1 to spend
/// @param recipient Address that will own the position
function mintNewPosition(
    PoolKey calldata poolKey,
    int24 tickLower,
    int24 tickUpper,
    uint256 liquidity,
    uint128 amount0Max,
    uint128 amount1Max,
    address recipient
) external returns (uint256 tokenId) {
```



Define the sequence of operations needed for minting:

```solidity
// Define the sequence of operations:
// 1. MINT_POSITION - Creates the position and calculates token requirements
// 2. SETTLE_PAIR - Provides the tokens needed
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,
    Actions.SETTLE_PAIR
);
```



Set up parameters for each action:

```solidity
bytes[] memory params = new bytes[](2);

// Parameters for MINT_POSITION
params[0] = abi.encode(
    poolKey,     // Which pool to mint in
    tickLower,   // Position's lower price bound
    tickUpper,   // Position's upper price bound
    liquidity,   // Amount of liquidity to mint
    amount0Max,  // Maximum amount of token0 to use
    amount1Max,  // Maximum amount of token1 to use
    recipient,   // Who receives the NFT
    ""           // No hook data needed
);

// Parameters for SETTLE_PAIR - specify tokens to provide
params[1] = abi.encode(
    poolKey.currency0,  // First token to settle
    poolKey.currency1   // Second token to settle
);
```



Finally, execute the mint operation:

```solidity
// Execute the mint operation
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```



## Increasing Liquidity

After a position is created, you might want to add more liquidity to it. This operation requires understanding how fee accumulation works since fees are credited to your position during an increase.

### **Understanding the Operation**

When increasing liquidity:

1. The operation calculates the tokens needed based on current prices
2. Any accumulated fees are **automatically credited** to your position
3. In some cases, fee revenue might partially or fully cover the tokens needed

### **Choosing the Right Delta Resolution**

Unlike minting where we always use SETTLE_PAIR, increasing liquidity has different delta-resolving options depending on your scenario:

1. **Standard Case**: When you’re providing new tokens

```solidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.SETTLE_PAIR
);
```



**2. Fee Conversion**: When converting accumulated fees to liquidity

```solidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.CLOSE_CURRENCY,  // For token0
    Actions.CLOSE_CURRENCY   // For token1
);
```



### **Implementation**

Here’s how to implement a flexible increase liquidity function:

```solidity
/// @notice Increases liquidity in an existing position
/// @param tokenId The ID of the position
/// @param liquidityIncrease Amount of liquidity to add
/// @param amount0Max Maximum amount of token0 to spend
/// @param amount1Max Maximum amount of token1 to spend
/// @param useFeesAsLiquidity Whether to use accumulated fees
function increaseLiquidity(
    uint256 tokenId,
    uint128 liquidityIncrease,
    uint256 amount0Max,
    uint256 amount1Max,
    bool useFeesAsLiquidity
) external {
```



Choose the appropriate delta resolution based on whether we’re using fees:

```solidity
// Define the sequence of operations:
// If using fees: Handle potential fee conversion
// If not: Standard liquidity addition
bytes memory actions;
if (useFeesAsLiquidity) {
    actions = abi.encodePacked(
        Actions.INCREASE_LIQUIDITY,  // Add liquidity
        Actions.CLOSE_CURRENCY,      // Handle token0 (might need to pay or receive)
        Actions.CLOSE_CURRENCY       // Handle token1 (might need to pay or receive)
    );
} else {
    actions = abi.encodePacked(
        Actions.INCREASE_LIQUIDITY,  // Add liquidity
        Actions.SETTLE_PAIR          // Provide tokens
    );
}
```



Prepare parameters based on our chosen strategy:

```solidity
// Number of parameters depends on our strategy
bytes[] memory params = new bytes[](
    useFeesAsLiquidity ? 3 : 2
);

// Parameters for INCREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,           // Position to increase
    liquidityIncrease, // Amount to add
    amount0Max,        // Maximum token0 to spend
    amount1Max,        // Maximum token1 to spend
    ""                // No hook data needed
);
```



Set up delta resolution parameters:

```solidity
if (useFeesAsLiquidity) {
    // Using CLOSE_CURRENCY for automatic handling of each token
    params[1] = abi.encode(currency0);  // Handle token0
    params[2] = abi.encode(currency1);  // Handle token1
} else {
    // Standard SETTLE_PAIR for providing tokens
    params[1] = abi.encode(currency0, currency1);
}
```



Execute the operation:

```solidity
// Execute the increase
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
}
```



## Decreasing Liquidity

When you want to remove liquidity from a position, you’ll need to handle both the liquidity reduction and any accumulated fees. Let’s understand how to implement this effectively.

### **Understanding the Operation**

Decreasing liquidity involves:

1. Specifying how much liquidity to remove
2. Setting minimum amounts to receive (slippage protection)
3. Collecting both the removed liquidity and any accumulated fees

### **Delta Resolution Options**

When decreasing liquidity, you’ll receive tokens, so it's most common to receive a pair of tokens:

```solidity
bytes memory actions = abi.encodePacked(
    Actions.DECREASE_LIQUIDITY,
    Actions.TAKE_PAIR
);
```



### **Implementation**

When removing liquidity from a position, you’ll be able to receive tokens and any accumulated fees. Let’s break down the implementation step by step.

```solidity
/// @notice Removes liquidity from a position
/// @param tokenId The ID of the position
/// @param liquidityDecrease Amount of liquidity to remove
/// @param amount0Min Minimum amount of token0 to receive
/// @param amount1Min Minimum amount of token1 to receive
/// @param recipient Address to receive the tokens
function decreaseLiquidity(
    uint256 tokenId,
    uint128 liquidityDecrease,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient
) external {
```



Prepare the parameters array:

```solidity
// Number of parameters depends on our strategy
bytes[] memory params = new bytes[](2);

// Parameters for DECREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,           // Position to decrease
    liquidityDecrease, // Amount to remove
    amount0Min,        // Minimum token0 to receive
    amount1Min,        // Minimum token1 to receive
    ""                // No hook data needed
);
```



Set up delta resolution parameters:

```solidity
// Parameters for TAKE_PAIR
params[1] = abi.encode(
    currency0,
    currency1,
    recipient
);
```



Execute the operation:

```solidity
// Execute the decrease
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```



## Collecting Fees

In v4’s Position Manager, there isn’t a dedicated COLLECT command. Instead, **fees are collected by using DECREASE_LIQUIDITY with zero liquidity**. This pattern leverages the fact that fees are automatically credited during liquidity operations.

### **Understanding Fee Collection**

When collecting fees, you need to:

1. Perform a DECREASE_LIQUIDITY operation with zero liquidity
2. Handle the positive deltas (the fees you’re collecting)
3. Specify where the fees should go

### **Implementation**

```solidity
/// @notice Collects accumulated fees from a position
/// @param tokenId The ID of the position to collect fees from
/// @param recipient Address that will receive the fees
function collectFees(
    uint256 tokenId,
    address recipient
) external {
    // Define the sequence of operations
    bytes memory actions = abi.encodePacked(
        Actions.DECREASE_LIQUIDITY, // Remove liquidity
        Actions.TAKE_PAIR           // Receive both tokens
    );

    // Prepare parameters array
    bytes[] memory params = new bytes[](2);

    // Parameters for DECREASE_LIQUIDITY
    // All zeros since we're only collecting fees
    params[0] = abi.encode(
        tokenId,    // Position to collect from
        0,          // No liquidity change
        0,          // No minimum for token0 (fees can't be manipulated)
        0,          // No minimum for token1
        ""          // No hook data needed
    );
```



When collecting fees, we use a zero-liquidity decrease operation - this means we're not actually removing any liquidity from the position, we're just collecting accumulated fees.

And note that we set minimums to 0 for fee collection because fees cannot be manipulated in a front-run attack. This is different from other liquidity operations where setting appropriate minimum amounts is crucial for slippage protection.

Set up the fee collection parameters:

```solidity
    // Standard TAKE_PAIR for receiving all fees
    params[1] = abi.encode(
        currency0,
        currency1,
        recipient
    );
}
```



Execute the fee collection:

```solidity
// Execute fee collection
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```



## Burning Positions

When you want to completely exit a position, burning is more efficient than removing liquidity and collecting fees separately. The BURN_POSITION command handles everything in a single operation.

### **Understanding Position Burning**

A burn operation:

- Removes all remaining liquidity from the pool
- Collects any accumulated fees
- Burns the position NFT
- Settles all tokens to a specified recipient

### **Implementation**

Let’s implement a position burning function step by step:

```solidity
/// @notice Burns a position and receives all tokens
/// @param tokenId The ID of the position to burn
/// @param recipient Address that will receive the tokens
/// @param amount0Min Minimum amount of token0 to receive
/// @param amount1Min Minimum amount of token1 to receive
function burnPosition(
    uint256 tokenId,
    address recipient,
    uint256 amount0Min,
    uint256 amount1Min
) external {
    // Define the sequence of operations:
    // 1. BURN_POSITION - Removes the position and creates positive deltas
    // 2. TAKE_PAIR - Sends all tokens to the recipient
    bytes memory actions = abi.encodePacked(
        Actions.BURN_POSITION,
        Actions.TAKE_PAIR
    );
```



The burn operation requires two sets of parameters:

```solidity
bytes[] memory params = new bytes[](2);

// Parameters for BURN_POSITION
params[0] = abi.encode(
    tokenId,      // Position to burn
    amount0Min,   // Minimum token0 to receive
    amount1Min,   // Minimum token1 to receive
    ""            // No hook data needed
);

// Parameters for TAKE_PAIR - where tokens will go
params[1] = abi.encode(
    currency0,   // First token
    currency1,   // Second token
    recipient    // Who receives the tokens
);
```



Finally, execute the operation:

```solidity
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60
);
```



## Batch-Operating Liquidity

The Position Manager’s command-based design enables you to perform multiple liquidity operations in a single transaction. This is particularly valuable when managing multiple positions or performing complex liquidity management strategies, such as taking tokens from one position to increase liquidity of another position.

### Benefits of Batch Operations

When managing liquidity across multiple positions, batching operations provides significant advantages:

- Reduced gas costs by combining token settlements
- Atomic execution of related operations
- Simplified token handling through combined delta resolution

### Implementation Guide

Let’s implement a common scenario: rebalancing liquidity by creating a new position while closing an old one and collecting its fees. We’ll go through it step by step.

First, let’s define our parameters:

```solidity
/// @notice Rebalances liquidity by creating a new position and closing an old one
/// @param newPositionParams Parameters for the new position
/// @param oldPositionId Position to close and collect fees from
/// @param recipient Address to receive tokens from closed position
struct NewPositionParams {
    PoolKey poolKey;
    int24 tickLower;
    int24 tickUpper;
    uint128 liquidity;
    uint256 amount0Max;
    uint256 amount1Max;
}
```



In this example, we will rebalance liquidity by closing the old position and opening a new position. For the sake of example, let's assume the user will have to transfer additional tokens. Note that capital from the first position is automatically used towards the second position through flash accounting.

```solidity
function rebalanceLiquidity(
    NewPositionParams calldata newPositionParams,
    uint256 oldPositionId,
    address recipient
) external {
    // Group liquidity operations first, then delta resolutions
    bytes memory actions = abi.encodePacked(
        Actions.BURN_POSITION,    // Remove old position
        Actions.MINT_POSITION,    // Create new position
        Actions.SETTLE_PAIR       // Provide tokens for new position
    );
```



Notice how we order our operations: liquidity operations first (MINT and BURN), followed by delta resolutions (SETTLE and TAKE). This ordering is crucial for gas efficiency.

Next, let’s prepare our parameters array:

```solidity
// We need one parameter set for each action
bytes[] memory params = new bytes[](3);
```



Now, let’s encode parameters for the old position:

```solidity
// Parameters for BURN_POSITION
params[0] = abi.encode(
    oldPositionId,
    0,  // No minimum for token0 (consider adding slippage protection)
    0,  // No minimum for token1
    ""  // No hook data
);
```



Then for minting the new position:

```solidity
// Parameters for MINT_POSITION
params[1] = abi.encode(
    newPositionParams.poolKey,
    newPositionParams.tickLower,
    newPositionParams.tickUpper,
    newPositionParams.liquidity,
    newPositionParams.amount0Max,
    newPositionParams.amount1Max,
    address(this),  // New position owner
    ""              // No hook data
);
```



Next, we handle token settlements. First for the new position:

```solidity
// Parameters for SETTLE_PAIR (providing tokens for new position)
params[2] = abi.encode(
  newPositionParams.poolKey.currency0,
  newPositionParams.poolKey.currency1
);
```



With everything prepared, we can execute our batch operation:

```solidity
// Execute all operations atomically
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60
);
    positionManager.modifyLiquidities(
        abi.encode(actions, params),
        block.timestamp + 60
    );
}
```



## Delta-Resolving Operations

While we’ve seen basic delta resolution using SETTLE_PAIR and TAKE_PAIR in previous sections, v4’s Position Manager provides additional operations for handling more complex scenarios. Let’s understand when and how to use each one.

### **CLOSE_CURRENCY: Handling Unknown Deltas**

When you can’t predict whether you’ll need to pay or receive tokens, CLOSE_CURRENCY automatically handles either case.

```solidity
// Example scenario: Converting fees to liquidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.CLOSE_CURRENCY  // Will automatically settle or take based on final delta
);

bytes[] memory params = new bytes[](2);

// Parameters for INCREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,
    liquidityIncrease,
    amount0Max,
    amount1Max,
    ""
);

// CLOSE_CURRENCY only needs the currency
params[1] = abi.encode(currency0);
```



This is particularly useful when:

- Converting fees to liquidity (fees might fully cover the increase)
- Complex operations where final deltas are uncertain
- Reducing code complexity by letting the protocol handle the direction

### **CLEAR_OR_TAKE: Optimizing for Dust**

Sometimes receiving small token amounts costs more in gas than they’re worth. CLEAR_OR_TAKE lets you specify a threshold:

```solidity
// Parameters for CLEAR_OR_TAKE
params[0] = abi.encode(
    currency,     // The token to handle
    threshold     // Minimum amount worth taking
);
```



If the amount to receive is:

- Above threshold: Tokens are taken (like TAKE_PAIR)
- Below threshold: Amount is forfeited, saving gas

This is valuable for:

- Operations where dust amounts can be ignored
- Gas optimization in production systems

### **SWEEP: Handling Excess Payments**

SWEEP helps recover any excess tokens sent to the PoolManager:

```solidity
bytes memory actions = abi.encodePacked(
    Actions.YOUR_MAIN_OPERATION,
    Actions.SWEEP  // Add at the end to collect any excess
);

// Parameters for SWEEP
params[1] = abi.encode(
    currency,   // Token to sweep
    recipient   // Where to send excess tokens
);
```



Use SWEEP when:

- **Dealing with native ETH operations**
- Conservative token approvals might result in excess
- Need to ensure all tokens are properly accounted for

### **Understanding modifyLiquiditiesWithoutUnlock**

This function follows the same encoding and command patterns as `modifyLiquidity`, but serves a specific purpose: it's used when the PoolManager is already unlocked. This is particularly useful in certain scenarios:

- When called from hooks that are already executing within the PoolManager's lock/unlock cycle
- For operations like automatic fee compounding, where a hook might want to reinvest fees for users

For example, a hook that automatically compounds fees for users would use `modifyLiquiditiesWithoutUnlock` because the hook is already executing within the PoolManager's unlock context, and cannot re-unlock the PoolManager



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[StateView](https://docs.uniswap.org/contracts/v4/guides/state-view)

# StateView

## Introduction

When building on **Uniswap v4**, you will often need to read pool state for both onchain and offchain use cases. Onchain contracts can directly invoke the [**StateLibrary**](https://github.com/Uniswap/v4-core/blob/main/src/libraries/StateLibrary.sol) to execute these reads during transactions, but offchain systems—such as frontends or analytics services—require a deployed contract with view functions. This is where [**StateView**](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) comes in.

> *In short: Use StateLibrary within onchain contracts and use StateView with an RPC for frontends and analytics.*

By providing a dedicated interface for offchain reads, **StateView** helps:

- Retrieve pool state without paying gas
- Simplify integration for frontends, dashboards, and analytics
- Ensure a clean separation between onchain logic and offchain queries

## Comparing onchain and offchain Access

If you’re familiar with [Reading Pool State](https://docs.uniswap.org/contracts/v4/guides/read-pool-state), you already know that Uniswap v4 uses **extsload** for efficient data access. For onchain usage, we rely on **StateLibrary** within contracts. However, offchain clients cannot rely on an onchain library for state reads.

Instead, **StateView** provides these same calls in a single contract designed explicitly for offchain consumption.

> *Because StateLibrary operates via onchain function calls, it’s not directly accessible to offchain clients. Hence, StateView provides a simple, gas-free interface designed for frontends and analytics.*

For instance, an onchain contract might use the `StateLibrary` as follows:

```solidity
// Onchain contract using StateLibrary
contract MyProtocol {
    using StateLibrary for IPoolManager;

    function checkPoolPrice(PoolId poolId) external returns (uint160) {
        (uint160 sqrtPriceX96, , , ) = poolManager.getSlot0(poolId);
        // ... use the price in contract logic ...
        return sqrtPriceX96;
    }
}
```



By contrast, an offchain frontend or analytics service should interact with `StateView`:

```tsx
// Frontend or analytics client using StateView
const stateView = getContract({
  address: STATE_VIEW_ADDRESS,
  abi: stateViewABI
});

const { sqrtPriceX96 } = await stateView.read.getSlot0([poolId]);
// ... use the price in your application ...
```



This separation ensures that each context (onchain vs. offchain) uses the most efficient data reading pattern.

## Usage With Frontend Clients

Frontend applications frequently display real-time information about pools, positions, and other market data—without incurring transaction costs. **StateView** addresses these requirements by exposing read-only functions tailored for offchain integrations.

### Setting Up With Viem

We’ll use [**viem**](https://viem.sh/), a TypeScript library for Ethereum, to demonstrate how to connect to **StateView**.

```tsx
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// Initialize the client
const client = createPublicClient({
  chain: mainnet,
  transport: http()
});

// Set up StateView contract instance
const stateView = getContract({
  address: STATE_VIEW_ADDRESS,
  abi: stateViewABI,
  client
})
```



> **Note:** *The stateView object comes from our getContract call above. Make sure you’ve imported stateViewABI correctly before attempting to read from the contract.*

With this setup, you can now:

- **Connect to an Ethereum network**
- **Call StateView’s read functions**
- **Retrieve pool information offchain at no gas cost**

### Handling Errors and Invalid Pool IDs

When calling `stateView.read.<function>([poolId])`, be mindful that:

- If you pass an invalid `poolId` (typically a [`bytes32`](https://github.com/Uniswap/v4-core/blob/main/src/types/PoolId.sol#L6) in Uniswap v4), the call may revert or return unexpected data.
- Consider adding try-catch (or equivalent error handling in your framework) to gracefully handle failures if the pool does not exist or if the call fails onchain.

## Reading Pool Data

Here are common examples of how to retrieve pool data using **StateView**.

### Getting Pool State

A pool’s core state, such as its current price or fees, is often necessary for frontends. Use `getSlot0`:

```tsx
// Example: Reading pool price and fees
const getPoolState = async (poolId: string) => {
  // getSlot0 returns:
  // - Current price (sqrtPriceX96) in Q64.96 fixed-point format
  // - Active tick
  // - Protocol and LP fee settings
  const [
    sqrtPriceX96,
    tick,
    protocolFee,
    lpFee
   ] = await stateView.read.getSlot0([poolId]);

  return {
    price: calculatePrice(sqrtPriceX96), // implement your math logic for Q64.96
    tick,
    protocolFee,
    lpFee
  };
};
```



**What it Returns:**

- **`sqrtPriceX96`**: The current pool price in Q64.96 fixed-point format.
- **`tick`**: The current tick in which the pool is operating.
- **`protocolFee`** and **`lpFee`**: Fee parameters for protocol and LP fee tiers.

### Getting Pool Liquidity

To understand how much liquidity a pool holds:

```tsx
// Example: Reading the total active liquidity of a pool
const getPoolLiquidity = async (poolId: string) => {
  // getLiquidity returns the total liquidity currently active in the pool
  const liquidity = await stateView.read.getLiquidity([poolId]);
  return liquidity;
};
```



**Why It Matters:**

- Helps gauge the depth of the pool
- Influences price impact calculations in trading
- Provides context for the pool’s capacity to absorb trades

## Core Functions and Return Types

While **StateView** exposes many functions, here are several essential calls for most offchain applications. Each function typically takes a `poolId` (of type `bytes32`) as the key input, identifying which pool to query.

1. [`getSlot0(poolId)`](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/StateView#getslot0)
   - Returns `(uint160 sqrtPriceX96, int24 tick, uint8 protocolFee, uint8 lpFee)`.
   - Essential for displaying real-time price data and fees.
2. [`getLiquidity(poolId)`](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/StateView#getliquidity)
   - Returns `uint128 liquidity` (the total active pool liquidity).
   - Used to assess trading depth and volatility.
3. [`getPositionInfo(poolId, positionId)`](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/StateView#getpositioninfo)
   - Returns `(uint128 liquidity, uint256 feeGrowthInside0Last, uint256 feeGrowthInside1Last)`.
   - Critical for tracking user positions, especially to calculate earned fees over time.
4. [`getFeeGrowthGlobals(poolId)`](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/StateView#getfeegrowthglobals)
   - Returns `(uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1)`.
   - Useful for analytics around total fee accumulation in the pool.

### Note on `poolId` and `positionId`

- In

   

  Uniswap v4

  , a

   

  ```
  poolId
  ```

   

  is typically a

   

  ```
  bytes32
  ```

   

  that is derived by calling

   

  ```
  keccak256(abi.encode(poolKey))
  ```

   

  where poolKey contains:

  - currency0: The lower currency address of the pool
  - currency1: The higher currency address of the pool
  - fee: The pool LP fee (uint24)
  - tickSpacing: The tick spacing value (int24)
  - hooks: The hooks contract address

- A `positionId` may also be a `bytes32` or other unique identifier that references a specific position.

## Security and Gas Considerations

- **Offchain Reads**: Calls to `StateView` are purely read-only, so they cost no gas. This makes them ideal for frequently refreshing UI/analytics data.
- **Onchain vs. Offchain**: Remember that if you need to integrate pool data into a live transaction, you must use `StateLibrary` within your smart contract.
- **Edge Cases**: Always verify the returned data before using it in your application. Network or contract errors could lead to unexpected values.

## Conclusion

**StateView** is a powerful and efficient way to read Uniswap v4 pool data offchain. By separating onchain logic (using `StateLibrary`) and offchain reads (using `StateView`), Uniswap ensures the best developer experience for both contexts.

To recap:

1. **Setup**: Use libraries like `viem` to connect to the Ethereum network.
2. **Read**: Call `getSlot0`, `getLiquidity`, `getPositionInfo`, and other methods for crucial state data.
3. **Handle Errors**: Implement basic checks for invalid `poolId` or connection failures.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Flash Accounting](https://docs.uniswap.org/contracts/v4/guides/flash-accounting)

# Flash Accounting

## Introduction

Flash accounting is v4’s mechanism for tracking token movements throughout a transaction. Unlike traditional token accounting which updates balances immediately after each operation, flash accounting accumulates changes (deltas) and settles them at the end of the transaction.

## How Flash Accounting Works

When interacting with v4's PoolManager, all token movements follow a consistent pattern: negative values represent tokens moving from users to the PoolManager, while positive values represent tokens moving from the PoolManager to users. This pattern appears in operations like swaps and liquidity management, where:

- Negative values indicate tokens going to the PoolManager
- Positive values indicate tokens coming from the PoolManager

These movements are tracked through deltas that represent token obligations:

- Negative deltas indicate tokens owed to the PoolManager
- Positive deltas indicate tokens the PoolManager owes to an address

## The PoolManager Lock Pattern

All operations that access pool liquidity must occur while the PoolManager is unlocked. This pattern ensures atomic execution and proper delta tracking:

1. Unlock the PoolManager
2. Execute operations (creating deltas)
3. Resolve all deltas
4. Context returns to the PoolManager which verifies no outstanding deltas

If any deltas remain unresolved when the PoolManager locks, the entire transaction reverts. This guarantees that all token movements balance out by the end of the transaction.

## Understanding the Basics

Before diving into implementation patterns, let’s look at the key concepts you’ll need to work with flash accounting. Each example includes common scenarios you’ll encounter when building on v4.

### Working with Deltas

Every operation in v4 that involves tokens creates deltas. These deltas track what the executor owes to the PoolManager and vice versa:

```solidity
// Example: Executing a swap
// Note: This assumes the PoolManager has been unlocked
function executeSwap(PoolKey calldata key) external {
    // A swap returns a BalanceDelta
    BalanceDelta delta = poolManager.swap(
        key,
        IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: -1e18,  // Negative means spending/providing 1 ETH
            sqrtPriceLimitX96: MAX_SQRT_RATIO - 1  // Max price willing to accept
        }),
        ""
    );

    // Delta shows:
    // delta.amount0() = -1e18    (executor owes 1 ETH)
    // delta.amount1() = +2000e6  (executor receives 2000 USDC)
}
```



When a swap is executed, the PoolManager returns a `BalanceDelta` that shows your token obligations. In this example, the negative delta (-1e18) means the executor owes 1 ETH to the PoolManager, while the positive delta (+2000e6) means the executor is entitled to receive 2000 USDC. These deltas must be resolved before the transaction completes.

*Note how negative values in v4 consistently represent tokens going to the PoolManager - both in `amountSpecified` for the input amount and in the returned delta for tokens owed.*

### Reading Delta States

A common pattern is checking current deltas before executing operations. The `TransientStateLibrary` helps you track these balances:

```solidity
import {TransientStateLibrary} from "@uniswap/v4-core/src/libraries/TransientStateLibrary.sol";

contract DeltaReader {
    using TransientStateLibrary for IPoolManager;

    function checkDeltaBeforeOperation(
        Currency currency,
        address user
    ) external view returns (int256) {
        // Important: This shows the current delta for this token/user pair
        return poolManager.currencyDelta(user, currency);
        // Negative: User owes tokens
        // Positive: User can claim tokens
        // Zero: No outstanding obligations
    }
}
```



The `TransientStateLibrary` provides utilities to check the current state of deltas at any point in your transaction. The `currencyDelta` function returns an int256 where negative values indicate the user owes tokens to the PoolManager, positive values mean the user can claim tokens from the PoolManager, and zero means there are no outstanding obligations for this token/user pair.

### Resolving Deltas

You must resolve all deltas before your transaction completes. There are two main approaches:

**1. Using ERC-20 Functions**

When using ERC-20 tokens, settling requires a specific sequence of operations:

```solidity
function resolveWithERC20(
    Currency currency,
    uint256 amount
) external {
    // For negative deltas (you owe tokens):
    if (!currency.isAddressZero()) {  // If not ETH
        poolManager.sync(currency);    // Sync currency balance first
        IERC20Minimal(Currency.unwrap(currency)).transfer(
            address(poolManager), 
            amount
        );
        poolManager.settle();          // Complete the settlement
    }

    // For positive deltas (receiving tokens):
    poolManager.take(currency, address(this), amount);
}
```



When resolving negative deltas with ERC-20 tokens, you need to:

1. Sync the currency balance with `sync()`
2. Transfer the tokens to the PoolManager
3. Complete the settlement with `settle()`

For positive deltas, simply use `take` to receive tokens from the PoolManager.

**2. Using ERC-6909 Functions**

```solidity
function resolveWithERC6909(
    Currency currency,
    uint256 amount
) external {
    // For negative deltas (you owe tokens):
    poolManager.burn(currency, address(this), amount);

    // For positive deltas (receiving tokens):
    poolManager.mint(currency, address(this), amount);
}
```



ERC-6909 operations map to their ERC-20 equivalents in v4:

- Use `burn` when you would use `settle` (for negative deltas)
- Use `mint` when you would use `take` (for positive deltas)

Notice how this pattern requires no additional sync operations or separate token transfers.

> **Important**: *Every delta must be resolved before the transaction ends, or the entire transaction will revert. Use* `TransientStateLibrary` *to verify your balances are properly settled.*

> *Delta is a net balance resulting from token movements thus not bound to a certain token type i.e. can be resolved via mix-and-match with ERC-20 functions and ERC-6909 functions.*

## Working with Flash Accounting

To interact with the PoolManager, we first need to create the functions our users will call. Then we'll implement the unlock callback pattern required to execute these operations.

### Using the Lock/Unlock Pattern

Let's start by creating our external function. First, we need to implement the callback that the `PoolManager` will use:

```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory) {
    // To be implemented later
}
```



Now let's implement our external function that users will call:

```solidity
function executeSwap(
    PoolKey calldata key,
    uint256 amount
) external returns (int256, int256) {
    // Encode operation parameters
    bytes memory data = abi.encode(key, amount);

    // Call unlock with encoded data
    bytes memory result = poolManager.unlock(data);

    // Optional: Decode any relevant return data
    return (0, 0); // Replace with actual return values if needed
}
```



When you call this function the flow followed is the following:

1. `unlock` is called on the PoolManager
2. PoolManager calls back to your `unlockCallback`
3. Your callback executes the operations
4. All deltas must be resolved before returning
5. Execution of the logic returns to the PoolManager which verifies there are no outstanding deltas, and will relock itself

> **Warning***: Always implement proper access control in your unlock callback. Only the PoolManager should be able to call it.*

### Implementing the Unlock Callback

First, let’s set up a contract with the proper unlock callback implementation:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {BalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {Currency} from "@uniswap/v4-core/src/types/Currency.sol";

contract FlashAccountingExample {
    IPoolManager public immutable poolManager;

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }
    
    function executeSwap(
        PoolKey calldata key,
        uint256 amount
    ) external returns (int256, int256) {
        ...
    }

    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        // Important: Must check caller is PoolManager
        require(msg.sender == address(poolManager), "Not pool manager");

        // Decode and call our executeOperations function which 
        // we'll implement next
        (bytes memory result) = executeOperations(data);

        // Important: Must return bytes, even if empty
        return result;
    }
}
```



This base contract sets up the foundation for working with v4’s flash accounting. The `unlockCallback` function is required for any operations that access pool liquidity - when your contract calls `poolManager.unlock()`, the PoolManager calls back to this function to execute your operations.

The callback must verify it's being called by the PoolManager and return a bytes value (even if empty) to prevent transaction failures. Any actual pool operations (like swaps or liquidity changes) will be handled through the `executeOperations` function.

> **Critical Note***: The most common mistake developers make is not returning a bytes value from unlockCallback. This will cause your transaction to revert. Always return a bytes value, even if it’s empty.*

Let’s add functionality to execute operations:

```solidity
function executeOperations(
    bytes calldata data
) internal returns (bytes memory) {
    // Decode operation parameters
    (PoolKey memory key, uint256 amount) = abi.decode(
        data,
        (PoolKey, uint256)
    );

    // Execute operation (e.g. swap)
    BalanceDelta delta = poolManager.swap(
        key,
        IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: -int256(amount),
            sqrtPriceLimitX96: 0
        }),
        ""
    );

    // Resolve deltas
    if (delta.amount0() < 0) {
        poolManager.sync(key.currency0);
        IERC20Minimal(Currency.unwrap(key.currency0)).transfer(
            address(poolManager),
            uint256(-delta.amount0())
        );
        poolManager.settle();
    }
    if (delta.amount1() > 0) {
        poolManager.take(
            key.currency1,
            address(this),
            uint256(delta.amount1())
        );
    }

    return ""; // Return empty bytes if no specific result needed
}
```



The `executeOperations` function handles the actual pool operations. It first decodes the data passed from the unlock call to get the operation parameters.

In this example, it executes a swap which creates deltas (token obligations) that must be resolved. For negative deltas (tokens we owe), we follow a specific sequence: first sync the currency state, then transfer the tokens to the PoolManager, and finally call settle. For positive deltas (tokens we receive), we use take to claim them. All deltas must be resolved before the function returns or the transaction will revert.

## Managing Liquidity with Flash Accounting

When adding or removing liquidity in v4, you’ll use `modifyLiquidity` which creates deltas that need to be handled through flash accounting. Let's understand how this works.

### Adding Liquidity

```solidity
// Example: Adding liquidity creates negative deltas (you need to provide tokens)
BalanceDelta delta = poolManager.modifyLiquidity(
    key,
    IPoolManager.ModifyLiquidityParams({
        tickLower: tickLower,       // Lower price bound for position
        tickUpper: tickUpper,       // Upper price bound for position
        liquidityDelta: liquidityAmount  // Positive for adding liquidity
    }),
    ""  // No hook data needed
);

// Negative deltas for both tokens
// delta.amount0() = -100  (need to provide token0)
// delta.amount1() = -200  (need to provide token1)
```



When adding liquidity to a pool, you’ll need to provide both tokens in the pair. The `modifyLiquidity` function returns a [`BalanceDelta`](https://docs.uniswap.org/contracts/v4/reference/core/types/balancedelta) that indicates how many tokens you need to provide. In this case:

- The negative values in the delta (-100, -200) indicate you need to provide these amounts of each token
- The values are proportional to the current pool price and your specified price range (tickLower to tickUpper)
- These deltas must be resolved by providing the tokens before the transaction completes

### Removing Liquidity

```solidity
// Example: Removing liquidity creates positive deltas (you receive tokens)
BalanceDelta delta = poolManager.modifyLiquidity(
    key,
    IPoolManager.ModifyLiquidityParams({
        tickLower: tickLower,       // Same position bounds as when added
        tickUpper: tickUpper,
        liquidityDelta: -liquidityAmount  // Negative for removing liquidity
    }),
    ""  // No hook data needed
);

// Positive deltas for both tokens
// delta.amount0() = +100  (receive token0)
// delta.amount1() = +200  (receive token1)
```



When removing liquidity, the process is reversed. The negative `liquidityDelta` indicates you're removing liquidity, and the function returns positive deltas representing the tokens you'll receive:

- The positive values (+100, +200) indicate the amounts you’ll receive of each token
- The amounts depend on the pool’s current state and how much liquidity you’re removing
- These positive deltas represent tokens you can claim from the pool

> **Important***: Unlike single token operations, liquidity management typically involves handling deltas for both tokens in the pool.*

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Access msg.sender Inside a Hook](https://docs.uniswap.org/contracts/v4/guides/accessing-msg.sender-using-hook)

# Access msg.sender Inside a Hook

In Uniswap v4, when a hook is triggered, `msg.sender` is always the PoolManager contract, not the EOA or smart-account that initiated the swap. This behavior occurs because the PoolManager acts as an intermediary, executing the swap logic on behalf of the user.

## Securely Retrieving the Original `msg.sender` address in a Hook

Since a smart contract executes the swap, the `sender` parameter passed to `beforeSwap()` represents the caller of `PoolManager.swap()`.

This is typically a router contract, such as a custom swap router or the Universal Router. The challenge is distinguishing between different routers and securely obtaining the original msg.sender.

This guide explains how to securely retrieve the EOA or smart account in a hook.

## Hook Overview

To identify the true sender of a swap:

- Maintain a trusted list of swap routers in the hook.
- When a swap is initiated, check if the sender is a trusted router.
- If trusted, call `msgSender()` view function on the router to retrieve the original EOA.

# Implementing a Trusted Router Mechanism

## Implement the Hook

Lets start with a simple hook that wants to access `msg.sender` in `beforeSwap()`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Import statements for a hook

contract AccessSenderHook is BaseHook {
    // constructor, state, interface, etc
    // ...

    function _beforeSwap(address sender, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        // read msg.sender
        // ...

        return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
    }

    ...
}
```



> [Refer to Building your first hook](https://docs.uniswap.org/contracts/v4/guides/hooks/your-first-hook#setting-things-up)

## Define an Interface for Trusted Routers

Each trusted router should implement a standard function that exposes the original `msg.sender`

```solidity
interface IMsgSender {
    function msgSender() external view returns (address);
}
```



This function allows hooks to query the router for the actual sender.

## Store a List of Trusted Routers

The hook should keep track of which router contracts can be trusted to return a valid `msgSender()`

This can be done with the help of add and remove functions implemented in the hook.

```text
mapping(address swapRouter => bool approved) public verifiedRouters;
```



note

Make sure you include an address mapping in your hook for the routers before adding the functions.

```solidity
function addRouter(address _router) external {
    verifiedRouters[_router] = true;
    console.log("Router added:", _router);
}
```



This function allows hook to add the router to the list of trusted routers.

```solidity
function removeRouter(address _router) external {
    verifiedRouters[_router] = false;
    console.log("Router removed:", _router);
}
```



This function allows the hook to remove the router from the list of trusted routers if it's no longer needed.

## Implementing `beforeSwap`

Now that we have implemented a basic hook and have added necessary functions, let us implement the beforeSwap function:

```solidity
function _beforeSwap(address sender, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    override
    returns (bytes4, BeforeSwapDelta, uint24)
{
    try IMsgSender(sender).msgSender() returns (address swapper) {
        console.log("Swap initiated by account:", swapper);
    } catch {
        revert("Router does not implement msgSender()");
    }

    return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
}
```



note

While developing, make sure that you verify the contracts are valid before adding them to the list of trusted routers.

> **Here are some examples of trusted routers:**

- https://github.com/Uniswap/universal-router/tree/main
- https://github.com/z0r0z/v4-router

**Here is the full working code sample:**

```solidity=
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
import "forge-std/console.sol";

interface IMsgSender {
    function msgSender() external view returns (address);
}

contract AccessSenderHook is BaseHook {

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {
    }

    function _beforeSwap(
        address sender,
        PoolKey calldata,
        IPoolManager.SwapParams calldata,
        bytes calldata
    ) internal override returns (bytes4, BeforeSwapDelta, uint24) {

        try IMsgSender(sender).msgSender() returns (address swapper) {
            console.log("Swap initiated by account:", swapper);
        } catch {
            revert("Router does not implement msgSender()");
        }

        return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
    }

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: false,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: true,
                afterSwap: false,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }
    
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Calculate LP fees](https://docs.uniswap.org/contracts/v4/guides/calculate-lp-fees)

# Calculate LP fees

## Introduction

With hook introduced in v4, [Dynamic Fees](https://docs.uniswap.org/contracts/v4/concepts/07-dynamic-fees.mdx) is now possible and allow v4 pools to have a flexible and responsive fee structure comparing to v3 pools with static fee tiers(0.05%, 0.3%, 1%).

While in v3 we can get the amount for the fees claimed on each liquidity operation in the `Collect` event, in v4 with dynamic fees, swap fees are directly accrued to liquidity positions and can be further handled by hooks at *`afterModifyLiquidity`* - thus we should not emit `feesAccrued` in the event `ModifiyLiquidity`. This not only saves gas on event emission but more importantly avoid causing confusion since the amount of `feesAccrued` could be changed as a result of hook execution.

```solidity
// Modify liquidity in v4
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData) 
    // ... 
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued) 
{
    PoolId id = key.toId();
    {
        // ... (other code)
        BalanceDelta principalDelta;
        (principalDelta, feesAccrued) = pool.modifyLiquidity(
            // ... (the ModifyLiquidityParams)
        );
        callerDelta = principalDelta + feesAccrued;
    }

    // event is emitted before the afterModifyLiquidity call to ensure events are always emitted in order
    emit ModifyLiquidity(id, msg.sender, params.tickLower, params.tickUpper, params.liquidityDelta, params.salt);

    BalanceDelta hookDelta;
    (callerDelta, hookDelta) = key.hooks.afterModifyLiquidity(key, params, callerDelta, feesAccrued, hookData);
    // ... (other code)
}
```



In this guide we will go through how you can calculate fees earned for a LP position in v4 specifically the **uncollected fees** and **total lifetime fees**.

## Contract Setup

Import the necessary dependencies and prepare the function signature for `getUncollectedFees` and `getLifetimeFees`.

```solidity
pragma solidity ^0.8.24;

import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {Position} from "@uniswap/v4-core/src/libraries/Position.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import {BalanceDelta, toBalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {PoolId} from "@uniswap/v4-core/src/types/PoolId.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";

import {IPositionManager} from "src/interfaces/IPositionManager.sol";
import {PositionConfig} from "src/types/PositionConfig.sol";

contract CalculateFeeExample {
    using SafeCast for uint256;
    using StateLibrary for IPoolManager;

    IPositionManager posm = IPositionManager(<POSM_ADDRESS>);
    IPoolManager manager = IPoolManager(<POOL_MANAGER_ADDRESS>);

    function getUncollectedFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta uncollectedFees) {}

    function getLifetimeFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta lifetimeFees) {}
}
```



### Calculate uncollected fees for a LP position

In `getUncollectedFees(PositionConfig config, uint256 tokenId)`:

1. Get the last recorded fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`

```solidity
PoolId poolId = config.poolKey.toId();

// getPositionInfo(poolId, owner, tL, tU, salt)
// owner is the position manager, salt is the tokenId
(uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) =
    manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
```



1. Get the all-time fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`

```solidity
(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = 
    manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);
```



1. Compare the *all-time feeGrowthInside* from step 2 against the *last recorded feeGrowthInside* from step 1, and convert it to token amount

```solidity
uint128 tokenAmount =
    (FullMath.mulDiv(feeGrowthInsideX128 - feeGrowthInsideLastX128, liquidity, FixedPoint128.Q128)).toUint128();
```



### Calculate lifetime fees earned for a LP range

Create a new function `getLifetimeFee(PositionConfig config, uint256 tokenId)`:

1. Get the all-time fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`

```solidity
(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = 
    manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);
```



1. Convert it to token amount

```solidity
uint128 tokenAmount =
    (FullMath.mulDiv(feeGrowthInsideX128, liquidity, FixedPoint128.Q128)).toUint128();
```



## Full Contract

```solidity
pragma solidity ^0.8.24;

import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {Position} from "@uniswap/v4-core/src/libraries/Position.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import {BalanceDelta, toBalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {PoolId} from "@uniswap/v4-core/src/types/PoolId.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";

import {IPositionManager} from "src/interfaces/IPositionManager.sol";
import {PositionConfig} from "src/types/PositionConfig.sol";

contract CalculateFeeExample {
    using SafeCast for uint256;
    using StateLibrary for IPoolManager;

    IPositionManager posm = IPositionManager(<POSM_ADDRESS>);
    IPoolManager manager = IPoolManager(<POOL_MANAGER_ADDRESS>);

    function getUncollectedFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta uncollectedFees) {

        PoolId poolId = config.poolKey.toId();

        (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) =
            manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
            manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);

        uncollectedFees = _convertFeesToBalanceDelta(
            feeGrowthInside0X128 - feeGrowthInside0LastX128, feeGrowthInside1X128 - feeGrowthInside1LastX128, liquidity);
    }

    function getLifetimeFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta lifetimeFees) {

        PoolId poolId = config.poolKey.toId();

        (uint128 liquidity,,) = manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
            manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);

        lifetimeFees = _convertFeesToBalanceDelta(feeGrowthInside0X128, feeGrowthInside1X128, liquidity);
    }

    function _convertFeesToBalanceDelta(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128, uint256 liquidity) 
        internal
        view 
        returns (BalanceDelta feesInBalanceDelta) {
            
        uint128 token0Amount = (FullMath.mulDiv(feeGrowthInside0X128, liquidity, FixedPoint128.Q128)).toUint128();
        uint128 token1Amount = (FullMath.mulDiv(feeGrowthInside1X128, liquidity, FixedPoint128.Q128)).toUint128();
        feesInBalanceDelta = toBalanceDelta(uint256(token0Amount).toInt128(), uint256(token1Amount).toInt128());
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolGuides[Subscriber](https://docs.uniswap.org/contracts/v4/guides/subscriber)

# Subscriber

## Introduction

Uniswap v4 introduces Subscribers, a new mechanism in v4 that allows external contracts (aka Subscribers) to be notified by the PositionManager whenever specific events occur (e.g., liquidity changes, burns). It’s especially useful for designing **liquidity incentive** systems or reward programs.

Before diving into implementation details, let's understand what makes Subscribers valuable. When a position holder subscribes their position to a Subscriber contract, that contract receives notifications about various events: liquidity changes, position burns, and subscription status changes. This flow enables protocols to accurately track and reward liquidity provision.

Subscribers become of aware of the liquidity position, without needing to own the position and its underlying capital.

## Interface Methods

Let's explore each method that a [ISubscriber](https://github.com/Uniswap/v4-periphery/blob/main/src/interfaces/ISubscriber.sol) contract needs to implement. Understanding when and why these methods are called is crucial for building effective Subscriber contracts.

### Position Subscription Handling

The first two methods handle the subscription lifecycle:

```solidity
function notifySubscribe(
    uint256 tokenId,
    bytes memory data
) external;
```



This method is called whenever a position subscribes to your contract. The `tokenId` parameter identifies the subscribing position, while `data` can contain additional configuration information.

For example, you might use this data parameter to specify:

- Lock-up duration for rewards
- Campaign-specific settings
- Custom reward parameters

> ***Note**: The data parameter is entirely optional and its interpretation is up to your implementation.*

```solidity
function notifyUnsubscribe(
    uint256 tokenId
) external;
```



When a position unsubscribes, this method is called. There's an important consideration here:

> ***Important**: The gas consumption of this function must be less than unsubscribeGasLimit (set when deploying the PositionManager). This ensures users can always unsubscribe from your contract.

Also note that the subscriber contract reverts, the position will still unsuccessfully subscribe*

> 

### Position Modification Notifications

The next method handles liquidity changes and fee collection:

```solidity
function notifyModifyLiquidity(
    uint256 tokenId,
    int256 liquidityChange,
    BalanceDelta feesAccrued
) external;
```



This method is your window into position activity. It gets called in two scenarios:

- When users modify their liquidity (increase or decrease)
- When they collect accumulated fees

Here's what each parameter tells you:

- `tokenId`: The position being modified
- `liquidityChange`: How much liquidity is being added or removed (positive for additions, negative for removals)
- `feesAccrued`: Fees collected during this operation

> ***Warning**: Be cautious with feesAccrued values. In pools with a single liquidity position, malicious users can artificially inflate these values through self-donations.*

### Handling Position Burns

The final method deals with position termination:

```solidity
function notifyBurn(
    uint256 tokenId,
    address owner,
    PositionInfo info,
    uint256 liquidity,
    BalanceDelta feesAccrued
) external;
```



When a position is burned (fully removed), this method provides comprehensive information about its final state:

- Who owned it (`owner`)
- Its configuration (`info`)
- How much liquidity was removed (`liquidity`)
- Any final fees collected (`feesAccrued`)

> ***Important**: When a position is burned, you'll only receive notifyBurn - there's no separate notifyModifyLiquidity call.*

## How to Use Subscribers

Let's walk through the process of implementing and using a Subscriber contract. We'll break this down into four main steps that developers typically follow.

### Step 1: Implement Subscriber

First, create your contract implementing the ISubscriber interface:

```solidity
contract MySubscriber is ISubscriber {
    // Track subscribed positions
    mapping(uint256 => bool) public isSubscribed;

    // Implementation of interface methods
    function notifySubscribe(uint256 tokenId, bytes memory data) external {
        // Store subscription status
        isSubscribed[tokenId] = true;
    }

    // Other required methods...
}
```



> ***Note**: This is a basic implementation. Your actual contract will need more sophisticated tracking depending on your reward mechanism.*

### Step 2: Deploy Subscriber

Once implemented, deploy your contract:

```solidity
MySubscriber subscriber = new MySubscriber();
```



Make sure to store the deployed address - users will need it to subscribe their positions.

### Step 3: Mint Position

Users need positions before they can subscribe. They can either use existing positions or mint new ones:

```solidity
// Using the Position Manager
uint256 tokenId = positionManager.mint(
    poolKey,
    tickLower,
    tickUpper,
    liquidity,
    // other parameters...
);
```



### Step 4: Subscribe Position

Finally, users can subscribe their positions to your contract:

```solidity
// Optional configuration data
bytes memory subscriptionData = ""; // Configure based on your needs

// Subscribe the position
positionManager.subscribe(
    tokenId,
    subscriber,
    subscriptionData
);
```



> ***Important**: Make sure users understand any lock-up periods or conditions specified in your subscriptionData.*

### Important Considerations

When implementing and deploying Subscriber contracts, there are several crucial aspects to keep in mind. Let's explore each of these to ensure your implementation is secure and efficient.

### Gas Limits and Unsubscribe Safety

The most critical consideration is the unsubscribe process:

> ***Critical**: Your notifyUnsubscribe function must consume less gas than the unsubscribeGasLimit defined in the PositionManager. This is not just a best practice - it's a fundamental safety requirement that ensures users can always exit your system.*

For example:

```solidity
function notifyUnsubscribe(uint256 tokenId) external {
    // Keep this function lightweight
    delete positionData[tokenId]; // Simple state cleanup
    emit PositionUnsubscribed(tokenId);
}
```



## Implementation Patterns

When building your Subscriber, follow these established patterns:

### Liquidity Tracking

It's essential to properly track liquidity changes:

- Use `notifyModifyLiquidity` to update your internal accounting
- Remember that positive changes mean liquidity is being added
- Account for negative changes when liquidity is removed

> ***Note**: During a position burn, you'll only receive notifyBurn - there won't be a separate notifyModifyLiquidity call.*

### Optional Data Handling

The `optionalData` parameter in subscriptions can be used for:

- Additional campaign configuration
- Lock-up duration specifications
- Other custom parameters

## Security Considerations

Since Subscriber contracts often handle value distribution, security is paramount:

### Value Distribution

- **Custody**: Implement secure mechanisms for handling reward tokens
- **Calculation**: Ensure reward calculations are accurate and cannot be manipulated

### Protection Against Exploitation

Be aware of potential attack vectors:

- Users can artificially inflate `feesAccrued` in single-position pools
- Malicious actors might attempt to claim rewards they haven't earned

> ***Warning**: Always validate inputs and implement thorough checks before distributing any value.*

## Implementation Example

Let’s build a **minimal** Subscriber implementation that demonstrates how to handle position events. In practice, you’d likely extend these concepts to include reward calculations or more complex accounting.

> ***Note**: The code below focuses on the essential mechanics of receiving notifications. A production system will need additional logic for security, reward distribution, and user interaction.*

### Basic Reward Tracking

First, we set up our contract with the necessary data structures and references:

```solidity
contract LiquidityRewardsSubscriber is ISubscriber {
    // 1) Store subscription timestamps and liquidity for each position
    struct PositionData {
        uint256 subscriptionTime;
        uint256 currentLiquidity;
        bool isSubscribed;
    }

    // 2) A mapping from tokenId (position NFT) to our custom tracking data
    mapping(uint256 => PositionData) public positions;

    // 3) Reference to the PositionManager so we can authenticate notifications
    IPositionManager public immutable positionManager;

    constructor(IPositionManager _positionManager) {
        positionManager = _positionManager;
    }
}
```



### Why This Matters

- **`PositionData`**: Tracks how long the position has been subscribed (`subscriptionTime`), how much liquidity it currently has (`currentLiquidity`), and whether it’s active (`isSubscribed`).
- **`positionManager`**: We only trust calls from this authorized contract, preventing anyone else from triggering notifications.

## Handling Subscription Events

Next, we implement `notifySubscribe` and `notifyUnsubscribe` to manage a position’s subscription status:

```solidity
		/// @notice Handle new position subscriptions
		function notifySubscribe(
		    uint256 tokenId,
		    bytes memory /* data */
		) external {
		    require(msg.sender == address(positionManager), "Unauthorized");
		
		    positions[tokenId] = PositionData({
		        subscriptionTime: block.timestamp,
		        currentLiquidity: 0,
		        isSubscribed: true
		    });
		}
		
		/// @notice Clean up on unsubscribe
		/// @dev Keep this minimal to respect unsubscribeGasLimit
		function notifyUnsubscribe(uint256 tokenId) external {
		    require(msg.sender == address(positionManager), "Unauthorized");
		
		    // Remove all stored data for unsubscribed positions
		    delete positions[tokenId];
		}
```



### Key Takeaways

- We store the current block timestamp on `notifySubscribe` to measure how long a position has been subscribed.
- The `notifyUnsubscribe` method is deliberately small to ensure it remains below the `unsubscribeGasLimit`.

## Listening for Liquidity Modifications

Positions can add or remove liquidity, and potentially collect fees during the same transaction:

```solidity
/// @notice Track liquidity changes or fee collections
function notifyModifyLiquidity(
    uint256 tokenId,
    int256 liquidityChange,
    BalanceDelta /* feesAccrued */
) external {
    require(msg.sender == address(positionManager), "Unauthorized");

    PositionData storage position = positions[tokenId];

    if (liquidityChange > 0) {
        // Positive value indicates added liquidity
        position.currentLiquidity += uint256(liquidityChange);
    } else if (liquidityChange < 0) {
        // Negative value indicates removed liquidity
        position.currentLiquidity -= uint256(-liquidityChange);
    }
}
```



### Why This Is Important

- **`liquidityChange`** can be positive (liquidity added) or negative (liquidity removed). We update our internal tracking accordingly.
- **`feesAccrued`** is provided if the user also collects fees during this action. In a more advanced version, you could track these fees for reward calculations.

## Processing Position Burns

When a position is completely removed (burned), Uniswap v4 calls `notifyBurn`:

```solidity
/// @notice Called when a position is fully removed
function notifyBurn(
    uint256 tokenId,
    address,
    PositionInfo,
    uint256,
    BalanceDelta
) external {
    require(msg.sender == address(positionManager), "Unauthorized");

    // The position no longer exists, so remove our records
    delete positions[tokenId];
}
```



### Important Distinction

- **No `notifyModifyLiquidity`** is triggered on a full burn—`notifyBurn` covers any final liquidity/fee changes.

## Using the Subscriber

To put this into practice:

```solidity
// 1. Deploy the subscriber
LiquidityRewardsSubscriber subscriber = new LiquidityRewardsSubscriber(positionManager);

// 2. Users then subscribe their positions
positionManager.subscribe(tokenId, subscriber, "");
```



- **Deployment**: The developer deploying the Subscriber contract must store its address and share it with users.
- **Subscription**: Users call `subscribe(...)` on the PositionManager, passing in the `tokenId` and the subscriber’s address (yours).

## Production Considerations

> This example is deliberately minimal. A real-world Subscriber would need:
>
> - **Reward Distribution**: Logic that calculates and distributes incentives based on `subscriptionTime`, `currentLiquidity`, or `feesAccrued`.
> - **Security Checks**: Safeguards against malicious actors who might inflate fees, manipulate liquidity changes, or spam subscribe/unsubscribe cycles.
> - **Access Control**: Roles or permissions if only certain addresses are allowed to manage rewards or update parameters.
> - **Gas Optimization**: Especially if you expect many positions to subscribe/unsubscribe frequently.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical Reference[Errors](https://docs.uniswap.org/contracts/v4/reference/errors/)

# Custom Error Selectors

These are custom error selectors for Uniswap v4 contracts.

## IPoolManager.sol

| Error Selector                                         | Hex Value    |
| ------------------------------------------------------ | ------------ |
| `IPoolManager.CurrencyNotSettled.selector`             | `0x5212cba1` |
| `IPoolManager.PoolNotInitialized.selector`             | `0x486aa307` |
| `IPoolManager.AlreadyUnlocked.selector`                | `0x5090d6c6` |
| `IPoolManager.ManagerLocked.selector`                  | `0x54e3ca0d` |
| `IPoolManager.TickSpacingTooLarge.selector`            | `0xb02b5dc2` |
| `IPoolManager.TickSpacingTooSmall.selector`            | `0x16fe7696` |
| `IPoolManager.CurrenciesOutOfOrderOrEqual.selector`    | `0xeaa6c6eb` |
| `IPoolManager.UnauthorizedDynamicLPFeeUpdate.selector` | `0x30d21641` |
| `IPoolManager.SwapAmountCannotBeZero.selector`         | `0xbe8b8507` |
| `IPoolManager.NonZeroNativeValue.selector`             | `0x19d245cf` |

## Hooks.sol

| Error Selector                              | Hex Value    |
| ------------------------------------------- | ------------ |
| `Hooks.HookAddressNotValid.selector`        | `0xe65af6a0` |
| `Hooks.InvalidHookResponse.selector`        | `0x1e048e1d` |
| `Hooks.FailedHookCall.selector`             | `0x36bc48c5` |
| `Hooks.HookDeltaExceedsSwapAmount.selector` | `0xfa0b71d6` |

## Pool.sol

| Error Selector                            | Hex Value    |
| ----------------------------------------- | ------------ |
| `Pool.TicksMisordered.selector`           | `0xc4433ed5` |
| `Pool.TickLowerOutOfBounds.selector`      | `0xd5e2f7ab` |
| `Pool.TickUpperOutOfBounds.selector`      | `0x1ad777f8` |
| `Pool.TickLiquidityOverflow.selector`     | `0xb8e3c385` |
| `Pool.TickNotInitialized.selector`        | `0x82a774d3` |
| `Pool.PoolAlreadyInitialized.selector`    | `0x7983c051` |
| `Pool.PoolNotInitialized.selector`        | `0x486aa307` |
| `Pool.PriceLimitAlreadyExceeded.selector` | `0x7c9c6e8f` |
| `Pool.PriceLimitOutOfBounds.selector`     | `0x9e4d7cc7` |
| `Pool.NoLiquidityToReceiveFees.selector`  | `0xa74f97ab` |
| `Pool.InvalidFeeForExactOut.selector`     | `0x96206246` |

## IProtocolFees.sol

| Error Selector                                      | Hex Value    |
| --------------------------------------------------- | ------------ |
| `IProtocolFees.ProtocolFeeCannotBeFetched.selector` | `0x1ee49702` |
| `IProtocolFees.InvalidProtocolFee.selector`         | `0xba97f838` |
| `IProtocolFees.InvalidCaller.selector`              | `0x48f5c3ed` |

## LPFeeLibrary.sol

| Error Selector                      | Hex Value    |
| ----------------------------------- | ------------ |
| `LPFeeLibrary.FeeTooLarge.selector` | `0xfc5bee12` |

## Position.sol

| Error Selector                                | Hex Value    |
| --------------------------------------------- | ------------ |
| `Position.CannotUpdateEmptyPosition.selector` | `0xaefeb924` |

## Reserves.sol

| Error Selector                           | Hex Value    |
| ---------------------------------------- | ------------ |
| `Reserves.ReservesMustBeSynced.selector` | `0x8774be48` |

## SqrtPriceMath.sol

| Error Selector                                   | Hex Value    |
| ------------------------------------------------ | ------------ |
| `SqrtPriceMath.InvalidPriceOrLiquidity.selector` | `0x4f2461b8` |
| `SqrtPriceMath.InvalidPrice.selector`            | `0x00bfc921` |
| `SqrtPriceMath.NotEnoughLiquidity.selector`      | `0x4323a555` |
| `SqrtPriceMath.PriceOverflow.selector`           | `0xf5c787f1` |

## TickBitmap.sol

| Error Selector                       | Hex Value    |
| ------------------------------------ | ------------ |
| `TickBitmap.TickMisaligned.selector` | `0xd4d8f3e6` |

## TickMath.sol

| Error Selector                       | Hex Value    |
| ------------------------------------ | ------------ |
| `TickMath.InvalidTick.selector`      | `0xce8ef7fc` |
| `TickMath.InvalidSqrtPrice.selector` | `0x31efafe8` |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[BitMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/BitMath)

# BitMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/BitMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Author:** Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)

*This library provides functionality for computing bit properties of an unsigned integer*

## Functions

### mostSignificantBit

Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255

```solidity
function mostSignificantBit(uint256 x) internal pure returns (uint8 r);
```



**Parameters**

| Name | Type      | Description                                                  |
| ---- | --------- | ------------------------------------------------------------ |
| `x`  | `uint256` | the value for which to compute the most significant bit, must be greater than 0 |

**Returns**

| Name | Type    | Description                           |
| ---- | ------- | ------------------------------------- |
| `r`  | `uint8` | the index of the most significant bit |

### leastSignificantBit

Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255

```solidity
function leastSignificantBit(uint256 x) internal pure returns (uint8 r);
```



**Parameters**

| Name | Type      | Description                                                  |
| ---- | --------- | ------------------------------------------------------------ |
| `x`  | `uint256` | the value for which to compute the least significant bit, must be greater than 0 |

**Returns**

| Name | Type    | Description                            |
| ---- | ------- | -------------------------------------- |
| `r`  | `uint8` | the index of the least significant bit |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[CurrencyDelta](https://docs.uniswap.org/contracts/v4/reference/core/libraries/CurrencyDelta)

# CurrencyDelta

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CurrencyDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*this library implements the equivalent of a mapping, as transient storage can only be accessed in assembly*

## Functions

### _computeSlot

calculates which storage slot a delta should be stored in for a given account and currency

```solidity
function _computeSlot(address target, Currency currency) internal pure returns (bytes32 hashSlot);
```



### getDelta

```solidity
function getDelta(Currency currency, address target) internal view returns (int256 delta);
```



### applyDelta

applies a new currency delta for a given account and currency

```solidity
function applyDelta(Currency currency, address target, int128 delta) internal returns (int256 previous, int256 next);
```



**Returns**

| Name       | Type     | Description         |
| ---------- | -------- | ------------------- |
| `previous` | `int256` | The prior value     |
| `next`     | `int256` | The modified result |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[CurrencyReserves](https://docs.uniswap.org/contracts/v4/reference/core/libraries/CurrencyReserves)

# CurrencyReserves

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CurrencyReserves.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## State Variables

### RESERVES_OF_SLOT

bytes32(uint256(keccak256("ReservesOf")) - 1)

```solidity
bytes32 constant RESERVES_OF_SLOT = 0x1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd95;
```



### CURRENCY_SLOT

bytes32(uint256(keccak256("Currency")) - 1)

```solidity
bytes32 constant CURRENCY_SLOT = 0x27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b9;
```



## Functions

### getSyncedCurrency

```solidity
function getSyncedCurrency() internal view returns (Currency currency);
```



### resetCurrency

```solidity
function resetCurrency() internal;
```



### syncCurrencyAndReserves

```solidity
function syncCurrencyAndReserves(Currency currency, uint256 value) internal;
```



### getSyncedReserves

```solidity
function getSyncedReserves() internal view returns (uint256 value);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[CustomRevert](https://docs.uniswap.org/contracts/v4/reference/core/libraries/CustomRevert)

# CustomRevert

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CustomRevert.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains functions for reverting with custom errors with different argument types efficiently

*To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with `CustomError.selector.revertWith()`*

*The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately*

## Functions

### revertWith

*Reverts with the selector of a custom error in the scratch space*

```solidity
function revertWith(bytes4 selector) internal pure;
```



### revertWith

*Reverts with a custom error with an address argument in the scratch space*

```solidity
function revertWith(bytes4 selector, address addr) internal pure;
```



### revertWith

*Reverts with a custom error with an int24 argument in the scratch space*

```solidity
function revertWith(bytes4 selector, int24 value) internal pure;
```



### revertWith

*Reverts with a custom error with a uint160 argument in the scratch space*

```solidity
function revertWith(bytes4 selector, uint160 value) internal pure;
```



### revertWith

*Reverts with a custom error with two int24 arguments*

```solidity
function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure;
```



### revertWith

*Reverts with a custom error with two uint160 arguments*

```solidity
function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure;
```



### revertWith

*Reverts with a custom error with two address arguments*

```solidity
function revertWith(bytes4 selector, address value1, address value2) internal pure;
```



### bubbleUpAndRevertWith

bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error

*this method can be vulnerable to revert data bombs*

```solidity
function bubbleUpAndRevertWith(address revertingContract, bytes4 revertingFunctionSelector, bytes4 additionalContext)
    internal
    pure;
```



## Errors

### WrappedError

*ERC-7751 error for wrapping bubbled up reverts*

```solidity
error WrappedError(address target, bytes4 selector, bytes reason, bytes details);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[FixedPoint96](https://docs.uniswap.org/contracts/v4/reference/core/libraries/FixedPoint96)

# FixedPoint96

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/FixedPoint96.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)

*Used in SqrtPriceMath.sol*

## State Variables

### RESOLUTION

```solidity
uint8 internal constant RESOLUTION = 96;
```



### Q96

```solidity
uint256 internal constant Q96 = 0x1000000000000000000000000;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[FullMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/FullMath)

# FullMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/FullMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision

*Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits*

## Functions

### mulDiv

Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

*Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv*

```solidity
function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```



**Parameters**

| Name          | Type      | Description      |
| ------------- | --------- | ---------------- |
| `a`           | `uint256` | The multiplicand |
| `b`           | `uint256` | The multiplier   |
| `denominator` | `uint256` | The divisor      |

**Returns**

| Name     | Type      | Description        |
| -------- | --------- | ------------------ |
| `result` | `uint256` | The 256-bit result |

### mulDivRoundingUp

Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

```solidity
function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```



**Parameters**

| Name          | Type      | Description      |
| ------------- | --------- | ---------------- |
| `a`           | `uint256` | The multiplicand |
| `b`           | `uint256` | The multiplier   |
| `denominator` | `uint256` | The divisor      |

**Returns**

| Name     | Type      | Description        |
| -------- | --------- | ------------------ |
| `result` | `uint256` | The 256-bit result |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[Hooks](https://docs.uniswap.org/contracts/v4/reference/core/libraries/Hooks)

# Hooks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Hooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

V4 decides whether to invoke specific hooks by inspecting the least significant bits of the address that the hooks contract is deployed to. For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400 has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.

## State Variables

### ALL_HOOK_MASK

```solidity
uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);
```



### BEFORE_INITIALIZE_FLAG

```solidity
uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;
```



### AFTER_INITIALIZE_FLAG

```solidity
uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;
```



### BEFORE_ADD_LIQUIDITY_FLAG

```solidity
uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;
```



### AFTER_ADD_LIQUIDITY_FLAG

```solidity
uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;
```



### BEFORE_REMOVE_LIQUIDITY_FLAG

```solidity
uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;
```



### AFTER_REMOVE_LIQUIDITY_FLAG

```solidity
uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;
```



### BEFORE_SWAP_FLAG

```solidity
uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;
```



### AFTER_SWAP_FLAG

```solidity
uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;
```



### BEFORE_DONATE_FLAG

```solidity
uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;
```



### AFTER_DONATE_FLAG

```solidity
uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;
```



### BEFORE_SWAP_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;
```



### AFTER_SWAP_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;
```



### AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;
```



### AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;
```



## Functions

### validateHookPermissions

Utility function intended to be used in hook constructors to ensure the deployed hooks address causes the intended hooks to be called

*permissions param is memory as the function will be called from constructors*

```solidity
function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure;
```



**Parameters**

| Name          | Type          | Description                              |
| ------------- | ------------- | ---------------------------------------- |
| `self`        | `IHooks`      |                                          |
| `permissions` | `Permissions` | The hooks that are intended to be called |

### isValidHookAddress

Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address

```solidity
function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool);
```



**Parameters**

| Name   | Type     | Description                               |
| ------ | -------- | ----------------------------------------- |
| `self` | `IHooks` | The hook to verify                        |
| `fee`  | `uint24` | The fee of the pool the hook is used with |

**Returns**

| Name     | Type   | Description                            |
| -------- | ------ | -------------------------------------- |
| `<none>` | `bool` | bool True if the hook address is valid |

### callHook

performs a hook call using the given calldata on the given hook that doesn't return a delta

```solidity
function callHook(IHooks self, bytes memory data) internal returns (bytes memory result);
```



**Returns**

| Name     | Type    | Description                            |
| -------- | ------- | -------------------------------------- |
| `result` | `bytes` | The complete data returned by the hook |

### callHookWithReturnDelta

performs a hook call using the given calldata on the given hook

```solidity
function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256);
```



**Returns**

| Name     | Type     | Description                           |
| -------- | -------- | ------------------------------------- |
| `<none>` | `int256` | int256 The delta returned by the hook |

### noSelfCall

modifier to prevent calling a hook if they initiated the action

```solidity
modifier noSelfCall(IHooks self);
```



### beforeInitialize

calls beforeInitialize hook if permissioned and validates return value

```solidity
function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self);
```



### afterInitialize

calls afterInitialize hook if permissioned and validates return value

```solidity
function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick) internal noSelfCall(self);
```



### beforeModifyLiquidity

calls beforeModifyLiquidity hook if permissioned and validates return value

```solidity
function beforeModifyLiquidity(
    IHooks self,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) internal noSelfCall(self);
```



### afterModifyLiquidity

calls afterModifyLiquidity hook if permissioned and validates return value

```solidity
function afterModifyLiquidity(
    IHooks self,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta);
```



### beforeSwap

calls beforeSwap hook if permissioned and validates return value

```solidity
function beforeSwap(IHooks self, PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    internal
    returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride);
```



### afterSwap

calls afterSwap hook if permissioned and validates return value

```solidity
function afterSwap(
    IHooks self,
    PoolKey memory key,
    IPoolManager.SwapParams memory params,
    BalanceDelta swapDelta,
    bytes calldata hookData,
    BeforeSwapDelta beforeSwapHookReturn
) internal returns (BalanceDelta, BalanceDelta);
```



### beforeDonate

calls beforeDonate hook if permissioned and validates return value

```solidity
function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    internal
    noSelfCall(self);
```



### afterDonate

calls afterDonate hook if permissioned and validates return value

```solidity
function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    internal
    noSelfCall(self);
```



### hasPermission

```solidity
function hasPermission(IHooks self, uint160 flag) internal pure returns (bool);
```



## Errors

### HookAddressNotValid

Thrown if the address will not lead to the specified hook calls being called

```solidity
error HookAddressNotValid(address hooks);
```



**Parameters**

| Name    | Type      | Description                       |
| ------- | --------- | --------------------------------- |
| `hooks` | `address` | The address of the hooks contract |

### InvalidHookResponse

Hook did not return its selector

```solidity
error InvalidHookResponse();
```



### HookCallFailed

Additional context for ERC-7751 wrapped error when a hook call fails

```solidity
error HookCallFailed();
```



### HookDeltaExceedsSwapAmount

The hook's delta changed the swap from exactIn to exactOut or vice versa

```solidity
error HookDeltaExceedsSwapAmount();
```



## Structs

### Permissions

```solidity
struct Permissions {
    bool beforeInitialize;
    bool afterInitialize;
    bool beforeAddLiquidity;
    bool afterAddLiquidity;
    bool beforeRemoveLiquidity;
    bool afterRemoveLiquidity;
    bool beforeSwap;
    bool afterSwap;
    bool beforeDonate;
    bool afterDonate;
    bool beforeSwapReturnDelta;
    bool afterSwapReturnDelta;
    bool afterAddLiquidityReturnDelta;
    bool afterRemoveLiquidityReturnDelta;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[LPFeeLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/LPFeeLibrary)

# LPFeeLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/LPFeeLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Library of helper functions for a pools LP fee

## State Variables

### DYNAMIC_FEE_FLAG

An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE

```solidity
uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;
```



### OVERRIDE_FEE_FLAG

the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap

```solidity
uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;
```



### REMOVE_OVERRIDE_MASK

mask to remove the override fee flag from a fee returned by the beforeSwaphook

```solidity
uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;
```



### MAX_LP_FEE

the lp fee is represented in hundredths of a bip, so the max is 100%

```solidity
uint24 public constant MAX_LP_FEE = 1000000;
```



## Functions

### isDynamicFee

returns true if a pool's LP fee signals that the pool has a dynamic fee

```solidity
function isDynamicFee(uint24 self) internal pure returns (bool);
```



**Parameters**

| Name   | Type     | Description      |
| ------ | -------- | ---------------- |
| `self` | `uint24` | The fee to check |

**Returns**

| Name     | Type   | Description                     |
| -------- | ------ | ------------------------------- |
| `<none>` | `bool` | bool True of the fee is dynamic |

### isValid

returns true if an LP fee is valid, aka not above the maximum permitted fee

```solidity
function isValid(uint24 self) internal pure returns (bool);
```



**Parameters**

| Name   | Type     | Description      |
| ------ | -------- | ---------------- |
| `self` | `uint24` | The fee to check |

**Returns**

| Name     | Type   | Description                   |
| -------- | ------ | ----------------------------- |
| `<none>` | `bool` | bool True of the fee is valid |

### validate

validates whether an LP fee is larger than the maximum, and reverts if invalid

```solidity
function validate(uint24 self) internal pure;
```



**Parameters**

| Name   | Type     | Description         |
| ------ | -------- | ------------------- |
| `self` | `uint24` | The fee to validate |

### getInitialLPFee

gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.

*if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook*

```solidity
function getInitialLPFee(uint24 self) internal pure returns (uint24);
```



**Parameters**

| Name   | Type     | Description                        |
| ------ | -------- | ---------------------------------- |
| `self` | `uint24` | The fee to get the initial LP from |

**Returns**

| Name     | Type     | Description                                                  |
| -------- | -------- | ------------------------------------------------------------ |
| `<none>` | `uint24` | initialFee 0 if the fee is dynamic, otherwise the fee (if valid) |

### isOverride

returns true if the fee has the override flag set (2nd highest bit of the uint24)

```solidity
function isOverride(uint24 self) internal pure returns (bool);
```



**Parameters**

| Name   | Type     | Description      |
| ------ | -------- | ---------------- |
| `self` | `uint24` | The fee to check |

**Returns**

| Name     | Type   | Description                                    |
| -------- | ------ | ---------------------------------------------- |
| `<none>` | `bool` | bool True of the fee has the override flag set |

### removeOverrideFlag

returns a fee with the override flag removed

```solidity
function removeOverrideFlag(uint24 self) internal pure returns (uint24);
```



**Parameters**

| Name   | Type     | Description                              |
| ------ | -------- | ---------------------------------------- |
| `self` | `uint24` | The fee to remove the override flag from |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `uint24` | fee The fee without the override flag set |

### removeOverrideFlagAndValidate

Removes the override flag and validates the fee (reverts if the fee is too large)

```solidity
function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee);
```



**Parameters**

| Name   | Type     | Description                                                 |
| ------ | -------- | ----------------------------------------------------------- |
| `self` | `uint24` | The fee to remove the override flag from, and then validate |

**Returns**

| Name  | Type     | Description                                      |
| ----- | -------- | ------------------------------------------------ |
| `fee` | `uint24` | The fee without the override flag set (if valid) |

## Errors

### LPFeeTooLarge

Thrown when the static or dynamic fee on a pool exceeds 100%.

```solidity
error LPFeeTooLarge(uint24 fee);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[LiquidityMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/LiquidityMath)

# LiquidityMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/LiquidityMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### addDelta

Add a signed liquidity delta to liquidity and revert if it overflows or underflows

```solidity
function addDelta(uint128 x, int128 y) internal pure returns (uint128 z);
```



**Parameters**

| Name | Type      | Description                                    |
| ---- | --------- | ---------------------------------------------- |
| `x`  | `uint128` | The liquidity before change                    |
| `y`  | `int128`  | The delta by which liquidity should be changed |

**Returns**

| Name | Type      | Description         |
| ---- | --------- | ------------------- |
| `z`  | `uint128` | The liquidity delta |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[Lock](https://docs.uniswap.org/contracts/v4/reference/core/libraries/Lock)

# Lock

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Lock.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload) TODO: This library can be deleted when we have the transient keyword support in solidity.

## State Variables

### IS_UNLOCKED_SLOT

```solidity
bytes32 internal constant IS_UNLOCKED_SLOT = 0xc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab23;
```



## Functions

### unlock

```solidity
function unlock() internal;
```



### lock

```solidity
function lock() internal;
```



### isUnlocked

```solidity
function isUnlocked() internal view returns (bool unlocked);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[NonzeroDeltaCount](https://docs.uniswap.org/contracts/v4/reference/core/libraries/NonzeroDeltaCount)

# NonzeroDeltaCount

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/NonzeroDeltaCount.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload) for the nonzero delta count. TODO: This library can be deleted when we have the transient keyword support in solidity.

## State Variables

### NONZERO_DELTA_COUNT_SLOT

```solidity
bytes32 internal constant NONZERO_DELTA_COUNT_SLOT = 0x7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b;
```



## Functions

### read

```solidity
function read() internal view returns (uint256 count);
```



### increment

```solidity
function increment() internal;
```



### decrement

Potential to underflow. Ensure checks are performed by integrating contracts to ensure this does not happen. Current usage ensures this will not happen because we call decrement with known boundaries (only up to the number of times we call increment).

```solidity
function decrement() internal;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[ParseBytes](https://docs.uniswap.org/contracts/v4/reference/core/libraries/ParseBytes)

# ParseBytes

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/ParseBytes.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.

*parseSelector also is used to parse the expected selector For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).*

## Functions

### parseSelector

```solidity
function parseSelector(bytes memory result) internal pure returns (bytes4 selector);
```



### parseFee

```solidity
function parseFee(bytes memory result) internal pure returns (uint24 lpFee);
```



### parseReturnDelta

```solidity
function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[Pool](https://docs.uniswap.org/contracts/v4/reference/core/libraries/Pool)

# Pool

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Pool.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

a library with all actions that can be performed on a pool

## Functions

### checkTicks

*Common checks for valid tick inputs.*

```solidity
function checkTicks(int24 tickLower, int24 tickUpper) private pure;
```



### initialize

```solidity
function initialize(State storage self, uint160 sqrtPriceX96, uint24 lpFee) internal returns (int24 tick);
```



### setProtocolFee

```solidity
function setProtocolFee(State storage self, uint24 protocolFee) internal;
```



### setLPFee

Only dynamic fee pools may update the lp fee.

```solidity
function setLPFee(State storage self, uint24 lpFee) internal;
```



### modifyLiquidity

Effect changes to a position in a pool

*PoolManager checks that the pool is initialized before calling*

```solidity
function modifyLiquidity(State storage self, ModifyLiquidityParams memory params)
    internal
    returns (BalanceDelta delta, BalanceDelta feeDelta);
```



**Parameters**

| Name     | Type                    | Description                                                  |
| -------- | ----------------------- | ------------------------------------------------------------ |
| `self`   | `State`                 |                                                              |
| `params` | `ModifyLiquidityParams` | the position details and the change to the position's liquidity to effect |

**Returns**

| Name       | Type           | Description                                                  |
| ---------- | -------------- | ------------------------------------------------------------ |
| `delta`    | `BalanceDelta` | the deltas of the token balances of the pool, from the liquidity change |
| `feeDelta` | `BalanceDelta` | the fees generated by the liquidity range                    |

### swap

Executes a swap against the state, and returns the amount deltas of the pool

*PoolManager checks that the pool is initialized before calling*

```solidity
function swap(State storage self, SwapParams memory params)
    internal
    returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, SwapResult memory result);
```



### donate

Donates the given amount of currency0 and currency1 to the pool

```solidity
function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta);
```



### getFeeGrowthInside

Retrieves fee growth data

```solidity
function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)
    internal
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```



**Parameters**

| Name        | Type    | Description                             |
| ----------- | ------- | --------------------------------------- |
| `self`      | `State` | The Pool state struct                   |
| `tickLower` | `int24` | The lower tick boundary of the position |
| `tickUpper` | `int24` | The upper tick boundary of the position |

**Returns**

| Name                   | Type      | Description                                                  |
| ---------------------- | --------- | ------------------------------------------------------------ |
| `feeGrowthInside0X128` | `uint256` | The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | `uint256` | The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries |

### updateTick

Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa

```solidity
function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)
    internal
    returns (bool flipped, uint128 liquidityGrossAfter);
```



**Parameters**

| Name             | Type     | Description                                                  |
| ---------------- | -------- | ------------------------------------------------------------ |
| `self`           | `State`  | The mapping containing all tick information for initialized ticks |
| `tick`           | `int24`  | The tick that will be updated                                |
| `liquidityDelta` | `int128` | A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) |
| `upper`          | `bool`   | true for updating a position's upper tick, or false for updating a position's lower tick |

**Returns**

| Name                  | Type      | Description                                                  |
| --------------------- | --------- | ------------------------------------------------------------ |
| `flipped`             | `bool`    | Whether the tick was flipped from initialized to uninitialized, or vice versa |
| `liquidityGrossAfter` | `uint128` | The total amount of liquidity for all positions that references the tick after the update |

### tickSpacingToMaxLiquidityPerTick

Derives max liquidity per tick from given tick spacing

*Executed when adding liquidity*

```solidity
function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128 result);
```



**Parameters**

| Name          | Type    | Description                                                  |
| ------------- | ------- | ------------------------------------------------------------ |
| `tickSpacing` | `int24` | The amount of required tick separation, realized in multiples of `tickSpacing` e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ... |

**Returns**

| Name     | Type      | Description                |
| -------- | --------- | -------------------------- |
| `result` | `uint128` | The max liquidity per tick |

### checkPoolInitialized

Reverts if the given pool has not been initialized

```solidity
function checkPoolInitialized(State storage self) internal view;
```



### clearTick

Clears tick data

```solidity
function clearTick(State storage self, int24 tick) internal;
```



**Parameters**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `self` | `State` | The mapping containing all initialized tick information for initialized ticks |
| `tick` | `int24` | The tick that will be cleared                                |

### crossTick

Transitions to next tick as needed by price movement

```solidity
function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)
    internal
    returns (int128 liquidityNet);
```



**Parameters**

| Name                   | Type      | Description                                                  |
| ---------------------- | --------- | ------------------------------------------------------------ |
| `self`                 | `State`   | The Pool state struct                                        |
| `tick`                 | `int24`   | The destination tick of the transition                       |
| `feeGrowthGlobal0X128` | `uint256` | The all-time global fee growth, per unit of liquidity, in token0 |
| `feeGrowthGlobal1X128` | `uint256` | The all-time global fee growth, per unit of liquidity, in token1 |

**Returns**

| Name           | Type     | Description                                                  |
| -------------- | -------- | ------------------------------------------------------------ |
| `liquidityNet` | `int128` | The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left) |

## Errors

### TicksMisordered

Thrown when tickLower is not below tickUpper

```solidity
error TicksMisordered(int24 tickLower, int24 tickUpper);
```



**Parameters**

| Name        | Type    | Description           |
| ----------- | ------- | --------------------- |
| `tickLower` | `int24` | The invalid tickLower |
| `tickUpper` | `int24` | The invalid tickUpper |

### TickLowerOutOfBounds

Thrown when tickLower is less than min tick

```solidity
error TickLowerOutOfBounds(int24 tickLower);
```



**Parameters**

| Name        | Type    | Description           |
| ----------- | ------- | --------------------- |
| `tickLower` | `int24` | The invalid tickLower |

### TickUpperOutOfBounds

Thrown when tickUpper exceeds max tick

```solidity
error TickUpperOutOfBounds(int24 tickUpper);
```



**Parameters**

| Name        | Type    | Description           |
| ----------- | ------- | --------------------- |
| `tickUpper` | `int24` | The invalid tickUpper |

### TickLiquidityOverflow

For the tick spacing, the tick has too much liquidity

```solidity
error TickLiquidityOverflow(int24 tick);
```



### PoolAlreadyInitialized

Thrown when trying to initialize an already initialized pool

```solidity
error PoolAlreadyInitialized();
```



### PoolNotInitialized

Thrown when trying to interact with a non-initialized pool

```solidity
error PoolNotInitialized();
```



### PriceLimitAlreadyExceeded

Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit

```solidity
error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);
```



**Parameters**

| Name                  | Type      | Description                                      |
| --------------------- | --------- | ------------------------------------------------ |
| `sqrtPriceCurrentX96` | `uint160` | The invalid, already surpassed sqrtPriceLimitX96 |
| `sqrtPriceLimitX96`   | `uint160` | The surpassed price limit                        |

### PriceLimitOutOfBounds

Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range

```solidity
error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);
```



**Parameters**

| Name                | Type      | Description                                  |
| ------------------- | --------- | -------------------------------------------- |
| `sqrtPriceLimitX96` | `uint160` | The invalid, out-of-bounds sqrtPriceLimitX96 |

### NoLiquidityToReceiveFees

Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers

```solidity
error NoLiquidityToReceiveFees();
```



### InvalidFeeForExactOut

Thrown when trying to swap with max lp fee and specifying an output amount

```solidity
error InvalidFeeForExactOut();
```



## Structs

### TickInfo

```solidity
struct TickInfo {
    uint128 liquidityGross;
    int128 liquidityNet;
    uint256 feeGrowthOutside0X128;
    uint256 feeGrowthOutside1X128;
}
```



### State

The state of a pool

*Note that feeGrowthGlobal can be artificially inflated For pools with a single liquidity position, actors can donate to themselves to freely inflate feeGrowthGlobal atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*

```solidity
struct State {
    Slot0 slot0;
    uint256 feeGrowthGlobal0X128;
    uint256 feeGrowthGlobal1X128;
    uint128 liquidity;
    mapping(int24 tick => TickInfo) ticks;
    mapping(int16 wordPos => uint256) tickBitmap;
    mapping(bytes32 positionKey => Position.State) positions;
}
```



### ModifyLiquidityParams

```solidity
struct ModifyLiquidityParams {
    address owner;
    int24 tickLower;
    int24 tickUpper;
    int128 liquidityDelta;
    int24 tickSpacing;
    bytes32 salt;
}
```



### ModifyLiquidityState

```solidity
struct ModifyLiquidityState {
    bool flippedLower;
    uint128 liquidityGrossAfterLower;
    bool flippedUpper;
    uint128 liquidityGrossAfterUpper;
}
```



### SwapResult

```solidity
struct SwapResult {
    uint160 sqrtPriceX96;
    int24 tick;
    uint128 liquidity;
}
```



### StepComputations

```solidity
struct StepComputations {
    uint160 sqrtPriceStartX96;
    int24 tickNext;
    bool initialized;
    uint160 sqrtPriceNextX96;
    uint256 amountIn;
    uint256 amountOut;
    uint256 feeAmount;
    uint256 feeGrowthGlobalX128;
}
```



### SwapParams

```solidity
struct SwapParams {
    int256 amountSpecified;
    int24 tickSpacing;
    bool zeroForOne;
    uint160 sqrtPriceLimitX96;
    uint24 lpFeeOverride;
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[Position](https://docs.uniswap.org/contracts/v4/reference/core/libraries/Position)

# Position

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Position.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Positions represent an owner address' liquidity between a lower and upper tick boundary

*Positions store additional state for tracking fees owed to the position*

## Functions

### get

Returns the State struct of a position, given an owner and position boundaries

```solidity
function get(mapping(bytes32 => State) storage self, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    internal
    view
    returns (State storage position);
```



**Parameters**

| Name        | Type                        | Description                                                  |
| ----------- | --------------------------- | ------------------------------------------------------------ |
| `self`      | `mapping(bytes32 => State)` | The mapping containing all user positions                    |
| `owner`     | `address`                   | The address of the position owner                            |
| `tickLower` | `int24`                     | The lower tick boundary of the position                      |
| `tickUpper` | `int24`                     | The upper tick boundary of the position                      |
| `salt`      | `bytes32`                   | A unique value to differentiate between multiple positions in the same range |

**Returns**

| Name       | Type    | Description                                            |
| ---------- | ------- | ------------------------------------------------------ |
| `position` | `State` | The position info struct of the given owners' position |

### calculatePositionKey

A helper function to calculate the position key

```solidity
function calculatePositionKey(address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    internal
    pure
    returns (bytes32 positionKey);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `owner`     | `address` | The address of the position owner                            |
| `tickLower` | `int24`   | the lower tick boundary of the position                      |
| `tickUpper` | `int24`   | the upper tick boundary of the position                      |
| `salt`      | `bytes32` | A unique value to differentiate between multiple positions in the same range, by the same owner. Passed in by the caller. |

### update

Credits accumulated fees to a user's position

```solidity
function update(State storage self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)
    internal
    returns (uint256 feesOwed0, uint256 feesOwed1);
```



**Parameters**

| Name                   | Type      | Description                                                  |
| ---------------------- | --------- | ------------------------------------------------------------ |
| `self`                 | `State`   | The individual position to update                            |
| `liquidityDelta`       | `int128`  | The change in pool liquidity as a result of the position update |
| `feeGrowthInside0X128` | `uint256` | The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | `uint256` | The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries |

**Returns**

| Name        | Type      | Description                                        |
| ----------- | --------- | -------------------------------------------------- |
| `feesOwed0` | `uint256` | The amount of currency0 owed to the position owner |
| `feesOwed1` | `uint256` | The amount of currency1 owed to the position owner |

## Errors

### CannotUpdateEmptyPosition

Cannot update a position with no liquidity

```solidity
error CannotUpdateEmptyPosition();
```



## Structs

### State

```solidity
struct State {
    uint128 liquidity;
    uint256 feeGrowthInside0LastX128;
    uint256 feeGrowthInside1LastX128;
}
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[ProtocolFeeLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/ProtocolFeeLibrary)

# ProtocolFeeLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/ProtocolFeeLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

library of functions related to protocol fees

## State Variables

### MAX_PROTOCOL_FEE

Max protocol fee is 0.1% (1000 pips)

*Increasing these values could lead to overflow in Pool.swap*

```solidity
uint16 public constant MAX_PROTOCOL_FEE = 1000;
```



### FEE_0_THRESHOLD

Thresholds used for optimized bounds checks on protocol fees

```solidity
uint24 internal constant FEE_0_THRESHOLD = 1001;
```



### FEE_1_THRESHOLD

```solidity
uint24 internal constant FEE_1_THRESHOLD = 1001 << 12;
```



### PIPS_DENOMINATOR

the protocol fee is represented in hundredths of a bip

```solidity
uint256 internal constant PIPS_DENOMINATOR = 1_000_000;
```



## Functions

### getZeroForOneFee

```solidity
function getZeroForOneFee(uint24 self) internal pure returns (uint16);
```



### getOneForZeroFee

```solidity
function getOneForZeroFee(uint24 self) internal pure returns (uint16);
```



### isValidProtocolFee

```solidity
function isValidProtocolFee(uint24 self) internal pure returns (bool valid);
```



### calculateSwapFee

*here `self` is just a single direction's protocol fee, not a packed type of 2 protocol fees*

```solidity
function calculateSwapFee(uint16 self, uint24 lpFee) internal pure returns (uint24 swapFee);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[SafeCast](https://docs.uniswap.org/contracts/v4/reference/core/libraries/SafeCast)

# SafeCast

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SafeCast.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods for safely casting between types

## Functions

### toUint160

Cast a uint256 to a uint160, revert on overflow

```solidity
function toUint160(uint256 x) internal pure returns (uint160 y);
```



**Parameters**

| Name | Type      | Description                  |
| ---- | --------- | ---------------------------- |
| `x`  | `uint256` | The uint256 to be downcasted |

**Returns**

| Name | Type      | Description                              |
| ---- | --------- | ---------------------------------------- |
| `y`  | `uint160` | The downcasted integer, now type uint160 |

### toUint128

Cast a uint256 to a uint128, revert on overflow

```solidity
function toUint128(uint256 x) internal pure returns (uint128 y);
```



**Parameters**

| Name | Type      | Description                  |
| ---- | --------- | ---------------------------- |
| `x`  | `uint256` | The uint256 to be downcasted |

**Returns**

| Name | Type      | Description                              |
| ---- | --------- | ---------------------------------------- |
| `y`  | `uint128` | The downcasted integer, now type uint128 |

### toUint128

Cast a int128 to a uint128, revert on overflow or underflow

```solidity
function toUint128(int128 x) internal pure returns (uint128 y);
```



**Parameters**

| Name | Type     | Description             |
| ---- | -------- | ----------------------- |
| `x`  | `int128` | The int128 to be casted |

**Returns**

| Name | Type      | Description                          |
| ---- | --------- | ------------------------------------ |
| `y`  | `uint128` | The casted integer, now type uint128 |

### toInt128

Cast a int256 to a int128, revert on overflow or underflow

```solidity
function toInt128(int256 x) internal pure returns (int128 y);
```



**Parameters**

| Name | Type     | Description                 |
| ---- | -------- | --------------------------- |
| `x`  | `int256` | The int256 to be downcasted |

**Returns**

| Name | Type     | Description                             |
| ---- | -------- | --------------------------------------- |
| `y`  | `int128` | The downcasted integer, now type int128 |

### toInt256

Cast a uint256 to a int256, revert on overflow

```solidity
function toInt256(uint256 x) internal pure returns (int256 y);
```



**Parameters**

| Name | Type      | Description              |
| ---- | --------- | ------------------------ |
| `x`  | `uint256` | The uint256 to be casted |

**Returns**

| Name | Type     | Description                         |
| ---- | -------- | ----------------------------------- |
| `y`  | `int256` | The casted integer, now type int256 |

### toInt128

Cast a uint256 to a int128, revert on overflow

```solidity
function toInt128(uint256 x) internal pure returns (int128);
```



**Parameters**

| Name | Type      | Description                  |
| ---- | --------- | ---------------------------- |
| `x`  | `uint256` | The uint256 to be downcasted |

**Returns**

| Name     | Type     | Description                             |
| -------- | -------- | --------------------------------------- |
| `<none>` | `int128` | The downcasted integer, now type int128 |

## Errors

### SafeCastOverflow

```solidity
error SafeCastOverflow();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[SqrtPriceMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/SqrtPriceMath)

# SqrtPriceMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SqrtPriceMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas

## Functions

### getNextSqrtPriceFromAmount0RoundingUp

Gets the next sqrt price given a delta of currency0

*Always rounds up, because in the exact output case (increasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the price less in order to not send too much output. The most precise formula for this is liquidity \* sqrtPX96 / (liquidity +- amount \* sqrtPX96), if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).*

```solidity
function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    internal
    pure
    returns (uint160);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `sqrtPX96`  | `uint160` | The starting price, i.e. before accounting for the currency0 delta |
| `liquidity` | `uint128` | The amount of usable liquidity                               |
| `amount`    | `uint256` | How much of currency0 to add or remove from virtual reserves |
| `add`       | `bool`    | Whether to add or remove the amount of currency0             |

**Returns**

| Name     | Type      | Description                                                 |
| -------- | --------- | ----------------------------------------------------------- |
| `<none>` | `uint160` | The price after adding or removing amount, depending on add |

### getNextSqrtPriceFromAmount1RoundingDown

Gets the next sqrt price given a delta of currency1

*Always rounds down, because in the exact output case (decreasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the price less in order to not send too much output. The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity*

```solidity
function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    internal
    pure
    returns (uint160);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `sqrtPX96`  | `uint160` | The starting price, i.e., before accounting for the currency1 delta |
| `liquidity` | `uint128` | The amount of usable liquidity                               |
| `amount`    | `uint256` | How much of currency1 to add, or remove, from virtual reserves |
| `add`       | `bool`    | Whether to add, or remove, the amount of currency1           |

**Returns**

| Name     | Type      | Description                                 |
| -------- | --------- | ------------------------------------------- |
| `<none>` | `uint160` | The price after adding or removing `amount` |

### getNextSqrtPriceFromInput

Gets the next sqrt price given an input amount of currency0 or currency1

*Throws if price or liquidity are 0, or if the next price is out of bounds*

```solidity
function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)
    internal
    pure
    returns (uint160);
```



**Parameters**

| Name         | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `sqrtPX96`   | `uint160` | The starting price, i.e., before accounting for the input amount |
| `liquidity`  | `uint128` | The amount of usable liquidity                               |
| `amountIn`   | `uint256` | How much of currency0, or currency1, is being swapped in     |
| `zeroForOne` | `bool`    | Whether the amount in is currency0 or currency1              |

**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `<none>` | `uint160` | uint160 The price after adding the input amount to currency0 or currency1 |

### getNextSqrtPriceFromOutput

Gets the next sqrt price given an output amount of currency0 or currency1

*Throws if price or liquidity are 0 or the next price is out of bounds*

```solidity
function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)
    internal
    pure
    returns (uint160);
```



**Parameters**

| Name         | Type      | Description                                                |
| ------------ | --------- | ---------------------------------------------------------- |
| `sqrtPX96`   | `uint160` | The starting price before accounting for the output amount |
| `liquidity`  | `uint128` | The amount of usable liquidity                             |
| `amountOut`  | `uint256` | How much of currency0, or currency1, is being swapped out  |
| `zeroForOne` | `bool`    | Whether the amount out is currency1 or currency0           |

**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `<none>` | `uint160` | uint160 The price after removing the output amount of currency0 or currency1 |

### getAmount0Delta

Gets the amount0 delta between two prices

*Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper), i.e. liquidity \* (sqrt(upper) - sqrt(lower)) / (sqrt(upper) \* sqrt(lower))*

```solidity
function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)
    internal
    pure
    returns (uint256);
```



**Parameters**

| Name            | Type      | Description                            |
| --------------- | --------- | -------------------------------------- |
| `sqrtPriceAX96` | `uint160` | A sqrt price                           |
| `sqrtPriceBX96` | `uint160` | Another sqrt price                     |
| `liquidity`     | `uint128` | The amount of usable liquidity         |
| `roundUp`       | `bool`    | Whether to round the amount up or down |

**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `<none>` | `uint256` | uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices |

### absDiff

Equivalent to: `a >= b ? a - b : b - a`

```solidity
function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res);
```



### getAmount1Delta

Gets the amount1 delta between two prices

*Calculates liquidity \* (sqrt(upper) - sqrt(lower))*

```solidity
function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)
    internal
    pure
    returns (uint256 amount1);
```



**Parameters**

| Name            | Type      | Description                             |
| --------------- | --------- | --------------------------------------- |
| `sqrtPriceAX96` | `uint160` | A sqrt price                            |
| `sqrtPriceBX96` | `uint160` | Another sqrt price                      |
| `liquidity`     | `uint128` | The amount of usable liquidity          |
| `roundUp`       | `bool`    | Whether to round the amount up, or down |

**Returns**

| Name      | Type      | Description                                                  |
| --------- | --------- | ------------------------------------------------------------ |
| `amount1` | `uint256` | Amount of currency1 required to cover a position of size liquidity between the two passed prices |

### getAmount0Delta

Equivalent to: amount1 = roundUp ? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96) : FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96); Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.

Helper that gets signed currency0 delta

```solidity
function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)
    internal
    pure
    returns (int256);
```



**Parameters**

| Name            | Type      | Description                                                  |
| --------------- | --------- | ------------------------------------------------------------ |
| `sqrtPriceAX96` | `uint160` | A sqrt price                                                 |
| `sqrtPriceBX96` | `uint160` | Another sqrt price                                           |
| `liquidity`     | `int128`  | The change in liquidity for which to compute the amount0 delta |

**Returns**

| Name     | Type     | Description                                                  |
| -------- | -------- | ------------------------------------------------------------ |
| `<none>` | `int256` | int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices |

### getAmount1Delta

Helper that gets signed currency1 delta

```solidity
function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)
    internal
    pure
    returns (int256);
```



**Parameters**

| Name            | Type      | Description                                                  |
| --------------- | --------- | ------------------------------------------------------------ |
| `sqrtPriceAX96` | `uint160` | A sqrt price                                                 |
| `sqrtPriceBX96` | `uint160` | Another sqrt price                                           |
| `liquidity`     | `int128`  | The change in liquidity for which to compute the amount1 delta |

**Returns**

| Name     | Type     | Description                                                  |
| -------- | -------- | ------------------------------------------------------------ |
| `<none>` | `int256` | int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices |

## Errors

### InvalidPriceOrLiquidity

```solidity
error InvalidPriceOrLiquidity();
```



### InvalidPrice

```solidity
error InvalidPrice();
```



### NotEnoughLiquidity

```solidity
error NotEnoughLiquidity();
```



### PriceOverflow

```solidity
error PriceOverflow();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[StateLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/StateLibrary)

# StateLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/StateLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A helper library to provide state getters that use extsload

## State Variables

### POOLS_SLOT

index of pools mapping in the PoolManager

```solidity
bytes32 public constant POOLS_SLOT = bytes32(uint256(6));
```



### FEE_GROWTH_GLOBAL0_OFFSET

index of feeGrowthGlobal0X128 in Pool.State

```solidity
uint256 public constant FEE_GROWTH_GLOBAL0_OFFSET = 1;
```



### LIQUIDITY_OFFSET

index of liquidity in Pool.State

```solidity
uint256 public constant LIQUIDITY_OFFSET = 3;
```



### TICKS_OFFSET

index of TicksInfo mapping in Pool.State: mapping(int24 => TickInfo) ticks;

```solidity
uint256 public constant TICKS_OFFSET = 4;
```



### TICK_BITMAP_OFFSET

index of tickBitmap mapping in Pool.State

```solidity
uint256 public constant TICK_BITMAP_OFFSET = 5;
```



### POSITIONS_OFFSET

index of Position.State mapping in Pool.State: mapping(bytes32 => Position.State) positions;

```solidity
uint256 public constant POSITIONS_OFFSET = 6;
```



## Functions

### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*

```solidity
function getSlot0(IPoolManager manager, PoolId poolId)
    internal
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```



**Parameters**

| Name      | Type           | Description                |
| --------- | -------------- | -------------------------- |
| `manager` | `IPoolManager` | The pool manager contract. |
| `poolId`  | `PoolId`       | The ID of the pool.        |

**Returns**

| Name           | Type      | Description                                                 |
| -------------- | --------- | ----------------------------------------------------------- |
| `sqrtPriceX96` | `uint160` | The square root of the price of the pool, in Q96 precision. |
| `tick`         | `int24`   | The current tick of the pool.                               |
| `protocolFee`  | `uint24`  | The protocol fee of the pool.                               |
| `lpFee`        | `uint24`  | The swap fee of the pool.                                   |

### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*

```solidity
function getTickInfo(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name      | Type           | Description                           |
| --------- | -------------- | ------------------------------------- |
| `manager` | `IPoolManager` | The pool manager contract.            |
| `poolId`  | `PoolId`       | The ID of the pool.                   |
| `tick`    | `int24`        | The tick to retrieve information for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross`        | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`          | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*

```solidity
function getTickLiquidity(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```



**Parameters**

| Name      | Type           | Description                         |
| --------- | -------------- | ----------------------------------- |
| `manager` | `IPoolManager` | The pool manager contract.          |
| `poolId`  | `PoolId`       | The ID of the pool.                 |
| `tick`    | `int24`        | The tick to retrieve liquidity for. |

**Returns**

| Name             | Type      | Description                                                  |
| ---------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross` | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`   | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |

### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*

```solidity
function getTickFeeGrowthOutside(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name      | Type           | Description                          |
| --------- | -------------- | ------------------------------------ |
| `manager` | `IPoolManager` | The pool manager contract.           |
| `poolId`  | `PoolId`       | The ID of the pool.                  |
| `tick`    | `int24`        | The tick to retrieve fee growth for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*

*Note that feeGrowthGlobal can be artificially inflated For pools with a single liquidity position, actors can donate to themselves to freely inflate feeGrowthGlobal atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*

```solidity
function getFeeGrowthGlobals(IPoolManager manager, PoolId poolId)
    internal
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```



**Parameters**

| Name      | Type           | Description                |
| --------- | -------------- | -------------------------- |
| `manager` | `IPoolManager` | The pool manager contract. |
| `poolId`  | `PoolId`       | The ID of the pool.        |

**Returns**

| Name               | Type      | Description                       |
| ------------------ | --------- | --------------------------------- |
| `feeGrowthGlobal0` | `uint256` | The global fee growth for token0. |
| `feeGrowthGlobal1` | `uint256` | The global fee growth for token1. |

### getLiquidity

Retrieves total the liquidity of a pool.

*Corresponds to pools[poolId].liquidity*

```solidity
function getLiquidity(IPoolManager manager, PoolId poolId) internal view returns (uint128 liquidity);
```



**Parameters**

| Name      | Type           | Description                |
| --------- | -------------- | -------------------------- |
| `manager` | `IPoolManager` | The pool manager contract. |
| `poolId`  | `PoolId`       | The ID of the pool.        |

**Returns**

| Name        | Type      | Description                |
| ----------- | --------- | -------------------------- |
| `liquidity` | `uint128` | The liquidity of the pool. |

### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*

```solidity
function getTickBitmap(IPoolManager manager, PoolId poolId, int16 tick) internal view returns (uint256 tickBitmap);
```



**Parameters**

| Name      | Type           | Description                          |
| --------- | -------------- | ------------------------------------ |
| `manager` | `IPoolManager` | The pool manager contract.           |
| `poolId`  | `PoolId`       | The ID of the pool.                  |
| `tick`    | `int16`        | The tick to retrieve the bitmap for. |

**Returns**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `tickBitmap` | `uint256` | The bitmap of the tick. |

### getPositionInfo

Retrieves the position information of a pool without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(
    IPoolManager manager,
    PoolId poolId,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    bytes32 salt
) internal view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name        | Type           | Description                                                  |
| ----------- | -------------- | ------------------------------------------------------------ |
| `manager`   | `IPoolManager` |                                                              |
| `poolId`    | `PoolId`       | The ID of the pool.                                          |
| `owner`     | `address`      | The owner of the liquidity position.                         |
| `tickLower` | `int24`        | The lower tick of the liquidity range.                       |
| `tickUpper` | `int24`        | The upper tick of the liquidity range.                       |
| `salt`      | `bytes32`      | The bytes32 randomness to further distinguish position state. |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionInfo

Retrieves the position information of a pool at a specific position ID.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(IPoolManager manager, PoolId poolId, bytes32 positionId)
    internal
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name         | Type           | Description                |
| ------------ | -------------- | -------------------------- |
| `manager`    | `IPoolManager` | The pool manager contract. |
| `poolId`     | `PoolId`       | The ID of the pool.        |
| `positionId` | `bytes32`      | The ID of the position.    |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieiving liquidity as compared to getPositionInfo*

```solidity
function getPositionLiquidity(IPoolManager manager, PoolId poolId, bytes32 positionId)
    internal
    view
    returns (uint128 liquidity);
```



**Parameters**

| Name         | Type           | Description                |
| ------------ | -------------- | -------------------------- |
| `manager`    | `IPoolManager` | The pool manager contract. |
| `poolId`     | `PoolId`       | The ID of the pool.        |
| `positionId` | `bytes32`      | The ID of the position.    |

**Returns**

| Name        | Type      | Description                    |
| ----------- | --------- | ------------------------------ |
| `liquidity` | `uint128` | The liquidity of the position. |

### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.State is cached and can become stale. This function will calculate the up to date feeGrowthInside*

```solidity
function getFeeGrowthInside(IPoolManager manager, PoolId poolId, int24 tickLower, int24 tickUpper)
    internal
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```



**Parameters**

| Name        | Type           | Description                  |
| ----------- | -------------- | ---------------------------- |
| `manager`   | `IPoolManager` | The pool manager contract.   |
| `poolId`    | `PoolId`       | The ID of the pool.          |
| `tickLower` | `int24`        | The lower tick of the range. |
| `tickUpper` | `int24`        | The upper tick of the range. |

**Returns**

| Name                   | Type      | Description                                      |
| ---------------------- | --------- | ------------------------------------------------ |
| `feeGrowthInside0X128` | `uint256` | The fee growth inside the tick range for token0. |
| `feeGrowthInside1X128` | `uint256` | The fee growth inside the tick range for token1. |

### _getPoolStateSlot

```solidity
function _getPoolStateSlot(PoolId poolId) internal pure returns (bytes32);
```



### _getTickInfoSlot

```solidity
function _getTickInfoSlot(PoolId poolId, int24 tick) internal pure returns (bytes32);
```



### _getPositionInfoSlot

```solidity
function _getPositionInfoSlot(PoolId poolId, bytes32 positionId) internal pure returns (bytes32);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[SwapMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/SwapMath)

# SwapMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SwapMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.

## State Variables

### MAX_SWAP_FEE

the swap fee is represented in hundredths of a bip, so the max is 100%

*the swap fee is the total fee on a swap, including both LP and Protocol fee*

```solidity
uint256 internal constant MAX_SWAP_FEE = 1e6;
```



## Functions

### getSqrtPriceTarget

Computes the sqrt price target for the next swap step

```solidity
function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)
    internal
    pure
    returns (uint160 sqrtPriceTargetX96);
```



**Parameters**

| Name                | Type      | Description                                                  |
| ------------------- | --------- | ------------------------------------------------------------ |
| `zeroForOne`        | `bool`    | The direction of the swap, true for currency0 to currency1, false for currency1 to currency0 |
| `sqrtPriceNextX96`  | `uint160` | The Q64.96 sqrt price for the next initialized tick          |
| `sqrtPriceLimitX96` | `uint160` | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

**Returns**

| Name                 | Type      | Description                             |
| -------------------- | --------- | --------------------------------------- |
| `sqrtPriceTargetX96` | `uint160` | The price target for the next swap step |

### computeSwapStep

Computes the result of swapping some amount in, or amount out, given the parameters of the swap

*If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.*

*feePips must be no larger than MAX_SWAP_FEE for this function. We ensure that before setting a fee using LPFeeLibrary.isValid.*

```solidity
function computeSwapStep(
    uint160 sqrtPriceCurrentX96,
    uint160 sqrtPriceTargetX96,
    uint128 liquidity,
    int256 amountRemaining,
    uint24 feePips
) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount);
```



**Parameters**

| Name                  | Type      | Description                                                  |
| --------------------- | --------- | ------------------------------------------------------------ |
| `sqrtPriceCurrentX96` | `uint160` | The current sqrt price of the pool                           |
| `sqrtPriceTargetX96`  | `uint160` | The price that cannot be exceeded, from which the direction of the swap is inferred |
| `liquidity`           | `uint128` | The usable liquidity                                         |
| `amountRemaining`     | `int256`  | How much input or output amount is remaining to be swapped in/out |
| `feePips`             | `uint24`  | The fee taken from the input amount, expressed in hundredths of a bip |

**Returns**

| Name               | Type      | Description                                                  |
| ------------------ | --------- | ------------------------------------------------------------ |
| `sqrtPriceNextX96` | `uint160` | The price after swapping the amount in/out, not to exceed the price target |
| `amountIn`         | `uint256` | The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap |
| `amountOut`        | `uint256` | The amount to be received, of either currency0 or currency1, based on the direction of the swap |
| `feeAmount`        | `uint256` | The amount of input that will be taken as a fee              |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[TickBitmap](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TickBitmap)

# TickBitmap

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TickBitmap.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Stores a packed mapping of tick index to its initialized state

*The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.*

## Functions

### compress

*round towards negative infinity*

```solidity
function compress(int24 tick, int24 tickSpacing) internal pure returns (int24 compressed);
```



### position

Computes the position in the mapping where the initialized bit for a tick lives

```solidity
function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos);
```



**Parameters**

| Name   | Type    | Description                                |
| ------ | ------- | ------------------------------------------ |
| `tick` | `int24` | The tick for which to compute the position |

**Returns**

| Name      | Type    | Description                                                  |
| --------- | ------- | ------------------------------------------------------------ |
| `wordPos` | `int16` | The key in the mapping containing the word in which the bit is stored |
| `bitPos`  | `uint8` | The bit position in the word where the flag is stored        |

### flipTick

Flips the initialized state for a given tick from false to true, or vice versa

```solidity
function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal;
```



**Parameters**

| Name          | Type                        | Description                           |
| ------------- | --------------------------- | ------------------------------------- |
| `self`        | `mapping(int16 => uint256)` | The mapping in which to flip the tick |
| `tick`        | `int24`                     | The tick to flip                      |
| `tickSpacing` | `int24`                     | The spacing between usable ticks      |

### nextInitializedTickWithinOneWord

Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick

```solidity
function nextInitializedTickWithinOneWord(
    mapping(int16 => uint256) storage self,
    int24 tick,
    int24 tickSpacing,
    bool lte
) internal view returns (int24 next, bool initialized);
```



**Parameters**

| Name          | Type                        | Description                                                  |
| ------------- | --------------------------- | ------------------------------------------------------------ |
| `self`        | `mapping(int16 => uint256)` | The mapping in which to compute the next initialized tick    |
| `tick`        | `int24`                     | The starting tick                                            |
| `tickSpacing` | `int24`                     | The spacing between usable ticks                             |
| `lte`         | `bool`                      | Whether to search for the next initialized tick to the left (less than or equal to the starting tick) |

**Returns**

| Name          | Type    | Description                                                  |
| ------------- | ------- | ------------------------------------------------------------ |
| `next`        | `int24` | The next initialized or uninitialized tick up to 256 ticks away from the current tick |
| `initialized` | `bool`  | Whether the next tick is initialized, as the function only searches within up to 256 ticks |

## Errors

### TickMisaligned

Thrown when the tick is not enumerated by the tick spacing

```solidity
error TickMisaligned(int24 tick, int24 tickSpacing);
```



**Parameters**

| Name          | Type    | Description                  |
| ------------- | ------- | ---------------------------- |
| `tick`        | `int24` | the invalid tick             |
| `tickSpacing` | `int24` | The tick spacing of the pool |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[TickMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TickMath)

# TickMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TickMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128

## State Variables

### MIN_TICK

*The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*

```solidity
int24 internal constant MIN_TICK = -887272;
```



### MAX_TICK

*The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*

```solidity
int24 internal constant MAX_TICK = 887272;
```



### MIN_TICK_SPACING

*The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]*

```solidity
int24 internal constant MIN_TICK_SPACING = 1;
```



### MAX_TICK_SPACING

*The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]*

```solidity
int24 internal constant MAX_TICK_SPACING = type(int16).max;
```



### MIN_SQRT_PRICE

*The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)*

```solidity
uint160 internal constant MIN_SQRT_PRICE = 4295128739;
```



### MAX_SQRT_PRICE

*The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)*

```solidity
uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;
```



### MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE

*A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`*

```solidity
uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =
    1461446703485210103287273052203988822378723970342 - 4295128739 - 1;
```



## Functions

### maxUsableTick

Given a tickSpacing, compute the maximum usable tick

```solidity
function maxUsableTick(int24 tickSpacing) internal pure returns (int24);
```



### minUsableTick

Given a tickSpacing, compute the minimum usable tick

```solidity
function minUsableTick(int24 tickSpacing) internal pure returns (int24);
```



### getSqrtPriceAtTick

Calculates sqrt(1.0001^tick) * 2^96

*Throws if |tick| > max tick*

```solidity
function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96);
```



**Parameters**

| Name   | Type    | Description                          |
| ------ | ------- | ------------------------------------ |
| `tick` | `int24` | The input tick for the above formula |

**Returns**

| Name           | Type      | Description                                                  |
| -------------- | --------- | ------------------------------------------------------------ |
| `sqrtPriceX96` | `uint160` | A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0) at the given tick |

### getTickAtSqrtPrice

Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96

*Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may ever return.*

```solidity
function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick);
```



**Parameters**

| Name           | Type      | Description                                              |
| -------------- | --------- | -------------------------------------------------------- |
| `sqrtPriceX96` | `uint160` | The sqrt price for which to compute the tick as a Q64.96 |

**Returns**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `tick` | `int24` | The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96 |

## Errors

### InvalidTick

Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK

```solidity
error InvalidTick(int24 tick);
```



### InvalidSqrtPrice

Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK

```solidity
error InvalidSqrtPrice(uint160 sqrtPriceX96);
```





[PreviousTickBitmap](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TickBitmap)[Nex](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TransientStat[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[TickMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TickMath)

# TickMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TickMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128

## State Variables

### MIN_TICK

*The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*

```solidity
int24 internal constant MIN_TICK = -887272;
```



### MAX_TICK

*The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*

```solidity
int24 internal constant MAX_TICK = 887272;
```



### MIN_TICK_SPACING

*The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]*

```solidity
int24 internal constant MIN_TICK_SPACING = 1;
```



### MAX_TICK_SPACING

*The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]*

```solidity
int24 internal constant MAX_TICK_SPACING = type(int16).max;
```



### MIN_SQRT_PRICE

*The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)*

```solidity
uint160 internal constant MIN_SQRT_PRICE = 4295128739;
```



### MAX_SQRT_PRICE

*The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)*

```solidity
uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;
```



### MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE

*A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`*

```solidity
uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =
    1461446703485210103287273052203988822378723970342 - 4295128739 - 1;
```



## Functions

### maxUsableTick

Given a tickSpacing, compute the maximum usable tick

```solidity
function maxUsableTick(int24 tickSpacing) internal pure returns (int24);
```



### minUsableTick

Given a tickSpacing, compute the minimum usable tick

```solidity
function minUsableTick(int24 tickSpacing) internal pure returns (int24);
```



### getSqrtPriceAtTick

Calculates sqrt(1.0001^tick) * 2^96

*Throws if |tick| > max tick*

```solidity
function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96);
```



**Parameters**

| Name   | Type    | Description                          |
| ------ | ------- | ------------------------------------ |
| `tick` | `int24` | The input tick for the above formula |

**Returns**

| Name           | Type      | Description                                                  |
| -------------- | --------- | ------------------------------------------------------------ |
| `sqrtPriceX96` | `uint160` | A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0) at the given tick |

### getTickAtSqrtPrice

Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96

*Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may ever return.*

```solidity
function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick);
```



**Parameters**

| Name           | Type      | Description                                              |
| -------------- | --------- | -------------------------------------------------------- |
| `sqrtPriceX96` | `uint160` | The sqrt price for which to compute the tick as a Q64.96 |

**Returns**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `tick` | `int24` | The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96 |

## Errors

### InvalidTick

Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK

```solidity
error InvalidTick(int24 tick);
```



### InvalidSqrtPrice

Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK

```solidity
error InvalidSqrtPrice(uint160 sqrtPriceX96);
```







[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[TransientStateLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/TransientStateLibrary)

# TransientStateLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TransientStateLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A helper library to provide state getters that use exttload

## Functions

### getSyncedReserves

returns the reserves for the synced currency

*returns 0 if the reserves are not synced or value is 0. Checks the synced currency to only return valid reserve values (after a sync and before a settle).*

```solidity
function getSyncedReserves(IPoolManager manager) internal view returns (uint256);
```



**Parameters**

| Name      | Type           | Description                |
| --------- | -------------- | -------------------------- |
| `manager` | `IPoolManager` | The pool manager contract. |

**Returns**

| Name     | Type      | Description                           |
| -------- | --------- | ------------------------------------- |
| `<none>` | `uint256` | uint256 The reserves of the currency. |

### getSyncedCurrency

```solidity
function getSyncedCurrency(IPoolManager manager) internal view returns (Currency);
```



### getNonzeroDeltaCount

Returns the number of nonzero deltas open on the PoolManager that must be zeroed out before the contract is locked

```solidity
function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256);
```



### currencyDelta

Get the current delta for a caller in the given currency

```solidity
function currencyDelta(IPoolManager manager, address target, Currency currency) internal view returns (int256);
```



**Parameters**

| Name       | Type           | Description                                |
| ---------- | -------------- | ------------------------------------------ |
| `manager`  | `IPoolManager` |                                            |
| `target`   | `address`      | The credited account address               |
| `currency` | `Currency`     | The currency for which to lookup the delta |

### isUnlocked

Returns whether the contract is unlocked or not

```solidity
function isUnlocked(IPoolManager manager) internal view returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[UnsafeMath](https://docs.uniswap.org/contracts/v4/reference/core/libraries/UnsafeMath)

# UnsafeMath

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/UnsafeMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods that perform common math functions but do not do any overflow or underflow checks

## Functions

### divRoundingUp

Returns ceil(x / y)

*division by 0 will return 0, and should be checked externally*

```solidity
function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z);
```



**Parameters**

| Name | Type      | Description  |
| ---- | --------- | ------------ |
| `x`  | `uint256` | The dividend |
| `y`  | `uint256` | The divisor  |

**Returns**

| Name | Type      | Description               |
| ---- | --------- | ------------------------- |
| `z`  | `uint256` | The quotient, ceil(x / y) |

### simpleMulDiv

Calculates floor(a×b÷denominator)

*division by 0 will return 0, and should be checked externally*

```solidity
function simpleMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```



**Parameters**

| Name          | Type      | Description      |
| ------------- | --------- | ---------------- |
| `a`           | `uint256` | The multiplicand |
| `b`           | `uint256` | The multiplier   |
| `denominator` | `uint256` | The divisor      |

**Returns**

| Name     | Type      | Description                                |
| -------- | --------- | ------------------------------------------ |
| `result` | `uint256` | The 256-bit result, floor(a×b÷denominator) |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[LiquidityAmounts](https://docs.uniswap.org/contracts/v4/reference/core/libraries/liquidity-amounts)

# LiquidityAmounts

The `LiquidityAmounts` library provides functions for computing liquidity amounts from token amounts and prices in Uniswap V4.

## Key Concept: sqrtPriceX96

`sqrtPriceX96` represents the square root of the price ratio of token1 to token0, multiplied by 2^96. This representation allows for precise price calculations across a wide range of values while using fixed-point arithmetic. It's more efficient than using ticks for intermediate calculations, as it avoids frequent conversions between prices and ticks.

## Functions

### getLiquidityForAmount0

```solidity
function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)
internal
pure
returns (uint128 liquidity)
```



Computes the amount of liquidity received for a given amount of token0 and price range.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| amount0       | uint256 | The amount of token0 being sent in           |

Returns the amount of liquidity received.

### getLiquidityForAmount1

```solidity
function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)
internal
pure
returns (uint128 liquidity)
```



Computes the amount of liquidity received for a given amount of token1 and price range.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| amount1       | uint256 | The amount of token1 being sent in           |

Returns the amount of liquidity received.

### getLiquidityForAmounts

```solidity
function getLiquidityForAmounts(
uint160 sqrtPriceX96,
uint160 sqrtPriceAX96,
uint160 sqrtPriceBX96,
uint256 amount0,
uint256 amount1
) internal pure returns (uint128 liquidity)
```



Computes the maximum amount of liquidity received for given amounts of token0 and token1, the current pool prices, and the prices at the tick boundaries.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceX96  | uint160 | Current square root price of the pool        |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| amount0       | uint256 | The amount of token0 being sent in           |
| amount1       | uint256 | The amount of token1 being sent in           |

Returns the maximum amount of liquidity received.

### getAmount0ForLiquidity

```solidity
function getAmount0ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)
internal
pure
returns (uint256 amount0)
```



Computes the amount of token0 for a given amount of liquidity and a price range.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| liquidity     | uint128 | The liquidity being valued                   |

Returns the amount of token0.

### getAmount1ForLiquidity

```solidity
function getAmount1ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)
internal
pure
returns (uint256 amount1)
```



Computes the amount of token1 for a given amount of liquidity and a price range.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| liquidity     | uint128 | The liquidity being valued                   |

Returns the amount of token1.

### getAmountsForLiquidity

```solidity
function getAmountsForLiquidity(
uint160 sqrtPriceX96,
uint160 sqrtPriceAX96,
uint160 sqrtPriceBX96,
uint128 liquidity
) internal pure returns (uint256 amount0, uint256 amount1)
```



Computes the token0 and token1 value for a given amount of liquidity, the current pool prices, and the prices at the tick boundaries.

| Param Name    | Type    | Description                                  |
| ------------- | ------- | -------------------------------------------- |
| sqrtPriceX96  | uint160 | Current square root price of the pool        |
| sqrtPriceAX96 | uint160 | Square root of price at first tick boundary  |
| sqrtPriceBX96 | uint160 | Square root of price at second tick boundary |
| liquidity     | uint128 | The liquidity being valued                   |

Returns the amount of token0 and token1.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreLibraries[TransientStateLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/transient-state-library)

# TransientStateLibrary

The `TransientStateLibrary` is a crucial component of Uniswap V4, providing utility functions for managing transient state in the PoolManager contract. This library handles operations related to reserves, delta counts, and locking state, which are essential for the efficient and secure operation of the Uniswap V4 protocol.

## Key Concepts

### Transient Storage

Uniswap V4 uses transient storage to optimize gas costs and improve efficiency. Transient storage, introduced in EIP-1153, is a way to store data that is only needed for the duration of a transaction, without persisting it to the blockchain's state trie. This is achieved using the `TLOAD` and `TSTORE` opcodes.

Key points about transient storage in Uniswap V4:

1. **PoolManager and** `exttload`: Instead of exposing custom getters for transient storage, the PoolManager implements an `exttload` (external tload) function. This function serves as an external wrapper for the `TLOAD` opcode, providing a standardized interface for accessing transient storage.
2. **TransientStateLibrary's Role:** The `TransientStateLibrary` acts as an intermediary, making calls to the PoolManager's `exttload` function to access transient storage. This abstraction simplifies the interaction with transient storage for other parts of the Uniswap V4 ecosystem.
3. **Standardization:** By channeling all transient storage access through the PoolManager's `exttload` function, Uniswap V4 ensures a consistent and controlled approach to managing transient data across the protocol.

Common operations that involve transient state include:

- Checking reserves (`getReserves`)
- Verifying currency deltas (`currencyDelta`)
- Syncing currency states (`sync`)
- Settling currency balances (`settle`)

This architecture allows Uniswap V4 to benefit from the gas efficiency of transient storage while maintaining a clean and standardized interface for interacting with this temporary data.

## Functions

### getReserves

```solidity
function getReserves(IPoolManager manager, Currency currency) internal view returns (uint256)
```



Retrieves the reserves of a specific currency from the PoolManager's transient storage.

| Param Name | Type         | Description                              |
| ---------- | ------------ | ---------------------------------------- |
| manager    | IPoolManager | The PoolManager contract instance        |
| currency   | Currency     | The currency for which to fetch reserves |

**Returns:**

- `uint256`: The amount of reserves for the specified currency

**Notes:**

- Returns `0` if the reserves are not synced
- Returns `type(uint256).max` if the reserves are synced but the value is `0`

### getNonzeroDeltaCount

```solidity
function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256)
```



Retrieves the count of nonzero deltas that must be zeroed out before the contract can be locked.

| Param Name | Type         | Description                       |
| ---------- | ------------ | --------------------------------- |
| manager    | IPoolManager | The PoolManager contract instance |

**Returns:**

- `uint256`: The number of nonzero deltas

### currencyDelta

```solidity
function currencyDelta(IPoolManager manager, address caller_, Currency currency) internal view returns (int256)
```



Fetches the current delta for a specific caller and currency from the PoolManager's transient storage.

| Param Name | Type         | Description                                |
| ---------- | ------------ | ------------------------------------------ |
| manager    | IPoolManager | The PoolManager contract instance          |
| caller_    | address      | The address of the caller                  |
| currency   | Currency     | The currency for which to lookup the delta |

**Returns:**

- `int256`: The delta value for the specified caller and currency

**Notes:**

- A **negative** delta indicates an amount that must be **paid or settled** by the caller. In other words, a negative delta means the caller owes that amount and needs to pay or settle it.
- A **positive** delta indicates an amount that is owed to the caller. This delta amount must be **taken or claimed** by the caller.

### isUnlocked

```solidity
function isUnlocked(IPoolManager manager) internal view returns (bool)
```



Checks if the PoolManager contract is currently unlocked.

| Param Name | Type         | Description                       |
| ---------- | ------------ | --------------------------------- |
| manager    | IPoolManager | The PoolManager contract instance |

**Returns:**

- `bool`: `true` if the contract is unlocked, `false` otherwise

## Usage and Importance

The `TransientStateLibrary` plays a critical role in Uniswap V4's operation:

1. **Gas Optimization:** By using transient storage, the library helps reduce gas costs associated with state changes that are only relevant within a single transaction. This is particularly important for multi-hop transactions, where internal net balances (deltas) are updated instead of making token transfers for each hop.
2. **Security:** The library provides functions to check the lock state and manage deltas, which are crucial for maintaining the integrity of the protocol during operations. The use of transient storage also allows for more efficient implementation of security measures compared to V3's reentrancy guards.
3. **Flexibility:** The library allows for efficient management of currency-specific data, such as reserves and deltas, which is essential for Uniswap V4's multi-currency pools.
4. **Encapsulation:** By centralizing these utility functions in a library, the code promotes better organization and reusability across the Uniswap V4 codebase.

## Integration with PoolManager

The `TransientStateLibrary` is designed to work closely with the `PoolManager` contract. The `TransientStateLibrary` can be easily integrated with the `PoolManager` contract using the `using` keyword for syntactic sugar. This allows you to call the library functions as if they were methods of the `IPoolManager` instance. Here's an example:

```solidity
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {TransientStateLibrary} from "v4-core/src/libraries/TransientStateLibrary.sol";

contract Example {
    using TransientStateLibrary for IPoolManager;

    function example() external {
        int256 delta = manager.currencyDelta(address(this), currency);
        // Use the delta value...
    }
}
```



In this example, the `using TransientStateLibrary for IPoolManager;` statement allows you to call `currencyDelta` directly on the `manager` instance, making your code more readable and concise.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[BalanceDelta](https://docs.uniswap.org/contracts/v4/reference/core/types/BalanceDelta)

# BalanceDelta

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0 and the lower 128 bits represent the amount1.*

```solidity
type BalanceDelta is int256;
```



## BalanceDeltaLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

Library for getting the amount0 and amount1 deltas from the BalanceDelta type

## State Variables

### ZERO_DELTA

A BalanceDelta of 0

```solidity
BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);
```



## Functions

### amount0

```solidity
function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0);
```



### amount1

```solidity
function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1);
```



# sub

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

```solidity
function sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```



# toBalanceDelta

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

```solidity
function toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta);
```



# eq

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

```solidity
function eq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```



# add

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

```solidity
function add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```



# neq

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

```solidity
function neq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[BeforeSwapDelta](https://docs.uniswap.org/contracts/v4/reference/core/types/BeforeSwapDelta)

# BeforeSwapDelta

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
type BeforeSwapDelta is int256;
```



## BeforeSwapDeltaLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol)

Library for getting the specified and unspecified deltas from the BeforeSwapDelta type

## State Variables

### ZERO_DELTA

A BeforeSwapDelta of 0

```solidity
BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);
```



## Functions

### getSpecifiedDelta

extracts int128 from the upper 128 bits of the BeforeSwapDelta returned by beforeSwap

```solidity
function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified);
```



### getUnspecifiedDelta

extracts int128 from the lower 128 bits of the BeforeSwapDelta returned by beforeSwap and afterSwap

```solidity
function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified);
```



# toBeforeSwapDelta

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol)

```solidity
function toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)
    pure
    returns (BeforeSwapDelta beforeSwapDelta);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[Currency](https://docs.uniswap.org/contracts/v4/reference/core/types/Currency)

# Currency

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
type Currency is address;
```



## CurrencyLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

*This library allows for transferring and holding native tokens and ERC20 tokens*

## State Variables

### ADDRESS_ZERO

A constant to represent the native currency

```solidity
Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));
```



## Functions

### transfer

```solidity
function transfer(Currency currency, address to, uint256 amount) internal;
```



### balanceOfSelf

```solidity
function balanceOfSelf(Currency currency) internal view returns (uint256);
```



### balanceOf

```solidity
function balanceOf(Currency currency, address owner) internal view returns (uint256);
```



### isAddressZero

```solidity
function isAddressZero(Currency currency) internal pure returns (bool);
```



### toId

```solidity
function toId(Currency currency) internal pure returns (uint256);
```



### fromId

```solidity
function fromId(uint256 id) internal pure returns (Currency);
```



## Errors

### NativeTransferFailed

Additional context for ERC-7751 wrapped error when a native transfer fails

```solidity
error NativeTransferFailed();
```



### ERC20TransferFailed

Additional context for ERC-7751 wrapped error when an ERC20 transfer fails

```solidity
error ERC20TransferFailed();
```



# greaterThanOrEqualTo

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

```solidity
function greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool);
```



# lessThan

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

```solidity
function lessThan(Currency currency, Currency other) pure returns (bool);
```



# equals

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

```solidity
function equals(Currency currency, Currency other) pure returns (bool);
```



# greaterThan

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

```solidity
function greaterThan(Currency currency, Currency other) pure returns (bool);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[PoolId](https://docs.uniswap.org/contracts/v4/reference/core/types/PoolId)

# PoolId

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolId.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
type PoolId is bytes32;
```



## PoolIdLibrary

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolId.sol)

Library for computing the ID of a pool

## Functions

### toId

Returns value equal to keccak256(abi.encode(poolKey))

```solidity
function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[PoolKey](https://docs.uniswap.org/contracts/v4/reference/core/types/PoolKey)

# PoolKey

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolKey.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Returns the key for identifying a pool

```solidity
struct PoolKey {
    Currency currency0;
    Currency currency1;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[Slot0](https://docs.uniswap.org/contracts/v4/reference/core/types/Slot0)

# Slot0

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Slot0.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*Slot0 is a packed version of solidity structure. Using the packaged version saves gas by not storing the structure fields in memory slots. Layout: 24 bits empty | 24 bits lpFee | 12 bits protocolFee 1->0 | 12 bits protocolFee 0->1 | 24 bits tick | 160 bits sqrtPriceX96 Fields in the direction from the least significant bit: The current price uint160 sqrtPriceX96; The current tick int24 tick; Protocol fee, expressed in hundredths of a bip, upper 12 bits are for 1->0, and the lower 12 are for 0->1 the maximum is 1000 - meaning the maximum protocol fee is 0.1% the protocolFee is taken from the input first, then the lpFee is taken from the remaining input uint24 protocolFee; The current LP fee of the pool. If the pool is dynamic, this does not include the dynamic fee flag. uint24 lpFee;*

```solidity
type Slot0 is bytes32;
```



# Slot0Library

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Slot0.sol)

Library for getting and setting values in the Slot0 type

## State Variables

### MASK_160_BITS

```solidity
uint160 internal constant MASK_160_BITS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
```



### MASK_24_BITS

```solidity
uint24 internal constant MASK_24_BITS = 0xFFFFFF;
```



### TICK_OFFSET

```solidity
uint8 internal constant TICK_OFFSET = 160;
```



### PROTOCOL_FEE_OFFSET

```solidity
uint8 internal constant PROTOCOL_FEE_OFFSET = 184;
```



### LP_FEE_OFFSET

```solidity
uint8 internal constant LP_FEE_OFFSET = 208;
```



## Functions

### sqrtPriceX96

```solidity
function sqrtPriceX96(Slot0 _packed) internal pure returns (uint160 _sqrtPriceX96);
```



### tick

```solidity
function tick(Slot0 _packed) internal pure returns (int24 _tick);
```



### protocolFee

```solidity
function protocolFee(Slot0 _packed) internal pure returns (uint24 _protocolFee);
```



### lpFee

```solidity
function lpFee(Slot0 _packed) internal pure returns (uint24 _lpFee);
```



### setSqrtPriceX96

```solidity
function setSqrtPriceX96(Slot0 _packed, uint160 _sqrtPriceX96) internal pure returns (Slot0 _result);
```



### setTick

```solidity
function setTick(Slot0 _packed, int24 _tick) internal pure returns (Slot0 _result);
```



### setProtocolFee

```solidity
function setProtocolFee(Slot0 _packed, uint24 _protocolFee) internal pure returns (Slot0 _result);
```



### setLpFee

```solidity
function setLpFee(Slot0 _packed, uint24 _lpFee) internal pure returns (Slot0 _result);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[BalanceDelta Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/balancedelta-guide)

# BalanceDelta Guide

`BalanceDelta` is a type used in Uniswap V4 to represent the balance changes of two tokens (token0 and token1). It tightly packs the two values in a single 256 bits. It is designed to efficiently store and manipulate these balance deltas, with the upper 128 bits representing the change in token0 (`amount0`) and the lower 128 bits representing the change in token1 (`amount1`).

## Purpose

The main purpose of `BalanceDelta` is to keep track of the net balance changes in the two tokens of a pool after various operations such as swaps, liquidity modifications, and interactions with hooks. It provides a compact and efficient way to store and update these balance deltas throughout the execution flow of the pool.

In the context of hooks, `BalanceDelta` is used to ensure that the net balance change for each token is zero after the hook's functionality is executed. This is important for maintaining the integrity of the pool's balances and ensuring that the hooks do not introduce any unexpected or unauthorized balance changes.

## Type Definition

```solidity
type BalanceDelta is int256;
```



## Using Directives

```solidity
using {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;
using BalanceDeltaLibrary for BalanceDelta global;
using SafeCast for int256;
```



These using directives enable arithmetic operations, equality comparisons, and library functions to be used directly on `BalanceDelta` values.

## Functions

### toBalanceDelta

```solidity
function toBalanceDelta(int128 amount0, int128 amount1) pure returns (BalanceDelta balanceDelta);
```



Creates a `BalanceDelta` value from two `int128` values representing `amount0` and `amount1`.

| Param Name | Type   | Description                     |
| ---------- | ------ | ------------------------------- |
| amount0    | int128 | The amount for the first token  |
| amount1    | int128 | The amount for the second token |

Returns the created `BalanceDelta` value.

### add

```solidity
function add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```



Adds two `BalanceDelta` values.

| Param Name | Type         | Description                     |
| ---------- | ------------ | ------------------------------- |
| a          | BalanceDelta | The first `BalanceDelta` value  |
| b          | BalanceDelta | The second `BalanceDelta` value |

Returns the sum of the two `BalanceDelta` values.

### sub

```solidity
function sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```



Subtracts one `BalanceDelta` value from another.

| Param Name | Type         | Description                     |
| ---------- | ------------ | ------------------------------- |
| a          | BalanceDelta | The first `BalanceDelta` value  |
| b          | BalanceDelta | The second `BalanceDelta` value |

Returns the difference of the two `BalanceDelta` values.

### eq

```solidity
function eq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```



Checks if two `BalanceDelta` values are equal.

| Param Name | Type         | Description                     |
| ---------- | ------------ | ------------------------------- |
| a          | BalanceDelta | The first `BalanceDelta` value  |
| b          | BalanceDelta | The second `BalanceDelta` value |

Returns `true` if the values are equal, `false` otherwise.

### neq

```solidity
function neq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```



Checks if two `BalanceDelta` values are not equal.

| Param Name | Type         | Description                     |
| ---------- | ------------ | ------------------------------- |
| a          | BalanceDelta | The first `BalanceDelta` value  |
| b          | BalanceDelta | The second `BalanceDelta` value |

Returns `true` if the values are not equal, `false` otherwise.

## Library Functions

### amount0

```solidity
function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0);
```



Extracts the `amount0` value from a `BalanceDelta`.

| Param Name   | Type         | Description              |
| ------------ | ------------ | ------------------------ |
| balanceDelta | BalanceDelta | The `BalanceDelta` value |

Returns the extracted `amount0` value as an `int128`.

### amount1

```solidity
function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1);
```



Extracts the `amount1` value from a `BalanceDelta`.

| Param Name   | Type         | Description              |
| ------------ | ------------ | ------------------------ |
| balanceDelta | BalanceDelta | The `BalanceDelta` value |

Returns the extracted `amount1` value as an `int128`.

## Usage in Hooks

When a hook is called during a swap or liquidity modification, it can perform custom logic and interact with the pool's balances. However, to maintain the correctness of the pool's state, the hook must ensure that any balance changes it introduces are properly accounted for and net to zero at the end of its execution. The BalanceDelta is forwarded to the `afterSwap` & `afterAddliquidity`, `afterRemoveLiquidity` hooks.

## Usage in the Pool Library

In the `Pool` library, `BalanceDelta` is used extensively to track balance changes during various operations such as swaps, liquidity modifications, and donations. The library functions `swap`, `modifyLiquidity`, and `donate` all return `BalanceDelta` values representing the net balance changes resulting from these operations.

The `Pool` library uses `BalanceDelta` to efficiently update and manage the pool's balances, ensuring that the net balance changes are accurately accounted for and that the pool remains in a consistent state.

By leveraging the compact representation and efficient arithmetic operations provided by `BalanceDelta`, the `Pool` library can perform complex balance calculations and updates in a gas-optimized manner, reducing the overall cost of executing pool-related operations.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[BeforeSwapDelta Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta-guide)

# BeforeSwapDelta Guide

`BeforeSwapDelta` is a custom type used in Uniswap V4 hook contracts to represent balance changes during swap operations. It is specifically designed to handle the return value of the `beforeSwap` hook and to be compatible with the `afterSwap` hook.

Before explaining `BeforeSwapDelta` in detail, it is worth noting that in the context of Uniswap V4 swaps:

- The **specified** token is the one for which the user specifies an exact input or output amount.
- The **unspecified** token is the counterpart in the swap, whose amount is determined by the pool's pricing mechanism.

## Purpose

The main purpose of `BeforeSwapDelta` is to efficiently encode and decode balance changes for both specified and unspecified tokens in a single 256-bit value. This compact representation allows for gas-efficient operations and seamless integration with Uniswap V4's hook system.

`BeforeSwapDelta` is essential for:

- Allowing hooks to modify swap parameters or override default swap behavior
- Allowing hooks to take fees from swaps
- Providing fine-grained control over balance adjustments resulting from swaps
- Optimizing gas usage by packing two `int128` values into a single `int256`

To summarise, `BeforeSwapDelta` is used to ensure that the net balance change for each token is zero after the hook's functionality is executed. This is important for maintaining the integrity of the pool's balances and ensuring that the hooks do not introduce any unexpected or unauthorized balance changes.

## Type Definition

```solidity
type BeforeSwapDelta is int256;
```



The `BeforeSwapDelta` type is an alias for int256, where:

- The upper 128 bits represent the delta in specified tokens
- The lower 128 bits represent the delta in unspecified tokens

## Using Directives

```solidity
using BeforeSwapDeltaLibrary for BeforeSwapDelta global;
using SafeCast for int256;
```



These using directives enable library functions to be used directly on `BeforeSwapDelta` values and provide safe casting operations for int256 values.

## Functions

### toBeforeSwapDelta

```solidity
function toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified) pure returns (BeforeSwapDelta beforeSwapDelta);
```



Creates a `BeforeSwapDelta` value from two `int128` values representing `deltaSpecified` and `deltaUnspecified`.

| Param Name       | Type   | Description                                  |
| ---------------- | ------ | -------------------------------------------- |
| deltaSpecified   | int128 | The balance change for the specified token   |
| deltaUnspecified | int128 | The balance change for the unspecified token |

Returns the created `BeforeSwapDelta` value.

This function uses bitwise operations in assembly for gas-efficient packing of the two int128 values:

```solidity
assembly ("memory-safe") {
    beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))
}
```



## Library Functions

### ZERO_DELTA

```solidity
BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);
```



A constant representing a zero delta (no balance changes). It should be used as a default return value. It is most commonly used for hooks that are *not* implementing custom accounting.

### getSpecifiedDelta

```solidity
function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified);
```



Extracts the specified token delta from a `BeforeSwapDelta` value.

| Param Name | Type            | Description                 |
| ---------- | --------------- | --------------------------- |
| delta      | BeforeSwapDelta | The `BeforeSwapDelta` value |

Returns the extracted specified token delta as an `int128`.

### getUnspecifiedDelta

```solidity
function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified);
```



Extracts the unspecified token delta from a BeforeSwapDelta value.

| Param Name | Type            | Description           |
| ---------- | --------------- | --------------------- |
| delta      | BeforeSwapDelta | The `BeforeSwapDelta` |

Returns the extracted unspecified token delta as an `int128`.

## Usage in Hooks

When a hook is called during a swap operation, it can perform custom logic and interact with the pool's balances. The `beforeSwap` hook returns a `BeforeSwapDelta` value to indicate any balance changes the *hook* introduces. For example, hooks taking fees should return the value it took as a `BeforeSwapDelta`.

## Usage in PoolManager.sol

`BeforeSwapDelta` plays a crucial role in Uniswap V4's PoolManager contract, particularly in the swap process. Here's an overview of how it's used:

## Calling the `beforeSwap` Hook

In the `swap` function of the PoolManager contract, the `beforeSwap` hook is called:

```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    // ...
    returns (BalanceDelta swapDelta)
{
    // ... (other code)

    BeforeSwapDelta beforeSwapDelta;
    {
        int256 amountToSwap;
        uint24 lpFeeOverride;
        (amountToSwap, beforeSwapDelta, lpFeeOverride) = key.hooks.beforeSwap(key, params, hookData);

        // ... (swap execution)
    }

    // ... (other code)
}
```



The `beforeSwap` hook returns a `BeforeSwapDelta` value along with other parameters.

### Interaction between `beforeSwapDelta` and `amountToSwap`

The `beforeSwapDelta` returned by the hook is used in conjunction with `params.amountSpecified` to determine the final `amountToSwap`. This allows hooks to modify the swap amount based on their custom logic. Here's a more detailed explanation of how this works:

1. The `beforeSwap` hook returns a `BeforeSwapDelta` value.
2. The `getSpecifiedDelta()` of this `BeforeSwapDelta` is used to adjust the original `params.amountSpecified`.
3. This adjustment results in the final `amountToSwap` that will be used for the actual swap operation.

Here's a simplified representation of this calculation:

```solidity
int256 amountToSwap = params.amountSpecified + beforeSwapDelta.getSpecifiedDelta();
```



In this example, the `amountToSwap` is calculated by adding the specified delta from `beforeSwapDelta` to the original `amountSpecified`. This calculation allows hooks to increase or decrease the swap amount, effectively implementing features like fees, rebates, or other custom logic.

**Detailed Example:**

Let's say a user wants to swap 100 tokens, but a hook implements a 1% fee:

1. `params.amountSpecified` would be 100
2. The hook calculates the fee as 1 token and returns a `beforeSwapDelta` with a specified delta of -1
3. `amountToSwap` is then calculated as 100 + (-1) = 99

This way, the actual amount swapped (99) reflects the fee taken by the hook, while still allowing the pool to execute the swap based on the original 100 token input from the user.

Here's how the `beforeSwap` hook might handle this:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    int128 specifiedAmount = params.amountSpecified.toInt128();
    int128 fee = specifiedAmount / 100;  // 1% fee
    int128 adjustedAmount = specifiedAmount - fee;
    
    delta = BeforeSwapDelta.from(-fee, 0);  // Fee taken from specified token
    amountIn = params.amountSpecified;  // Original amount
    
    return (amountIn, delta, 0);
}
```



After this hook executes:

- `amountIn` remains 100 (the original `params.amountSpecified`)
- `delta` represents a change of -1 in the specified token (the fee)

Then, in the PoolManager:

```solidity
int256 amountToSwap = params.amountSpecified + beforeSwapDelta.getSpecifiedDelta();
// This effectively calculates: 100 + (-1) = 99
```



As a result:

- The pool sees the full input amount of 100 tokens.
- The actual amount swapped is 99 tokens.
- The 1 token difference becomes the hook's fee.

This mechanism allows hooks to influence the swap amount while maintaining transparency about the full input amount, enabling complex custom logic within the Uniswap V4 framework.

## Relation to `afterSwap`

While `beforeSwapDelta` is primarily used in the `beforeSwap` hook, it also plays a role in the `afterSwap` process. Specifically:

- The `afterSwap` hook receives the `beforeSwapDelta` as a parameter.
- The unspecified delta (`beforeSwapDelta.getUnspecifiedDelta()`) is particularly important in the `afterSwap` context.
- This unspecified delta is accounted for in `afterSwap`'s calculations, allowing for consistent balance tracking across the entire swap process.

This mechanism ensures that:

1. Changes made by the `beforeSwap` hook are properly considered when finalizing the swap.
2. The `afterSwap` hook can make informed decisions based on the full context of the swap, including any modifications made in `beforeSwap`.
3. Complex swap logic can be implemented across multiple hook points while maintaining consistency.

For example, if a fee was taken on the specified token in `beforeSwap`, the `afterSwap` hook can use this information to ensure the overall balance changes are correct, potentially adjusting the unspecified token amount accordingly.

Developers implementing custom hooks should be aware of this relationship and ensure their `beforeSwap` and `afterSwap` implementations work together coherently, especially when implementing features like fees or rebates that affect token balances.

## Key Purposes of BeforeSwapDelta

The `BeforeSwapDelta` serves several important purposes in the Uniswap V4 swap process:

1. **Customization of Swap Behavior:** It allows hooks to modify the swap parameters or even completely override the default swap behavior.
2. **Balance Adjustment:** The delta values can be used to adjust the final balance changes resulting from the swap, giving hooks fine-grained control over the swap's outcome.
3. **Gas Optimization:** By packing two `int128` values into a single `int256`, it reduces the number of stack variables and can lead to gas savings.
4. **Cross-Hook Communication:** It provides a way for the `beforeSwap` hook to pass information to the `afterSwap` hook, enabling more complex and stateful hook logic.
5. **Hook Fees Implementation:** `BeforeSwapDelta` offers flexible options for implementing hook fees:

- Fees can be charged on either the specified or unspecified token.
- Fees can be implemented in either the `beforeSwap` or `afterSwap` hook.
- For `beforeSwap`:

1. Adjust the specified amount to account for the fee.
2. Useful for scenarios where the fee needs to be known before the swap execution.

- For `afterSwap`:

1. Generally considered best practice to charge fees on the unspecified token.
2. Allows for more accurate fee calculation based on the actual swap outcome.

- As a result, developers can implement various fee structures, such as:

1. Fixed fee amounts
2. Percentage-based fees
3. Tiered fee structures based on swap volume or other criteria

Example of a simple percentage-based fee in `beforeSwap`:

```solidity
int128 fee = specifiedAmount * FEE_PERCENTAGE / 100;
int128 adjustedAmount = specifiedAmount - fee;
delta = BeforeSwapDelta.from(-adjustedAmount, 0);
```



This flexibility in fee implementation allows developers to create sophisticated economic models within their Uniswap V4 hooks, tailoring the behavior to specific use cases while maintaining the efficiency and standardization provided by the `BeforeSwapDelta` structure.

## Perspective

It's important to note that the `BeforeSwapDelta` is from the perspective of the hook itself, not the user. For example, if a user swaps 1 USDC for 1 USDT:

- User gives 1 USDC: balance0OfUser decreases
- Hook gets 1 USDC: balance0OfHook increases

This perspective is key to correctly interpreting and manipulating the delta values within hook implementations.

## Implementation Details

The `BeforeSwapDelta` type and its associated functions use low-level assembly code for efficient bit manipulation and gas optimization:

- The `toBeforeSwapDelta` function uses bitwise operations (`shl`, `or`, `and`, `sub`) to pack two `int128` values into a single `int256`.
- The `getSpecifiedDelta` function uses the `sar` (shift arithmetic right) operation to extract the upper 128 bits.
- The `getUnspecifiedDelta` function uses the `signextend` operation to extract and sign-extend the lower 128 bits.

The `toBeforeSwapDelta` function combines the specified and unspecified deltas into a single `int256` value using bitwise operations. The `getSpecifiedDelta` and `getUnspecifiedDelta` functions extract the respective deltas using bit shifting and sign extension.

By leveraging this compact representation and efficient arithmetic operations, Uniswap V4 can perform complex balance calculations and updates in a gas-optimized manner, reducing the overall cost of executing pool-related operations.

## Implementation Considerations

When working with `BeforeSwapDelta`, especially for implementing hook fees, consider the following:

- **Fee Timing:** While fees can be implemented in either `beforeSwap` or `afterSwap`, charging fees on the unspecified token in `afterSwap` is often considered best practice. This approach can provide more accurate fee calculations based on the final swap amounts.
- **Fee Direction:** Remember that the deltas in `BeforeSwapDelta` are from the perspective of the hook. A positive delta means the hook is receiving tokens, while a negative delta means the hook is paying out tokens.
- **Consistency:** Ensure that your fee implementation is consistent across both `beforeSwap` and `afterSwap` hooks to maintain the integrity of the swap process.
- **Gas Efficiency:** When implementing fees, consider the gas costs of your calculations. The compact nature of `BeforeSwapDelta` can help in optimizing gas usage, but complex fee structures might increase gas costs.

## Comparison with BalanceDelta

`BeforeSwapDelta` shares a similar structure with `BalanceDelta`, both packing two `int128` values into a single `int256`. However, there are key differences:

- `BalanceDelta` represents amount0 and amount1.
- `BeforeSwapDelta` represents specified and unspecified amounts, which may not directly correspond to token0 and token1, depending on the swap direction.

## Best Practices

When working with `BeforeSwapDelta`, consider the following best practices:

- Always use the provided library functions (`getSpecifiedDelta` and `getUnspecifiedDelta`) to extract delta values.
- Ensure that the signs of the delta values are correct from the hook's perspective.
- Use `SafeCast` when converting between different integer types to prevent overflow/underflow errors.

## Error Handling and Edge Cases

- **Overflow/Underflow:** Ensure that the input int128 values do not exceed their range when packing into BeforeSwapDelta.
- **Zero Values:** ZERO_DELTA represents no balance changes. Be cautious when interpreting zero values in specific contexts.
- **Sign Mismatch:** Ensure that the signs of the delta values correctly represent the intended balance changes from the hook's perspective.

## Example Usage in a Hook

### Basic Example

Here's a simple example of how `BeforeSwapDelta` might be used in a `beforeSwap` hook:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    // Convert the specified amount to int128
    int128 specifiedAmount = params.amountSpecified.toInt128();
    
    // In this example, we're not modifying the unspecified amount
    int128 unspecifiedAmount = 0; // Calculated based on your custom logic
    
    // Create the BeforeSwapDelta
    delta = toBeforeSwapDelta(specifiedAmount, unspecifiedAmount);
    
    // Return the original amount as amountIn
    amountIn = params.amountSpecified;
    
    // Return 0 for lpFeeOverride as we're not changing the LP fee
    return (amountIn, delta, 0);
}
```



Let's break down what this basic hook is doing:

1. It converts the `params.amountSpecified` to `int128`, which is required for `BeforeSwapDelta`.
2. It sets the `unspecifiedAmount` to 0, which means this hook isn't modifying the counterpart token in the swap.
3. It creates a `BeforeSwapDelta` using these amounts.
4. It returns the original `amountIn`, the created `delta`, and 0 for `lpFeeOverride`.

This basic example doesn't modify the swap parameters or introduce any fees. It demonstrates the minimal structure of a `beforeSwap` hook using `BeforeSwapDelta`.

## Advanced Example: Implementing a Fee

For a more practical use case, here's an example that implements a simple fee mechanism:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    // Determine if this is a swap for token0 or token1
    bool zeroForOne = params.zeroForOne;
    
    // Convert the specified amount to int128, ensuring it's positive
    int128 specifiedAmount = params.amountSpecified.abs().toInt128();
    
    // Calculate a 0.1% fee
    int128 fee = specifiedAmount / 1000;
    
    // Adjust the specified amount based on swap direction
    int128 adjustedSpecifiedAmount;
    if (params.exactInput) {
        // For exact input, reduce the amount by the fee
        adjustedSpecifiedAmount = specifiedAmount - fee;
    } else {
        // For exact output, increase the amount by the fee
        adjustedSpecifiedAmount = specifiedAmount + fee;
    }
    
    // Create the BeforeSwapDelta
    delta = zeroForOne 
        ? BeforeSwapDelta.from(-adjustedSpecifiedAmount, 0)
        : BeforeSwapDelta.from(0, -adjustedSpecifiedAmount);
    
    // Return the original amount as amountIn
    amountIn = params.amountSpecified;
    
    // Return 0 for lpFeeOverride as we're not changing the LP fee
    return (amountIn, delta, 0);
}
```



**Let's break down what this hook is doing:**

1. **Swap Direction Determination:** The hook checks `params.zeroForOne` to determine the direction of the swap (token0 to token1 or vice versa).

2. **Amount Conversion:** It converts `params.amountSpecified` to a positive `int128`. This is necessary because `BeforeSwapDelta` works with `int128` values.

3. **Fee Calculation:** A 0.1% fee is calculated based on the specified amount.

4. Amount Adjustment:

    

   Depending on whether the swap is exact input or exact output, the specified amount is adjusted:

   - For exact input, the fee is subtracted (user provides less to the pool).
   - For exact output, the fee is added (user needs to provide more to the pool).

5. **BeforeSwapDelta Creation:** The `BeforeSwapDelta` is created using the adjusted amount. The negative sign indicates that the pool will receive these tokens from the user. The amount is placed in either the first or second parameter of `BeforeSwapDelta.from()` depending on the swap direction.

6. Return Values:

   - `amountIn` is set to the original `params.amountSpecified`. This allows the pool to account for the full amount the user is putting in or expecting out.
   - The `delta` value contains our adjusted amounts.
   - `0` is returned for `lpFeeOverride`, meaning we're not changing the default LP fee.

**What This Accomplishes:**

- This hook implements a 0.1% fee on the swaps.
- It handles both exact input and exact output swaps correctly.
- It accounts for the swap direction (token0 to token1 or vice versa).
- The fee is taken from the input amount for exact input swaps, or added to the input amount for exact output swaps.
- The pool will see the full input/output amount, but will only swap the adjusted amount (after accounting for the fee).
- The difference between the original amount and the adjusted amount effectively becomes the hook's fee.

**Considerations:**

- This example assumes the fee is always taken in the input token. In practice, you might want to design more sophisticated fee structures.
- The hook doesn't handle storage of collected fees. In a real implementation, you'd need to account for and possibly transfer these fees.
- Always ensure that your hook's logic is consistent with the overall pool behavior and doesn't introduce unexpected side effects.
- This implementation doesn't change the LP fee (lpFeeOverride is 0). In some cases, you might want to adjust this as well.

As you can see from this example, by using `BeforeSwapDelta`, hooks can implement custom logic such as fees, rebates, or other modifications to the swap parameters, allowing for highly flexible and customizable pool behavior in Uniswap V4.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[Currency Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/currency-guide)

# Currency Guide

`Currency` is a custom type that represents either native currency (ETH) or ERC20 tokens.

## Type Definition

```solidity
type Currency is address;
```



## Global Functions

### equals

```solidity
function equals(Currency currency, Currency other) pure returns (bool)
```



Checks if two `Currency` values are equal.

| Param Name | Type     | Description               |
| ---------- | -------- | ------------------------- |
| currency   | Currency | The first Currency value  |
| other      | Currency | The second Currency value |

Returns `true` if the Currency values are equal, `false` otherwise.

### greaterThan

```solidity
function greaterThan(Currency currency, Currency other) pure returns (bool)
```



Compares two `Currency` values based on their underlying addresses.

| Param Name | Type     | Description               |
| ---------- | -------- | ------------------------- |
| currency   | Currency | The first Currency value  |
| other      | Currency | The second Currency value |

Returns `true` if the underlying address of `currency` is numerically greater than the underlying address of `other`, `false` otherwise.

Note: This comparison is based on the numerical value of the addresses and does not imply any inherent ordering or value relationship between different currencies. It's primarily used for consistent ordering in data structures.

### lessThan

```solidity
function lessThan(Currency currency, Currency other) pure returns (bool)
```



Compares two `Currency` values based on their underlying addresses.

| Param Name | Type     | Description               |
| ---------- | -------- | ------------------------- |
| currency   | Currency | The first Currency value  |
| other      | Currency | The second Currency value |

Returns `true` if the underlying address of `currency` is numerically less than the underlying address of `other`, `false` otherwise.

Note: As with `greaterThan`, this comparison is based on address values and does not imply any inherent ordering or value relationship between currencies.

### greaterThanOrEqualTo

```solidity
function greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool)
```



Checks if one `Currency` value is greater than or equal to another, based on their underlying addresses.

| Param Name | Type     | Description               |
| ---------- | -------- | ------------------------- |
| currency   | Currency | The first Currency value  |
| other      | Currency | The second Currency value |

Returns `true` if the underlying address of `currency` is numerically greater than or equal to the underlying address of `other`, `false` otherwise.

## CurrencyLibrary

The `CurrencyLibrary` provides utility functions for handling both native currency (ETH) and ERC20 tokens.

### Constants

```solidity
Currency public constant NATIVE = Currency.wrap(address(0));
```



`NATIVE` represents the native currency (ETH). It is defined as a `Currency` with the underlying address of `address(0)`.

### Functions

#### transfer

```solidity
function transfer(Currency currency, address to, uint256 amount) internal
```



Transfers `amount` of `currency` to the `to` address.

| Param Name | Type     | Description                        |
| ---------- | -------- | ---------------------------------- |
| currency   | Currency | The currency to transfer           |
| to         | address  | The recipient address              |
| amount     | uint256  | The amount of currency to transfer |

#### balanceOfSelf

```solidity
function balanceOfSelf(Currency currency) internal view returns (uint256)
```



Returns the balance of `currency` held by the contract itself.

| Param Name | Type     | Description           |
| ---------- | -------- | --------------------- |
| currency   | Currency | The currency to check |

Returns the balance of the specified currency.

#### balanceOf

```solidity
function balanceOf(Currency currency, address owner) internal view returns (uint256)
```



Returns the balance of `currency` held by the `owner` address.

| Param Name | Type     | Description           |
| ---------- | -------- | --------------------- |
| currency   | Currency | The currency to check |
| owner      | address  | The address to check  |

Returns the balance of the specified currency for the given address.

#### isNative

```solidity
function isNative(Currency currency) internal pure returns (bool)
```



Checks if the given `currency` is the native currency (ETH).

| Param Name | Type     | Description           |
| ---------- | -------- | --------------------- |
| currency   | Currency | The currency to check |

Returns `true` if the currency is native (ETH), `false` otherwise.

#### toId

```solidity
function toId(Currency currency) internal pure returns (uint256)
```



Converts a `Currency` to its corresponding ID.

| Param Name | Type     | Description             |
| ---------- | -------- | ----------------------- |
| currency   | Currency | The currency to convert |

Returns the ID of the currency.

#### fromId

```solidity
function fromId(uint256 id) internal pure returns (Currency)
```



Converts an ID to its corresponding `Currency`.

| Param Name | Type    | Description       |
| ---------- | ------- | ----------------- |
| id         | uint256 | The ID to convert |

Returns the Currency corresponding to the given ID.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreTypes[PoolKey Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/poolkey-guide)

# PoolKey Guide

`PoolKey` is a crucial struct in Uniswap V4 that uniquely identifies a liquidity pool. It encapsulates all the essential parameters that define a pool's characteristics.

## Structure

```solidity
struct PoolKey {
    Currency currency0;
    Currency currency1;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
}
```



## Fields

| Field Name  | Type     | Description                                                  |
| ----------- | -------- | ------------------------------------------------------------ |
| currency0   | Currency | The lower currency of the pool, sorted numerically           |
| currency1   | Currency | The higher currency of the pool, sorted numerically          |
| fee         | uint24   | The pool swap fee, capped at 1,000,000. If the first bit is 1, the pool has a dynamic fee |
| tickSpacing | int24    | The spacing between ticks for the pool                       |
| hooks       | IHooks   | The address of the hooks contract associated with the pool   |

## Important Notes

- The `currency0` and `currency1` fields are always sorted numerically, with `currency0` being the lower value. This ensures consistent pool identification regardless of the order in which tokens are provided.
- The `fee` field can represent either a static fee or indicate that the pool uses a dynamic fee mechanism.
- The `tickSpacing` field determines the granularity of price ranges that can be used for liquidity provision.
- The `hooks` field is an interface of our Hooks that the PoolManager uses to call these functions





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[ERC6909](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909)

# ERC6909

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ERC6909.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC6909Claims)

**Author:** Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)

Minimalist and gas efficient standard ERC6909 implementation.

*Copied from the commit at 4b47a19038b798b4a33d9749d25e570443520647*

*This contract has been modified from the implementation at the above link.*

## State Variables

### isOperator

```solidity
mapping(address owner => mapping(address operator => bool isOperator)) public isOperator;
```



### balanceOf

```solidity
mapping(address owner => mapping(uint256 id => uint256 balance)) public balanceOf;
```



### allowance

```solidity
mapping(address owner => mapping(address spender => mapping(uint256 id => uint256 amount))) public allowance;
```



## Functions

### transfer

```solidity
function transfer(address receiver, uint256 id, uint256 amount) public virtual returns (bool);
```



### transferFrom

```solidity
function transferFrom(address sender, address receiver, uint256 id, uint256 amount) public virtual returns (bool);
```



### approve

```solidity
function approve(address spender, uint256 id, uint256 amount) public virtual returns (bool);
```



### setOperator

```solidity
function setOperator(address operator, bool approved) public virtual returns (bool);
```



### supportsInterface

```solidity
function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
```



### _mint

```solidity
function _mint(address receiver, uint256 id, uint256 amount) internal virtual;
```



### _burn

```solidity
function _burn(address sender, uint256 id, uint256 amount) internal virtual;
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[ERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909Claims)

# ERC6909Claims

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ERC6909](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909)

ERC6909Claims inherits ERC6909 and implements an internal burnFrom function

## Functions

### _burnFrom

Burn `amount` tokens of token type `id` from `from`.

*if sender is not `from` they must be an operator or have sufficient allowance.*

```solidity
function _burnFrom(address from, uint256 id, uint256 amount) internal;
```



**Parameters**

| Name     | Type      | Description                      |
| -------- | --------- | -------------------------------- |
| `from`   | `address` | The address to burn tokens from. |
| `id`     | `uint256` | The currency to burn.            |
| `amount` | `uint256` | The amount to burn.              |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[Extsload](https://docs.uniswap.org/contracts/v4/reference/core/Extsload)

# Extsload

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/Extsload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IExtsload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExtsload)

Enables public storage access for efficient state retrieval by external contracts. https://eips.ethereum.org/EIPS/eip-2330#rationale

## Functions

### extsload

Called by external contracts to access granular pool state

```solidity
function extsload(bytes32 slot) external view returns (bytes32);
```



**Parameters**

| Name   | Type      | Description          |
| ------ | --------- | -------------------- |
| `slot` | `bytes32` | Key of slot to sload |

**Returns**

| Name     | Type      | Description                            |
| -------- | --------- | -------------------------------------- |
| `<none>` | `bytes32` | value The value of the slot as bytes32 |

### extsload

Called by external contracts to access granular pool state

```solidity
function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory);
```



**Parameters**

| Name        | Type      | Description |
| ----------- | --------- | ----------- |
| `startSlot` | `bytes32` |             |
| `nSlots`    | `uint256` |             |

**Returns**

| Name     | Type        | Description                            |
| -------- | ----------- | -------------------------------------- |
| `<none>` | `bytes32[]` | value The value of the slot as bytes32 |

### extsload

Called by external contracts to access granular pool state

```solidity
function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory);
```



**Parameters**

| Name    | Type        | Description |
| ------- | ----------- | ----------- |
| `slots` | `bytes32[]` |             |

**Returns**

| Name     | Type        | Description                            |
| -------- | ----------- | -------------------------------------- |
| `<none>` | `bytes32[]` | value The value of the slot as bytes32 |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[Exttload](https://docs.uniswap.org/contracts/v4/reference/core/Exttload)

# Exttload

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/Exttload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IExttload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExttload)

Enables public transient storage access for efficient state retrieval by external contracts. https://eips.ethereum.org/EIPS/eip-2330#rationale

## Functions

### exttload

Called by external contracts to access transient storage of the contract

```solidity
function exttload(bytes32 slot) external view returns (bytes32);
```



**Parameters**

| Name   | Type      | Description          |
| ------ | --------- | -------------------- |
| `slot` | `bytes32` | Key of slot to tload |

**Returns**

| Name     | Type      | Description                            |
| -------- | --------- | -------------------------------------- |
| `<none>` | `bytes32` | value The value of the slot as bytes32 |

### exttload

Called by external contracts to access transient storage of the contract

```solidity
function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory);
```



**Parameters**

| Name    | Type        | Description |
| ------- | ----------- | ----------- |
| `slots` | `bytes32[]` |             |

**Returns**

| Name     | Type        | Description                            |
| -------- | ----------- | -------------------------------------- |
| `<none>` | `bytes32[]` | value The value of the slot as bytes32 |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[IPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/IPoolManager)

# IPoolManager

The `IPoolManager` interface defines the main methods for interacting with the Uniswap V4 pool manager contract. It exposes the core *swap lifecycle* operations

## ModifyLiquidityParams

Structure used to modify liquidity in a pool.

- `tickLower`: Lower tick boundary of the position
- `tickUpper`: Upper tick boundary of the position
- `liquidityDelta`: Amount of liquidity to add (positive) or remove (negative)
- `salt`: A value to set if you want unique liquidity positions at the same range

Used in the `modifyLiquidity` function to add or remove liquidity from a specific position in the pool.

## SwapParams

Structure used to execute a swap in a pool.

- `zeroForOne`: Direction of the swap (true for token0 to token1, false for token1 to token0)
- `amountSpecified`: The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)
- `sqrtPriceLimitX96`: Slippage limit represented as [Q64X96](https://uniswapv3book.com/milestone_3/more-on-fixed-point-numbers.html#:~:text=The Q64.,and 18 signify decimal places.) notation

Used in the `swap` function to define the behavior of our swap.

## Methods

### initialize

```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96)
    external
    returns (int24 tick);
```



Initialize a new pool by defining its parameters: token pair, fee tier, tick spacing, hook contract, and starting price

| Param Name   | Type    | Description                                          |
| ------------ | ------- | ---------------------------------------------------- |
| key          | PoolKey | The key defining the pool to initialize              |
| sqrtPriceX96 | uint160 | The initial sqrt price of the pool as a Q64.96 value |

Returns the initial tick value of the pool.

### unlock

```solidity
function unlock(bytes calldata data) external returns (bytes memory);
```



Provides a single entry point for all pool operations. The provided data is passed to the callback for execution.

| Param Name | Type  | Description                                                  |
| ---------- | ----- | ------------------------------------------------------------ |
| data       | bytes | Any data to pass to the callback via `IUnlockCallback(msg.sender).unlockCallback(data)` |

Returns the data returned by the callback.

### modifyLiquidity

```solidity
function modifyLiquidity(
    PoolKey memory key,
    ModifyLiquidityParams memory params,
    bytes calldata hookData
) external returns (BalanceDelta, BalanceDelta);
```



Modifies the liquidity for the given pool. Can be used to add or remove liquidity, or collect fees

> passing zero will collect fees for the given tick range

| Param Name | Type                  | Description                                                  |
| ---------- | --------------------- | ------------------------------------------------------------ |
| key        | PoolKey               | The key of the pool to modify liquidity in                   |
| params     | ModifyLiquidityParams | The parameters for modifying the liquidity position          |
| hookData   | bytes                 | Any data to pass to a hook contract on the before/add liquidity hooks |

Returns the balance delta for the caller (total of principal and fees) and the fee delta generated in the liquidity range.

### swap

```solidity
function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta);
```



Executes a swap against the given pool using the provided parameters.

| Param Name | Type       | Description                                                  |
| ---------- | ---------- | ------------------------------------------------------------ |
| key        | PoolKey    | The key of the pool to swap in                               |
| params     | SwapParams | The parameters for executing the swap                        |
| hookData   | bytes      | Any data to pass to a hook contract on the before/afterSwap hooks |

Returns the balance delta for the address initiating the swap. Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG, the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.

### donate

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (BalanceDelta);
```



Donates the specified currency amounts to the pool.

| Param Name | Type    | Description                                                  |
| ---------- | ------- | ------------------------------------------------------------ |
| key        | PoolKey | The key of the pool to donate to                             |
| amount0    | uint256 | The amount of token0 to donate                               |
| amount1    | uint256 | The amount of token1 to donate                               |
| hookData   | bytes   | Any data to pass to a hook contract on the before/afterDonate hooks |

Returns the balance delta representing the donated amounts.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[NoDelegateCall](https://docs.uniswap.org/contracts/v4/reference/core/NoDelegateCall)

# NoDelegateCall

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/NoDelegateCall.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Base contract that provides a modifier for preventing delegatecall to methods in a child contract

## State Variables

### original

*The original address of this contract*

```solidity
address private immutable original;
```



## Functions

### constructor

```solidity
constructor();
```



### checkNotDelegateCall

*Private method is used instead of inlining into modifier because modifiers are copied into each method, and the use of immutable means the address bytes are copied in every place the modifier is used.*

```solidity
function checkNotDelegateCall() private view;
```



### noDelegateCall

Prevents delegatecall into the modified method

```solidity
modifier noDelegateCall();
```



## Errors

### DelegateCallNotAllowed

```solidity
error DelegateCallNotAllowed();
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[PoolManager](https://docs.uniswap.org/contracts/v4/reference/core/PoolManager)

# PoolManager

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/PoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager), [ProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/ProtocolFees), [NoDelegateCall](https://docs.uniswap.org/contracts/v4/reference/core/NoDelegateCall), [ERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909Claims), [Extsload](https://docs.uniswap.org/contracts/v4/reference/core/Extsload), [Exttload](https://docs.uniswap.org/contracts/v4/reference/core/Exttload)

Holds the state for all pools

## State Variables

### MAX_TICK_SPACING

```solidity
int24 private constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;
```



### MIN_TICK_SPACING

```solidity
int24 private constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;
```



### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```



## Functions

### onlyWhenUnlocked

This will revert if the contract is locked

```solidity
modifier onlyWhenUnlocked();
```



### constructor

```solidity
constructor(address initialOwner) ProtocolFees(initialOwner);
```



### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*

```solidity
function unlock(bytes calldata data) external override returns (bytes memory result);
```



**Parameters**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `data` | `bytes` | Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)` |

**Returns**

| Name     | Type    | Description                                                  |
| -------- | ------- | ------------------------------------------------------------ |
| `result` | `bytes` | The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)` |

### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external noDelegateCall returns (int24 tick);
```



**Parameters**

| Name           | Type      | Description                             |
| -------------- | --------- | --------------------------------------- |
| `key`          | `PoolKey` | The pool key for the pool to initialize |
| `sqrtPriceX96` | `uint160` | The initial square root price           |

**Returns**

| Name   | Type    | Description                  |
| ------ | ------- | ---------------------------- |
| `tick` | `int24` | The initial tick of the pool |

### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*

```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```



**Parameters**

| Name       | Type                                 | Description                                               |
| ---------- | ------------------------------------ | --------------------------------------------------------- |
| `key`      | `PoolKey`                            | The pool to modify liquidity in                           |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for modifying the liquidity                |
| `hookData` | `bytes`                              | The data to pass through to the add/removeLiquidity hooks |

**Returns**

| Name          | Type           | Description                                                  |
| ------------- | -------------- | ------------------------------------------------------------ |
| `callerDelta` | `BalanceDelta` | The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable |
| `feesAccrued` | `BalanceDelta` | The balance delta of the fees generated in the liquidity range. Returned for informational purposes |

### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*

```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta swapDelta);
```



**Parameters**

| Name       | Type                      | Description                                |
| ---------- | ------------------------- | ------------------------------------------ |
| `key`      | `PoolKey`                 | The pool to swap in                        |
| `params`   | `IPoolManager.SwapParams` | The parameters for swapping                |
| `hookData` | `bytes`                   | The data to pass through to the swap hooks |

**Returns**

| Name        | Type           | Description                               |
| ----------- | -------------- | ----------------------------------------- |
| `swapDelta` | `BalanceDelta` | The balance delta of the address swapping |

### _swap

Internal swap function to execute a swap, take protocol fees on input token, and emit the swap event

```solidity
function _swap(Pool.State storage pool, PoolId id, Pool.SwapParams memory params, Currency inputCurrency)
    internal
    returns (BalanceDelta);
```



### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds. Donors should keep this in mind when designing donation mechanisms.*

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta delta);
```



**Parameters**

| Name       | Type      | Description                                  |
| ---------- | --------- | -------------------------------------------- |
| `key`      | `PoolKey` | The key of the pool to donate to             |
| `amount0`  | `uint256` | The amount of currency0 to donate            |
| `amount1`  | `uint256` | The amount of currency1 to donate            |
| `hookData` | `bytes`   | The data to pass through to the donate hooks |

**Returns**

| Name    | Type           | Description                                           |
| ------- | -------------- | ----------------------------------------------------- |
| `delta` | `BalanceDelta` | BalanceDelta The delta of the caller after the donate |

### sync

Writes the current ERC20 balance of the specified currency to transient storage This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped for native tokens because the amount to settle is determined by the sent value. However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle native funds, this function can be called with the native currency to then be able to settle the native currency*

```solidity
function sync(Currency currency) external;
```



### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*

```solidity
function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked;
```



**Parameters**

| Name       | Type       | Description                                    |
| ---------- | ---------- | ---------------------------------------------- |
| `currency` | `Currency` | The currency to withdraw from the pool manager |
| `to`       | `address`  | The address to withdraw to                     |
| `amount`   | `uint256`  | The amount of currency to withdraw             |

### settle

Called by the user to pay what is owed

```solidity
function settle() external payable onlyWhenUnlocked returns (uint256);
```



**Returns**

| Name     | Type      | Description                         |
| -------- | --------- | ----------------------------------- |
| `<none>` | `uint256` | paid The amount of currency settled |

### settleFor

Called by the user to pay on behalf of another address

```solidity
function settleFor(address recipient) external payable onlyWhenUnlocked returns (uint256);
```



**Parameters**

| Name        | Type      | Description                           |
| ----------- | --------- | ------------------------------------- |
| `recipient` | `address` | The address to credit for the payment |

**Returns**

| Name     | Type      | Description                         |
| -------- | --------- | ----------------------------------- |
| `<none>` | `uint256` | paid The amount of currency settled |

### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently. A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust. Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*

```solidity
function clear(Currency currency, uint256 amount) external onlyWhenUnlocked;
```



### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked;
```



**Parameters**

| Name     | Type      | Description                                            |
| -------- | --------- | ------------------------------------------------------ |
| `to`     | `address` | The address to mint the tokens to                      |
| `id`     | `uint256` | The currency address to mint to ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to mint                         |

### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked;
```



**Parameters**

| Name     | Type      | Description                                              |
| -------- | --------- | -------------------------------------------------------- |
| `from`   | `address` | The address to burn the tokens from                      |
| `id`     | `uint256` | The currency address to burn from ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to burn                           |

### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```



**Parameters**

| Name              | Type      | Description                                       |
| ----------------- | --------- | ------------------------------------------------- |
| `key`             | `PoolKey` | The key of the pool to update dynamic LP fees for |
| `newDynamicLPFee` | `uint24`  | The new dynamic pool LP fee                       |

### _settle

```solidity
function _settle(address recipient) internal returns (uint256 paid);
```



### _accountDelta

Adds a balance delta in a currency for a target address

```solidity
function _accountDelta(Currency currency, int128 delta, address target) internal;
```



### _accountPoolBalanceDelta

Accounts the deltas of 2 currencies to a target address

```solidity
function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta, address target) internal;
```



### _getPool

Implementation of the _getPool function defined in ProtocolFees

```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```



### _isUnlocked

Implementation of the _isUnlocked function defined in ProtocolFees

```solidity
function _isUnlocked() internal view override returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCore[ProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/ProtocolFees)

# ProtocolFees

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ProtocolFees.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IProtocolFees), Owned

Contract handling the setting and accrual of protocol fees

## State Variables

### protocolFeesAccrued

Given a currency address, returns the protocol fees accrued in that currency

```solidity
mapping(Currency currency => uint256 amount) public protocolFeesAccrued;
```



### protocolFeeController

Returns the current protocol fee controller address

```solidity
address public protocolFeeController;
```



## Functions

### constructor

```solidity
constructor(address initialOwner) Owned(initialOwner);
```



### setProtocolFeeController

Sets the protocol fee controller

```solidity
function setProtocolFeeController(address controller) external onlyOwner;
```



**Parameters**

| Name         | Type      | Description                     |
| ------------ | --------- | ------------------------------- |
| `controller` | `address` | The new protocol fee controller |

### setProtocolFee

Sets the protocol fee for the given pool

```solidity
function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
```



**Parameters**

| Name             | Type      | Description                                   |
| ---------------- | --------- | --------------------------------------------- |
| `key`            | `PoolKey` | The key of the pool to set a protocol fee for |
| `newProtocolFee` | `uint24`  | The fee to set                                |

### collectProtocolFees

Collects the protocol fees for a given recipient and currency, returning the amount collected

*This will revert if the contract is unlocked*

```solidity
function collectProtocolFees(address recipient, Currency currency, uint256 amount)
    external
    returns (uint256 amountCollected);
```



**Parameters**

| Name        | Type       | Description                              |
| ----------- | ---------- | ---------------------------------------- |
| `recipient` | `address`  | The address to receive the protocol fees |
| `currency`  | `Currency` | The currency to withdraw                 |
| `amount`    | `uint256`  | The amount of currency to withdraw       |

**Returns**

| Name              | Type      | Description                                   |
| ----------------- | --------- | --------------------------------------------- |
| `amountCollected` | `uint256` | The amount of currency successfully withdrawn |

### _isUnlocked

*abstract internal function to allow the ProtocolFees contract to access the lock*

```solidity
function _isUnlocked() internal virtual returns (bool);
```



### _getPool

*abstract internal function to allow the ProtocolFees contract to access pool state*

*this is overridden in PoolManager.sol to give access to the _pools mapping*

```solidity
function _getPool(PoolId id) internal virtual returns (Pool.State storage);
```



### _updateProtocolFees

```solidity
function _updateProtocolFees(Currency currency, uint256 amount) internal;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IERC20Minimal](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC20Minimal)

# IERC20Minimal

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/external/IERC20Minimal.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains a subset of the full ERC20 interface that is used in Uniswap V3

## Functions

### balanceOf

Returns an account's balance in the token

```solidity
function balanceOf(address account) external view returns (uint256);
```



**Parameters**

| Name      | Type      | Description                                                  |
| --------- | --------- | ------------------------------------------------------------ |
| `account` | `address` | The account for which to look up the number of tokens it has, i.e. its balance |

**Returns**

| Name     | Type      | Description                              |
| -------- | --------- | ---------------------------------------- |
| `<none>` | `uint256` | The number of tokens held by the account |

### transfer

Transfers the amount of token from the `msg.sender` to the recipient

```solidity
function transfer(address recipient, uint256 amount) external returns (bool);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `recipient` | `address` | The account that will receive the amount transferred         |
| `amount`    | `uint256` | The number of tokens to send from the sender to the recipient |

**Returns**

| Name     | Type   | Description                                                  |
| -------- | ------ | ------------------------------------------------------------ |
| `<none>` | `bool` | Returns true for a successful transfer, false for an unsuccessful transfer |

### allowance

Returns the current allowance given to a spender by an owner

```solidity
function allowance(address owner, address spender) external view returns (uint256);
```



**Parameters**

| Name      | Type      | Description                      |
| --------- | --------- | -------------------------------- |
| `owner`   | `address` | The account of the token owner   |
| `spender` | `address` | The account of the token spender |

**Returns**

| Name     | Type      | Description                                           |
| -------- | --------- | ----------------------------------------------------- |
| `<none>` | `uint256` | The current allowance granted by `owner` to `spender` |

### approve

Sets the allowance of a spender from the `msg.sender` to the value `amount`

```solidity
function approve(address spender, uint256 amount) external returns (bool);
```



**Parameters**

| Name      | Type      | Description                                                  |
| --------- | --------- | ------------------------------------------------------------ |
| `spender` | `address` | The account which will be allowed to spend a given amount of the owners tokens |
| `amount`  | `uint256` | The amount of tokens allowed to be used by `spender`         |

**Returns**

| Name     | Type   | Description                                                  |
| -------- | ------ | ------------------------------------------------------------ |
| `<none>` | `bool` | Returns true for a successful approval, false for unsuccessful |

### transferFrom

Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`

```solidity
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```



**Parameters**

| Name        | Type      | Description                                           |
| ----------- | --------- | ----------------------------------------------------- |
| `sender`    | `address` | The account from which the transfer will be initiated |
| `recipient` | `address` | The recipient of the transfer                         |
| `amount`    | `uint256` | The amount of the transfer                            |

**Returns**

| Name     | Type   | Description                                                  |
| -------- | ------ | ------------------------------------------------------------ |
| `<none>` | `bool` | Returns true for a successful transfer, false for unsuccessful |

## Events

### Transfer

Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```



**Parameters**

| Name    | Type      | Description                                                  |
| ------- | --------- | ------------------------------------------------------------ |
| `from`  | `address` | The account from which the tokens were sent, i.e. the balance decreased |
| `to`    | `address` | The account to which the tokens were sent, i.e. the balance increased |
| `value` | `uint256` | The amount of tokens that were transferred                   |

### Approval

Event emitted when the approval amount for the spender of a given owner's tokens changes.

```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```



**Parameters**

| Name      | Type      | Description                                               |
| --------- | --------- | --------------------------------------------------------- |
| `owner`   | `address` | The account that approved spending of its tokens          |
| `spender` | `address` | The account for which the spending allowance was modified |
| `value`   | `uint256` | The new allowance from the owner to the spender           |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC6909Claims)

# IERC6909Claims

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/external/IERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for claims over a contract balance, wrapped as a ERC6909

## Functions

### balanceOf

Owner balance of an id.

```solidity
function balanceOf(address owner, uint256 id) external view returns (uint256 amount);
```



**Parameters**

| Name    | Type      | Description               |
| ------- | --------- | ------------------------- |
| `owner` | `address` | The address of the owner. |
| `id`    | `uint256` | The id of the token.      |

**Returns**

| Name     | Type      | Description               |
| -------- | --------- | ------------------------- |
| `amount` | `uint256` | The balance of the token. |

### allowance

Spender allowance of an id.

```solidity
function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
```



**Parameters**

| Name      | Type      | Description                 |
| --------- | --------- | --------------------------- |
| `owner`   | `address` | The address of the owner.   |
| `spender` | `address` | The address of the spender. |
| `id`      | `uint256` | The id of the token.        |

**Returns**

| Name     | Type      | Description                 |
| -------- | --------- | --------------------------- |
| `amount` | `uint256` | The allowance of the token. |

### isOperator

Checks if a spender is approved by an owner as an operator

```solidity
function isOperator(address owner, address spender) external view returns (bool approved);
```



**Parameters**

| Name      | Type      | Description                 |
| --------- | --------- | --------------------------- |
| `owner`   | `address` | The address of the owner.   |
| `spender` | `address` | The address of the spender. |

**Returns**

| Name       | Type   | Description          |
| ---------- | ------ | -------------------- |
| `approved` | `bool` | The approval status. |

### transfer

Transfers an amount of an id from the caller to a receiver.

```solidity
function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
```



**Parameters**

| Name       | Type      | Description                  |
| ---------- | --------- | ---------------------------- |
| `receiver` | `address` | The address of the receiver. |
| `id`       | `uint256` | The id of the token.         |
| `amount`   | `uint256` | The amount of the token.     |

**Returns**

| Name     | Type   | Description                                    |
| -------- | ------ | ---------------------------------------------- |
| `<none>` | `bool` | bool True, always, unless the function reverts |

### transferFrom

Transfers an amount of an id from a sender to a receiver.

```solidity
function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
```



**Parameters**

| Name       | Type      | Description                  |
| ---------- | --------- | ---------------------------- |
| `sender`   | `address` | The address of the sender.   |
| `receiver` | `address` | The address of the receiver. |
| `id`       | `uint256` | The id of the token.         |
| `amount`   | `uint256` | The amount of the token.     |

**Returns**

| Name     | Type   | Description                                    |
| -------- | ------ | ---------------------------------------------- |
| `<none>` | `bool` | bool True, always, unless the function reverts |

### approve

Approves an amount of an id to a spender.

```solidity
function approve(address spender, uint256 id, uint256 amount) external returns (bool);
```



**Parameters**

| Name      | Type      | Description                 |
| --------- | --------- | --------------------------- |
| `spender` | `address` | The address of the spender. |
| `id`      | `uint256` | The id of the token.        |
| `amount`  | `uint256` | The amount of the token.    |

**Returns**

| Name     | Type   | Description       |
| -------- | ------ | ----------------- |
| `<none>` | `bool` | bool True, always |

### setOperator

Sets or removes an operator for the caller.

```solidity
function setOperator(address operator, bool approved) external returns (bool);
```



**Parameters**

| Name       | Type      | Description                  |
| ---------- | --------- | ---------------------------- |
| `operator` | `address` | The address of the operator. |
| `approved` | `bool`    | The approval status.         |

**Returns**

| Name     | Type   | Description       |
| -------- | ------ | ----------------- |
| `<none>` | `bool` | bool True, always |

## Events

### OperatorSet

```solidity
event OperatorSet(address indexed owner, address indexed operator, bool approved);
```



### Approval

```solidity
event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
```



### Transfer

```solidity
event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IExtsload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExtsload)

# IExtsload

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExtsload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for functions to access any storage slot in a contract

## Functions

### extsload

Called by external contracts to access granular pool state

```solidity
function extsload(bytes32 slot) external view returns (bytes32 value);
```



**Parameters**

| Name   | Type      | Description          |
| ------ | --------- | -------------------- |
| `slot` | `bytes32` | Key of slot to sload |

**Returns**

| Name    | Type      | Description                      |
| ------- | --------- | -------------------------------- |
| `value` | `bytes32` | The value of the slot as bytes32 |

### extsload

Called by external contracts to access granular pool state

```solidity
function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);
```



**Parameters**

| Name        | Type      | Description                               |
| ----------- | --------- | ----------------------------------------- |
| `startSlot` | `bytes32` | Key of slot to start sloading from        |
| `nSlots`    | `uint256` | Number of slots to load into return value |

**Returns**

| Name     | Type        | Description            |
| -------- | ----------- | ---------------------- |
| `values` | `bytes32[]` | List of loaded values. |

### extsload

Called by external contracts to access sparse pool state

```solidity
function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);
```



**Parameters**

| Name    | Type        | Description                  |
| ------- | ----------- | ---------------------------- |
| `slots` | `bytes32[]` | List of slots to SLOAD from. |

**Returns**

| Name     | Type        | Description            |
| -------- | ----------- | ---------------------- |
| `values` | `bytes32[]` | List of loaded values. |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IExttload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExttload)

# IExttload

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExttload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for functions to access any transient storage slot in a contract

## Functions

### exttload

Called by external contracts to access transient storage of the contract

```solidity
function exttload(bytes32 slot) external view returns (bytes32 value);
```



**Parameters**

| Name   | Type      | Description          |
| ------ | --------- | -------------------- |
| `slot` | `bytes32` | Key of slot to tload |

**Returns**

| Name    | Type      | Description                      |
| ------- | --------- | -------------------------------- |
| `value` | `bytes32` | The value of the slot as bytes32 |

### exttload

Called by external contracts to access sparse transient pool state

```solidity
function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);
```



**Parameters**

| Name    | Type        | Description            |
| ------- | ----------- | ---------------------- |
| `slots` | `bytes32[]` | List of slots to tload |

**Returns**

| Name     | Type        | Description           |
| -------- | ----------- | --------------------- |
| `values` | `bytes32[]` | List of loaded values |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IHooks](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks)

# IHooks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

V4 decides whether to invoke specific hooks by inspecting the least significant bits of the address that the hooks contract is deployed to. For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400 has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used. See the Hooks library for the full spec.

*Should only be callable by the v4 PoolManager.*

## Functions

### beforeInitialize

The hook called before the state of a pool is initialized

```solidity
function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);
```



**Parameters**

| Name           | Type      | Description                                    |
| -------------- | --------- | ---------------------------------------------- |
| `sender`       | `address` | The initial msg.sender for the initialize call |
| `key`          | `PoolKey` | The key for the pool being initialized         |
| `sqrtPriceX96` | `uint160` | The sqrt(price) of the pool as a Q64.96        |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### afterInitialize

The hook called after the state of a pool is initialized

```solidity
function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)
    external
    returns (bytes4);
```



**Parameters**

| Name           | Type      | Description                                               |
| -------------- | --------- | --------------------------------------------------------- |
| `sender`       | `address` | The initial msg.sender for the initialize call            |
| `key`          | `PoolKey` | The key for the pool being initialized                    |
| `sqrtPriceX96` | `uint160` | The sqrt(price) of the pool as a Q64.96                   |
| `tick`         | `int24`   | The current tick after the state of a pool is initialized |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### beforeAddLiquidity

The hook called before liquidity is added

```solidity
function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);
```



**Parameters**

| Name       | Type                                 | Description                                                  |
| ---------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`   | `address`                            | The initial msg.sender for the add liquidity call            |
| `key`      | `PoolKey`                            | The key for the pool                                         |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for adding liquidity                          |
| `hookData` | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### afterAddLiquidity

The hook called after liquidity is added

```solidity
function afterAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external returns (bytes4, BalanceDelta);
```



**Parameters**

| Name          | Type                                 | Description                                                  |
| ------------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`      | `address`                            | The initial msg.sender for the add liquidity call            |
| `key`         | `PoolKey`                            | The key for the pool                                         |
| `params`      | `IPoolManager.ModifyLiquidityParams` | The parameters for adding liquidity                          |
| `delta`       | `BalanceDelta`                       | The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta |
| `feesAccrued` | `BalanceDelta`                       | The fees accrued since the last time fees were collected from this position |
| `hookData`    | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`       | bytes4 The function selector for the hook                    |
| `<none>` | `BalanceDelta` | BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### beforeRemoveLiquidity

The hook called before liquidity is removed

```solidity
function beforeRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);
```



**Parameters**

| Name       | Type                                 | Description                                                  |
| ---------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`   | `address`                            | The initial msg.sender for the remove liquidity call         |
| `key`      | `PoolKey`                            | The key for the pool                                         |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for removing liquidity                        |
| `hookData` | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### afterRemoveLiquidity

The hook called after liquidity is removed

```solidity
function afterRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external returns (bytes4, BalanceDelta);
```



**Parameters**

| Name          | Type                                 | Description                                                  |
| ------------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`      | `address`                            | The initial msg.sender for the remove liquidity call         |
| `key`         | `PoolKey`                            | The key for the pool                                         |
| `params`      | `IPoolManager.ModifyLiquidityParams` | The parameters for removing liquidity                        |
| `delta`       | `BalanceDelta`                       | The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta |
| `feesAccrued` | `BalanceDelta`                       | The fees accrued since the last time fees were collected from this position |
| `hookData`    | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`       | bytes4 The function selector for the hook                    |
| `<none>` | `BalanceDelta` | BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### beforeSwap

The hook called before a swap

```solidity
function beforeSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata hookData
) external returns (bytes4, BeforeSwapDelta, uint24);
```



**Parameters**

| Name       | Type                      | Description                                                  |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| `sender`   | `address`                 | The initial msg.sender for the swap call                     |
| `key`      | `PoolKey`                 | The key for the pool                                         |
| `params`   | `IPoolManager.SwapParams` | The parameters for the swap                                  |
| `hookData` | `bytes`                   | Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook |

**Returns**

| Name     | Type              | Description                                                  |
| -------- | ----------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`          | bytes4 The function selector for the hook                    |
| `<none>` | `BeforeSwapDelta` | BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |
| `<none>` | `uint24`          | uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million) |

### afterSwap

The hook called after a swap

```solidity
function afterSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata hookData
) external returns (bytes4, int128);
```



**Parameters**

| Name       | Type                      | Description                                                  |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| `sender`   | `address`                 | The initial msg.sender for the swap call                     |
| `key`      | `PoolKey`                 | The key for the pool                                         |
| `params`   | `IPoolManager.SwapParams` | The parameters for the swap                                  |
| `delta`    | `BalanceDelta`            | The amount owed to the caller (positive) or owed to the pool (negative) |
| `hookData` | `bytes`                   | Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                                                  |
| -------- | -------- | ------------------------------------------------------------ |
| `<none>` | `bytes4` | bytes4 The function selector for the hook                    |
| `<none>` | `int128` | int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### beforeDonate

The hook called before donate

```solidity
function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (bytes4);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `sender`   | `address` | The initial msg.sender for the donate call                   |
| `key`      | `PoolKey` | The key for the pool                                         |
| `amount0`  | `uint256` | The amount of token0 being donated                           |
| `amount1`  | `uint256` | The amount of token1 being donated                           |
| `hookData` | `bytes`   | Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### afterDonate

The hook called after donate

```solidity
function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (bytes4);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `sender`   | `address` | The initial msg.sender for the donate call                   |
| `key`      | `PoolKey` | The key for the pool                                         |
| `amount0`  | `uint256` | The amount of token0 being donated                           |
| `amount1`  | `uint256` | The amount of token1 being donated                           |
| `hookData` | `bytes`   | Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager)

# IPoolManager

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IPoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IProtocolFees), [IERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC6909Claims), [IExtsload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExtsload), [IExttload](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IExttload)

Interface for the PoolManager

## Functions

### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*

```solidity
function unlock(bytes calldata data) external returns (bytes memory);
```



**Parameters**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `data` | `bytes` | Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)` |

**Returns**

| Name     | Type    | Description                                                  |
| -------- | ------- | ------------------------------------------------------------ |
| `<none>` | `bytes` | The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)` |

### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);
```



**Parameters**

| Name           | Type      | Description                             |
| -------------- | --------- | --------------------------------------- |
| `key`          | `PoolKey` | The pool key for the pool to initialize |
| `sqrtPriceX96` | `uint160` | The initial square root price           |

**Returns**

| Name   | Type    | Description                  |
| ------ | ------- | ---------------------------- |
| `tick` | `int24` | The initial tick of the pool |

### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*

*Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued) atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*

```solidity
function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```



**Parameters**

| Name       | Type                    | Description                                               |
| ---------- | ----------------------- | --------------------------------------------------------- |
| `key`      | `PoolKey`               | The pool to modify liquidity in                           |
| `params`   | `ModifyLiquidityParams` | The parameters for modifying the liquidity                |
| `hookData` | `bytes`                 | The data to pass through to the add/removeLiquidity hooks |

**Returns**

| Name          | Type           | Description                                                  |
| ------------- | -------------- | ------------------------------------------------------------ |
| `callerDelta` | `BalanceDelta` | The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable |
| `feesAccrued` | `BalanceDelta` | The balance delta of the fees generated in the liquidity range. Returned for informational purposes |

### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*

```solidity
function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta swapDelta);
```



**Parameters**

| Name       | Type         | Description                                |
| ---------- | ------------ | ------------------------------------------ |
| `key`      | `PoolKey`    | The pool to swap in                        |
| `params`   | `SwapParams` | The parameters for swapping                |
| `hookData` | `bytes`      | The data to pass through to the swap hooks |

**Returns**

| Name        | Type           | Description                               |
| ----------- | -------------- | ----------------------------------------- |
| `swapDelta` | `BalanceDelta` | The balance delta of the address swapping |

### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds. Donors should keep this in mind when designing donation mechanisms.*

*This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)). Read the comments in `Pool.swap()` for more information about this.*

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (BalanceDelta);
```



**Parameters**

| Name       | Type      | Description                                  |
| ---------- | --------- | -------------------------------------------- |
| `key`      | `PoolKey` | The key of the pool to donate to             |
| `amount0`  | `uint256` | The amount of currency0 to donate            |
| `amount1`  | `uint256` | The amount of currency1 to donate            |
| `hookData` | `bytes`   | The data to pass through to the donate hooks |

**Returns**

| Name     | Type           | Description                                           |
| -------- | -------------- | ----------------------------------------------------- |
| `<none>` | `BalanceDelta` | BalanceDelta The delta of the caller after the donate |

### sync

Writes the current ERC20 balance of the specified currency to transient storage This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped for native tokens because the amount to settle is determined by the sent value. However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle native funds, this function can be called with the native currency to then be able to settle the native currency*

```solidity
function sync(Currency currency) external;
```



### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*

*Can also be used as a mechanism for free flash loans*

```solidity
function take(Currency currency, address to, uint256 amount) external;
```



**Parameters**

| Name       | Type       | Description                                    |
| ---------- | ---------- | ---------------------------------------------- |
| `currency` | `Currency` | The currency to withdraw from the pool manager |
| `to`       | `address`  | The address to withdraw to                     |
| `amount`   | `uint256`  | The amount of currency to withdraw             |

### settle

Called by the user to pay what is owed

```solidity
function settle() external payable returns (uint256 paid);
```



**Returns**

| Name   | Type      | Description                    |
| ------ | --------- | ------------------------------ |
| `paid` | `uint256` | The amount of currency settled |

### settleFor

Called by the user to pay on behalf of another address

```solidity
function settleFor(address recipient) external payable returns (uint256 paid);
```



**Parameters**

| Name        | Type      | Description                           |
| ----------- | --------- | ------------------------------------- |
| `recipient` | `address` | The address to credit for the payment |

**Returns**

| Name   | Type      | Description                    |
| ------ | --------- | ------------------------------ |
| `paid` | `uint256` | The amount of currency settled |

### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently. A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust. Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*

```solidity
function clear(Currency currency, uint256 amount) external;
```



### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function mint(address to, uint256 id, uint256 amount) external;
```



**Parameters**

| Name     | Type      | Description                                            |
| -------- | --------- | ------------------------------------------------------ |
| `to`     | `address` | The address to mint the tokens to                      |
| `id`     | `uint256` | The currency address to mint to ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to mint                         |

### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function burn(address from, uint256 id, uint256 amount) external;
```



**Parameters**

| Name     | Type      | Description                                              |
| -------- | --------- | -------------------------------------------------------- |
| `from`   | `address` | The address to burn the tokens from                      |
| `id`     | `uint256` | The currency address to burn from ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to burn                           |

### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```



**Parameters**

| Name              | Type      | Description                                       |
| ----------------- | --------- | ------------------------------------------------- |
| `key`             | `PoolKey` | The key of the pool to update dynamic LP fees for |
| `newDynamicLPFee` | `uint24`  | The new dynamic pool LP fee                       |

## Events

### Initialize

Emitted when a new pool is initialized

```solidity
event Initialize(
    PoolId indexed id,
    Currency indexed currency0,
    Currency indexed currency1,
    uint24 fee,
    int24 tickSpacing,
    IHooks hooks,
    uint160 sqrtPriceX96,
    int24 tick
);
```



**Parameters**

| Name           | Type       | Description                                                  |
| -------------- | ---------- | ------------------------------------------------------------ |
| `id`           | `PoolId`   | The abi encoded hash of the pool key struct for the new pool |
| `currency0`    | `Currency` | The first currency of the pool by address sort order         |
| `currency1`    | `Currency` | The second currency of the pool by address sort order        |
| `fee`          | `uint24`   | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing`  | `int24`    | The minimum number of ticks between initialized ticks        |
| `hooks`        | `IHooks`   | The hooks contract address for the pool, or address(0) if none |
| `sqrtPriceX96` | `uint160`  | The price of the pool on initialization                      |
| `tick`         | `int24`    | The initial tick of the pool corresponding to the initialized price |

### ModifyLiquidity

Emitted when a liquidity position is modified

```solidity
event ModifyLiquidity(
    PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt
);
```



**Parameters**

| Name             | Type      | Description                                                  |
| ---------------- | --------- | ------------------------------------------------------------ |
| `id`             | `PoolId`  | The abi encoded hash of the pool key struct for the pool that was modified |
| `sender`         | `address` | The address that modified the pool                           |
| `tickLower`      | `int24`   | The lower tick of the position                               |
| `tickUpper`      | `int24`   | The upper tick of the position                               |
| `liquidityDelta` | `int256`  | The amount of liquidity that was added or removed            |
| `salt`           | `bytes32` | The extra data to make positions unique                      |

### Swap

Emitted for swaps between currency0 and currency1

```solidity
event Swap(
    PoolId indexed id,
    address indexed sender,
    int128 amount0,
    int128 amount1,
    uint160 sqrtPriceX96,
    uint128 liquidity,
    int24 tick,
    uint24 fee
);
```



**Parameters**

| Name           | Type      | Description                                                  |
| -------------- | --------- | ------------------------------------------------------------ |
| `id`           | `PoolId`  | The abi encoded hash of the pool key struct for the pool that was modified |
| `sender`       | `address` | The address that initiated the swap call, and that received the callback |
| `amount0`      | `int128`  | The delta of the currency0 balance of the pool               |
| `amount1`      | `int128`  | The delta of the currency1 balance of the pool               |
| `sqrtPriceX96` | `uint160` | The sqrt(price) of the pool after the swap, as a Q64.96      |
| `liquidity`    | `uint128` | The liquidity of the pool after the swap                     |
| `tick`         | `int24`   | The log base 1.0001 of the price of the pool after the swap  |
| `fee`          | `uint24`  | The swap fee in hundredths of a bip                          |

### Donate

Emitted for donations

```solidity
event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);
```



**Parameters**

| Name      | Type      | Description                                                  |
| --------- | --------- | ------------------------------------------------------------ |
| `id`      | `PoolId`  | The abi encoded hash of the pool key struct for the pool that was donated to |
| `sender`  | `address` | The address that initiated the donate call                   |
| `amount0` | `uint256` | The amount donated in currency0                              |
| `amount1` | `uint256` | The amount donated in currency1                              |

## Errors

### CurrencyNotSettled

Thrown when a currency is not netted out after the contract is unlocked

```solidity
error CurrencyNotSettled();
```



### PoolNotInitialized

Thrown when trying to interact with a non-initialized pool

```solidity
error PoolNotInitialized();
```



### AlreadyUnlocked

Thrown when unlock is called, but the contract is already unlocked

```solidity
error AlreadyUnlocked();
```



### ManagerLocked

Thrown when a function is called that requires the contract to be unlocked, but it is not

```solidity
error ManagerLocked();
```



### TickSpacingTooLarge

Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow

```solidity
error TickSpacingTooLarge(int24 tickSpacing);
```



### TickSpacingTooSmall

Pools must have a positive non-zero tickSpacing passed to #initialize

```solidity
error TickSpacingTooSmall(int24 tickSpacing);
```



### CurrenciesOutOfOrderOrEqual

PoolKey must have currencies where address(currency0) < address(currency1)

```solidity
error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);
```



### UnauthorizedDynamicLPFeeUpdate

Thrown when a call to updateDynamicLPFee is made by an address that is not the hook, or on a pool that does not have a dynamic swap fee.

```solidity
error UnauthorizedDynamicLPFeeUpdate();
```



### SwapAmountCannotBeZero

Thrown when trying to swap amount of 0

```solidity
error SwapAmountCannotBeZero();
```



### NonzeroNativeValue

Thrown when native currency is passed to a non native settlement

```solidity
error NonzeroNativeValue();
```



### MustClearExactPositiveDelta

Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.

```solidity
error MustClearExactPositiveDelta();
```



## Structs

### ModifyLiquidityParams

```solidity
struct ModifyLiquidityParams {
    int24 tickLower;
    int24 tickUpper;
    int256 liquidityDelta;
    bytes32 salt;
}
```



### SwapParams

```solidity
struct SwapParams {
    bool zeroForOne;
    int256 amountSpecified;
    uint160 sqrtPriceLimitX96;
}
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IProtocolFees)

# IProtocolFees

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IProtocolFees.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for all protocol-fee related functions in the pool manager

## Functions

### protocolFeesAccrued

Given a currency address, returns the protocol fees accrued in that currency

```solidity
function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);
```



**Parameters**

| Name       | Type       | Description           |
| ---------- | ---------- | --------------------- |
| `currency` | `Currency` | The currency to check |

**Returns**

| Name     | Type      | Description                                         |
| -------- | --------- | --------------------------------------------------- |
| `amount` | `uint256` | The amount of protocol fees accrued in the currency |

### setProtocolFee

Sets the protocol fee for the given pool

```solidity
function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
```



**Parameters**

| Name             | Type      | Description                                   |
| ---------------- | --------- | --------------------------------------------- |
| `key`            | `PoolKey` | The key of the pool to set a protocol fee for |
| `newProtocolFee` | `uint24`  | The fee to set                                |

### setProtocolFeeController

Sets the protocol fee controller

```solidity
function setProtocolFeeController(address controller) external;
```



**Parameters**

| Name         | Type      | Description                     |
| ------------ | --------- | ------------------------------- |
| `controller` | `address` | The new protocol fee controller |

### collectProtocolFees

Collects the protocol fees for a given recipient and currency, returning the amount collected

*This will revert if the contract is unlocked*

```solidity
function collectProtocolFees(address recipient, Currency currency, uint256 amount)
    external
    returns (uint256 amountCollected);
```



**Parameters**

| Name        | Type       | Description                              |
| ----------- | ---------- | ---------------------------------------- |
| `recipient` | `address`  | The address to receive the protocol fees |
| `currency`  | `Currency` | The currency to withdraw                 |
| `amount`    | `uint256`  | The amount of currency to withdraw       |

**Returns**

| Name              | Type      | Description                                   |
| ----------------- | --------- | --------------------------------------------- |
| `amountCollected` | `uint256` | The amount of currency successfully withdrawn |

### protocolFeeController

Returns the current protocol fee controller address

```solidity
function protocolFeeController() external view returns (address);
```



**Returns**

| Name     | Type      | Description                                         |
| -------- | --------- | --------------------------------------------------- |
| `<none>` | `address` | address The current protocol fee controller address |

## Events

### ProtocolFeeControllerUpdated

Emitted when the protocol fee controller address is updated in setProtocolFeeController.

```solidity
event ProtocolFeeControllerUpdated(address indexed protocolFeeController);
```



### ProtocolFeeUpdated

Emitted when the protocol fee is updated for a pool.

```solidity
event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
```



## Errors

### ProtocolFeeTooLarge

Thrown when protocol fee is set too high

```solidity
error ProtocolFeeTooLarge(uint24 fee);
```



### InvalidCaller

Thrown when collectProtocolFees or setProtocolFee is not called by the controller.

```solidity
error InvalidCaller();
```



### ProtocolFeeCurrencySynced

Thrown when collectProtocolFees is attempted on a token that is synced.

```solidity
error ProtocolFeeCurrencySynced();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoreinterfaces[IUnlockCallback](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IUnlockCallback)

# IUnlockCallback

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/callback/IUnlockCallback.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the callback executed when an address unlocks the pool manager

## Functions

### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked

```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory);
```



**Parameters**

| Name   | Type    | Description                                    |
| ------ | ------- | ---------------------------------------------- |
| `data` | `bytes` | The data that was passed to the call to unlock |

**Returns**

| Name     | Type    | Description                                                |
| -------- | ------- | ---------------------------------------------------------- |
| `<none>` | `bytes` | Any data that you want to be returned from the unlock call |





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[ActionsRouter](https://docs.uniswap.org/contracts/v4/reference/core/test/ActionsRouter)

# ActionsRouter

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ActionsRouter.sol)

**Inherits:** [IUnlockCallback](https://docs.uniswap.org/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md), Test

A router that handles an arbitrary input of actions. TODO: Can continue to add functions per action.

## Actions

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ActionsRouter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
enum Actions {
    SETTLE,
    SETTLE_NATIVE,
    SETTLE_FOR,
    TAKE,
    PRANK_TAKE_FROM,
    SYNC,
    MINT,
    CLEAR,
    ASSERT_BALANCE_EQUALS,
    ASSERT_RESERVES_EQUALS,
    ASSERT_DELTA_EQUALS,
    ASSERT_NONZERO_DELTA_COUNT_EQUALS,
    TRANSFER_FROM,
    COLLECT_PROTOCOL_FEES
}
```



## State Variables

### manager

```solidity
IPoolManager manager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory);
```



### executeActions

```solidity
function executeActions(Actions[] memory actions, bytes[] memory params) external payable;
```



### _settle

```solidity
function _settle() internal;
```



### _settleNative

```solidity
function _settleNative(bytes memory params) internal;
```



### _settleFor

```solidity
function _settleFor(bytes memory params) internal;
```



### _take

```solidity
function _take(bytes memory params) internal;
```



### _prankTakeFrom

```solidity
function _prankTakeFrom(bytes memory params) internal;
```



### _sync

```solidity
function _sync(bytes memory params) internal;
```



### _mint

```solidity
function _mint(bytes memory params) internal;
```



### _clear

```solidity
function _clear(bytes memory params) internal;
```



### _assertBalanceEquals

```solidity
function _assertBalanceEquals(bytes memory params) internal view;
```



### _assertReservesEquals

```solidity
function _assertReservesEquals(bytes memory params) internal view;
```



### _assertDeltaEquals

```solidity
function _assertDeltaEquals(bytes memory params) internal view;
```



### _assertNonzeroDeltaCountEquals

```solidity
function _assertNonzeroDeltaCountEquals(bytes memory params) internal view;
```



### _transferFrom

```solidity
function _transferFrom(bytes memory params) internal;
```



### _collectProtocolFees

```solidity
function _collectProtocolFees(bytes memory params) internal;
```



## Errors

### ActionNotSupported

```solidity
error ActionNotSupported();
```



### CheckParameters

```solidity
error CheckParameters();
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

# BaseTestHooks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/BaseTestHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IHooks](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks)

## Functions

### beforeInitialize

```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external virtual returns (bytes4);
```



### afterInitialize

```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external virtual returns (bytes4);
```



### beforeAddLiquidity

```solidity
function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external virtual returns (bytes4, BalanceDelta);
```



### beforeRemoveLiquidity

```solidity
function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4);
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external virtual returns (bytes4, BalanceDelta);
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    external
    virtual
    returns (bytes4, int128);
```



### beforeDonate

```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) external virtual returns (bytes4);
```



### afterDonate

```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) external virtual returns (bytes4);
```



## Errors

### HookNotImplemented

```solidity
error HookNotImplemented();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[CurrencyTest](https://docs.uniswap.org/contracts/v4/reference/core/test/CurrencyTest)

# CurrencyTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/CurrencyTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### transfer

```solidity
function transfer(Currency currency, address to, uint256 amount) external;
```



### balanceOfSelf

```solidity
function balanceOfSelf(Currency currency) external view returns (uint256);
```



### balanceOf

```solidity
function balanceOf(Currency currency, address owner) external view returns (uint256);
```



### isAddressZero

```solidity
function isAddressZero(Currency currency) external pure returns (bool);
```



### toId

```solidity
function toId(Currency currency) external pure returns (uint256);
```



### fromId

```solidity
function fromId(uint256 id) external pure returns (Currency);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[CustomCurveHook](https://docs.uniswap.org/contracts/v4/reference/core/test/CustomCurveHook)

# CustomCurveHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/CustomCurveHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

## State Variables

### manager

```solidity
IPoolManager immutable manager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### onlyPoolManager

```solidity
modifier onlyPoolManager();
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external view override onlyPoolManager returns (bytes4, BalanceDelta);
```



### _getInputOutputAndAmount

```solidity
function _getInputOutputAndAmount(PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    pure
    returns (Currency input, Currency output, uint256 amount);
```



## Errors

### AddLiquidityDirectToHook

```solidity
error AddLiquidityDirectToHook();
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[DeltaReturningHook](https://docs.uniswap.org/contracts/v4/reference/core/test/DeltaReturningHook)

# DeltaReturningHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DeltaReturningHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

## State Variables

### manager

```solidity
IPoolManager immutable manager;
```



### deltaSpecified

```solidity
int128 deltaSpecified;
```



### deltaUnspecifiedBeforeSwap

```solidity
int128 deltaUnspecifiedBeforeSwap;
```



### deltaUnspecifiedAfterSwap

```solidity
int128 deltaUnspecifiedAfterSwap;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### onlyPoolManager

```solidity
modifier onlyPoolManager();
```



### setDeltaSpecified

```solidity
function setDeltaSpecified(int128 delta) external;
```



### setDeltaUnspecifiedBeforeSwap

```solidity
function setDeltaUnspecifiedBeforeSwap(int128 delta) external;
```



### setDeltaUnspecifiedAfterSwap

```solidity
function setDeltaUnspecifiedAfterSwap(int128 delta) external;
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

```solidity
function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, int128);
```



### _sortCurrencies

```solidity
function _sortCurrencies(PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    pure
    returns (Currency specified, Currency unspecified);
```



### _settleOrTake

```solidity
function _settleOrTake(Currency currency, int128 delta) internal;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[DynamicFeesTestHook](https://docs.uniswap.org/contracts/v4/reference/core/test/DynamicFeesTestHook)

# DynamicFeesTestHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DynamicFeesTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

## State Variables

### fee

```solidity
uint24 internal fee;
```



### manager

```solidity
IPoolManager manager;
```



## Functions

### setManager

```solidity
function setManager(IPoolManager _manager) external;
```



### setFee

```solidity
function setFee(uint24 _fee) external;
```



### afterInitialize

```solidity
function afterInitialize(address, PoolKey calldata key, uint160, int24) external override returns (bytes4);
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```



### forcePoolFeeUpdate

```solidity
function forcePoolFeeUpdate(PoolKey calldata _key, uint24 _fee) external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[DynamicReturnFeeTestHook](https://docs.uniswap.org/contracts/v4/reference/core/test/DynamicReturnFeeTestHook)

# DynamicReturnFeeTestHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DynamicReturnFeeTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

## State Variables

### fee

```solidity
uint24 internal fee;
```



### manager

```solidity
IPoolManager manager;
```



## Functions

### setManager

```solidity
function setManager(IPoolManager _manager) external;
```



### setFee

```solidity
function setFee(uint24 _fee) external;
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    view
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```



### forcePoolFeeUpdate

```solidity
function forcePoolFeeUpdate(PoolKey calldata _key, uint24 _fee) external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[EmptyRevertContract](https://docs.uniswap.org/contracts/v4/reference/core/test/EmptyRevertContract)

# EmptyRevertContract

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/EmptyRevertContract.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### fallback

```solidity
fallback() external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[EmptyTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/EmptyTestHooks)

# EmptyTestHooks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/EmptyTestHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IHooks](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks)

## Functions

### constructor

```solidity
constructor();
```



### beforeInitialize

```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external pure override returns (bytes4);
```



### afterInitialize

```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external pure override returns (bytes4);
```



### beforeAddLiquidity

```solidity
function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external pure override returns (bytes4, BalanceDelta);
```



### beforeRemoveLiquidity

```solidity
function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external pure override returns (bytes4, BalanceDelta);
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    external
    pure
    override
    returns (bytes4, int128);
```



### beforeDonate

```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```



### afterDonate

```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[FeeTakingHook](https://docs.uniswap.org/contracts/v4/reference/core/test/FeeTakingHook)

# FeeTakingHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/FeeTakingHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

## State Variables

### manager

```solidity
IPoolManager immutable manager;
```



### LIQUIDITY_FEE

```solidity
uint128 public constant LIQUIDITY_FEE = 543;
```



### SWAP_FEE_BIPS

```solidity
uint128 public constant SWAP_FEE_BIPS = 123;
```



### TOTAL_BIPS

```solidity
uint128 public constant TOTAL_BIPS = 10000;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### onlyPoolManager

```solidity
modifier onlyPoolManager();
```



### afterSwap

```solidity
function afterSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, int128);
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta delta,
    BalanceDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta delta,
    BalanceDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[Fuzzers](https://docs.uniswap.org/contracts/v4/reference/core/test/Fuzzers)

# Fuzzers

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/Fuzzers.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** StdUtils

## State Variables

### _vm

```solidity
Vm internal constant _vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
```



## Functions

### boundLiquidityDelta

```solidity
function boundLiquidityDelta(PoolKey memory key, int256 liquidityDeltaUnbounded, int256 liquidityMaxByAmount)
    internal
    pure
    returns (int256);
```



### boundLiquidityDeltaTightly

```solidity
function boundLiquidityDeltaTightly(
    PoolKey memory key,
    int256 liquidityDeltaUnbounded,
    int256 liquidityMaxByAmount,
    uint256 maxPositions
) internal pure returns (int256);
```



### getLiquidityDeltaFromAmounts

```solidity
function getLiquidityDeltaFromAmounts(int24 tickLower, int24 tickUpper, uint160 sqrtPriceX96)
    internal
    pure
    returns (int256);
```



### boundTicks

```solidity
function boundTicks(int24 tickLower, int24 tickUpper, int24 tickSpacing) internal pure returns (int24, int24);
```



### boundTicks

```solidity
function boundTicks(PoolKey memory key, int24 tickLower, int24 tickUpper) internal pure returns (int24, int24);
```



### createRandomSqrtPriceX96

```solidity
function createRandomSqrtPriceX96(int24 tickSpacing, int256 seed) internal pure returns (uint160);
```



### createFuzzyLiquidityParams

*Obtain fuzzed and bounded parameters for creating liquidity*

```solidity
function createFuzzyLiquidityParams(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96
) internal pure returns (IPoolManager.ModifyLiquidityParams memory result);
```



**Parameters**

| Name           | Type                                 | Description                                                  |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| `key`          | `PoolKey`                            | The pool key                                                 |
| `params`       | `IPoolManager.ModifyLiquidityParams` | IPoolManager.ModifyLiquidityParams Note that these parameters are unbounded |
| `sqrtPriceX96` | `uint160`                            | The current sqrt price                                       |

### createFuzzyLiquidityParamsWithTightBound

```solidity
function createFuzzyLiquidityParamsWithTightBound(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    uint256 maxPositions
) internal pure returns (IPoolManager.ModifyLiquidityParams memory result);
```



### createFuzzyLiquidity

```solidity
function createFuzzyLiquidity(
    PoolModifyLiquidityTest modifyLiquidityRouter,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    bytes memory hookData
) internal returns (IPoolManager.ModifyLiquidityParams memory result, BalanceDelta delta);
```



### createFuzzyLiquidityWithTightBound

```solidity
function createFuzzyLiquidityWithTightBound(
    PoolModifyLiquidityTest modifyLiquidityRouter,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    bytes memory hookData,
    uint256 maxPositions
) internal returns (IPoolManager.ModifyLiquidityParams memory result, BalanceDelta delta);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[HooksTest](https://docs.uniswap.org/contracts/v4/reference/core/test/HooksTest)

# HooksTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/HooksTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### validateHookPermissions

```solidity
function validateHookPermissions(address hookAddress, Hooks.Permissions calldata params) external pure;
```



### isValidHookAddress

```solidity
function isValidHookAddress(address hookAddress, uint24 fee) external pure returns (bool);
```



### shouldCallBeforeInitialize

```solidity
function shouldCallBeforeInitialize(address hookAddress) external pure returns (bool);
```



### shouldCallAfterInitialize

```solidity
function shouldCallAfterInitialize(address hookAddress) external pure returns (bool);
```



### shouldCallBeforeSwap

```solidity
function shouldCallBeforeSwap(address hookAddress) external pure returns (bool);
```



### shouldCallAfterSwap

```solidity
function shouldCallAfterSwap(address hookAddress) external pure returns (bool);
```



### shouldCallBeforeAddLiquidity

```solidity
function shouldCallBeforeAddLiquidity(address hookAddress) external pure returns (bool);
```



### shouldCallAfterAddLiquidity

```solidity
function shouldCallAfterAddLiquidity(address hookAddress) external pure returns (bool);
```



### shouldCallBeforeRemoveLiquidity

```solidity
function shouldCallBeforeRemoveLiquidity(address hookAddress) external pure returns (bool);
```



### shouldCallAfterRemoveLiquidity

```solidity
function shouldCallAfterRemoveLiquidity(address hookAddress) external pure returns (bool);
```



### shouldCallBeforeDonate

```solidity
function shouldCallBeforeDonate(address hookAddress) external pure returns (bool);
```



### shouldCallAfterDonate

```solidity
function shouldCallAfterDonate(address hookAddress) external pure returns (bool);
```



### getGasCostOfShouldCall

```solidity
function getGasCostOfShouldCall(address hookAddress) external view returns (uint256);
```



### getGasCostOfValidateHookAddress

```solidity
function getGasCostOfValidateHookAddress(address hookAddress, Hooks.Permissions calldata params)
    external
    view
    returns (uint256);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[LPFeeTakingHook](https://docs.uniswap.org/contracts/v4/reference/core/test/LPFeeTakingHook)

# LPFeeTakingHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/LPFeeTakingHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks)

a hook that takes all of the LP fee revenue

*an example test hook to validate the data is provided correctly*

## State Variables

### manager

```solidity
IPoolManager immutable manager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### onlyPoolManager

```solidity
modifier onlyPoolManager();
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta feeDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta feeDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[LiquidityMathTest](https://docs.uniswap.org/contracts/v4/reference/core/test/LiquidityMathTest)

# LiquidityMathTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/LiquidityMathTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### addDelta

```solidity
function addDelta(uint128 x, int128 y) external pure returns (uint128 z);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[MockContract](https://docs.uniswap.org/contracts/v4/reference/core/test/MockContract)

# MockContract

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockContract.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** Proxy

Mock contract that tracks the number of calls to various functions by selector

*allows for proxying to an implementation contract if real logic or return values are needed*

## State Variables

### calls

```solidity
mapping(bytes32 => uint256) public calls;
```



### callParams

```solidity
mapping(bytes32 => mapping(bytes => uint256)) public callParams;
```



### impl

If set, delegatecall to implementation after tracking call

```solidity
address internal impl;
```



## Functions

### timesCalledSelector

```solidity
function timesCalledSelector(bytes32 selector) public view returns (uint256);
```



### timesCalled

```solidity
function timesCalled(string calldata fnSig) public view returns (uint256);
```



### calledWithSelector

```solidity
function calledWithSelector(bytes32 selector, bytes calldata params) public view returns (bool);
```



### calledWith

```solidity
function calledWith(string calldata fnSig, bytes calldata params) public view returns (bool);
```



### _implementation

exposes implementation contract address

```solidity
function _implementation() internal view override returns (address);
```



### setImplementation

```solidity
function setImplementation(address _impl) external;
```



### _beforeFallback

Captures calls by selector

```solidity
function _beforeFallback() internal;
```



### _fallback

```solidity
function _fallback() internal override;
```



### receive

```solidity
receive() external payable;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[MockERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/test/MockERC6909Claims)

# MockERC6909Claims

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909Claims)

Mock contract for testing ERC6909Claims

## Functions

### mint

mocked mint logic

```solidity
function mint(address to, uint256 id, uint256 amount) public;
```



### burn

mocked burn logic

```solidity
function burn(uint256 id, uint256 amount) public;
```



### burnFrom

mocked burn logic without checking sender allowance

```solidity
function burnFrom(address from, uint256 id, uint256 amount) public;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[MockHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/MockHooks)

# MockHooks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IHooks](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks)

## State Variables

### beforeInitializeData

```solidity
bytes public beforeInitializeData;
```



### afterInitializeData

```solidity
bytes public afterInitializeData;
```



### beforeAddLiquidityData

```solidity
bytes public beforeAddLiquidityData;
```



### afterAddLiquidityData

```solidity
bytes public afterAddLiquidityData;
```



### beforeRemoveLiquidityData

```solidity
bytes public beforeRemoveLiquidityData;
```



### afterRemoveLiquidityData

```solidity
bytes public afterRemoveLiquidityData;
```



### beforeSwapData

```solidity
bytes public beforeSwapData;
```



### afterSwapData

```solidity
bytes public afterSwapData;
```



### beforeDonateData

```solidity
bytes public beforeDonateData;
```



### afterDonateData

```solidity
bytes public afterDonateData;
```



### returnValues

```solidity
mapping(bytes4 => bytes4) public returnValues;
```



### lpFees

```solidity
mapping(PoolId => uint16) public lpFees;
```



## Functions

### beforeInitialize

```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external override returns (bytes4);
```



### afterInitialize

```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external override returns (bytes4);
```



### beforeAddLiquidity

```solidity
function beforeAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata hookData
) external override returns (bytes4);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```



### beforeRemoveLiquidity

```solidity
function beforeRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata hookData
) external override returns (bytes4);
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata hookData)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata hookData)
    external
    override
    returns (bytes4, int128);
```



### beforeDonate

```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata hookData)
    external
    override
    returns (bytes4);
```



### afterDonate

```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata hookData)
    external
    override
    returns (bytes4);
```



### setReturnValue

```solidity
function setReturnValue(bytes4 key, bytes4 value) external;
```



### setlpFee

```solidity
function setlpFee(PoolKey calldata key, uint16 value) external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[NativeERC20](https://docs.uniswap.org/contracts/v4/reference/core/test/NativeERC20)

# NativeERC20

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/NativeERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** Test

*This token contract simulates the ERC20 representation of a native token where on `transfer` and `transferFrom` the native balances are modified using a precompile*

## State Variables

### name

```solidity
string public name = "NativeERC20";
```



### symbol

```solidity
string public symbol = "NERC20";
```



### decimals

```solidity
uint8 public decimals = 18;
```



### allowance

```solidity
mapping(address => mapping(address => uint256)) public allowance;
```



## Functions

### totalSupply

```solidity
function totalSupply() public view returns (uint256);
```



### approve

```solidity
function approve(address guy, uint256 wad) public returns (bool);
```



### transfer

```solidity
function transfer(address dst, uint256 wad) public returns (bool);
```



### transferFrom

```solidity
function transferFrom(address src, address dst, uint256 wad) public returns (bool);
```



### balanceOf

```solidity
function balanceOf(address account) external view returns (uint256);
```



## Events

### Approval

```solidity
event Approval(address indexed src, address indexed guy, uint256 wad);
```



### Transfer

```solidity
event Transfer(address indexed src, address indexed dst, uint256 wad);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[NoDelegateCallTest](https://docs.uniswap.org/contracts/v4/reference/core/test/NoDelegateCallTest)

# NoDelegateCallTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/NoDelegateCallTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [NoDelegateCall](https://docs.uniswap.org/contracts/v4/reference/core/NoDelegateCall)

## Functions

### canBeDelegateCalled

```solidity
function canBeDelegateCalled() public view returns (uint256);
```



### cannotBeDelegateCalled

```solidity
function cannotBeDelegateCalled() public view noDelegateCall returns (uint256);
```



### getGasCostOfCanBeDelegateCalled

```solidity
function getGasCostOfCanBeDelegateCalled() external view returns (uint256);
```



### getGasCostOfCannotBeDelegateCalled

```solidity
function getGasCostOfCannotBeDelegateCalled() external view returns (uint256);
```



### callsIntoNoDelegateCallFunction

```solidity
function callsIntoNoDelegateCallFunction() external view;
```



### noDelegateCallPrivate

```solidity
function noDelegateCallPrivate() private view noDelegateCall;
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolClaimsTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolClaimsTest)

# PoolClaimsTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolClaimsTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### deposit

Convert ERC20 into a claimable 6909

```solidity
function deposit(Currency currency, address user, uint256 amount) external payable;
```



### withdraw

Redeem claimable 6909 for ERC20

```solidity
function withdraw(Currency currency, address user, uint256 amount) external payable;
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    address user;
    Currency currency;
    uint256 amount;
    bool deposit;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolDonateTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolDonateTest)

# PoolDonateTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolDonateTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### donate

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    uint256 amount0;
    uint256 amount1;
    bytes hookData;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolEmptyUnlockTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolEmptyUnlockTest)

# PoolEmptyUnlockTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolEmptyUnlockTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IUnlockCallback](https://docs.uniswap.org/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)

## State Variables

### manager

```solidity
IPoolManager manager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### unlock

```solidity
function unlock() external;
```



### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked

```solidity
function unlockCallback(bytes calldata) external override returns (bytes memory);
```



## Events

### UnlockCallback

```solidity
event UnlockCallback();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolModifyLiquidityTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolModifyLiquidityTest)

# PoolModifyLiquidityTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolModifyLiquidityTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### modifyLiquidity

```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```



### modifyLiquidity

```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes memory hookData,
    bool settleUsingBurn,
    bool takeClaims
) public payable returns (BalanceDelta delta);
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.ModifyLiquidityParams params;
    bytes hookData;
    bool settleUsingBurn;
    bool takeClaims;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolModifyLiquidityTestNoChecks](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolModifyLiquidityTestNoChecks)

# PoolModifyLiquidityTestNoChecks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolModifyLiquidityTestNoChecks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### modifyLiquidity

```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```



### modifyLiquidity

```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes memory hookData,
    bool settleUsingBurn,
    bool takeClaims
) public payable returns (BalanceDelta delta);
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.ModifyLiquidityParams params;
    bytes hookData;
    bool settleUsingBurn;
    bool takeClaims;
}
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[Action](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolNestedActionsTest)

# Action

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
enum Action {
    NESTED_SELF_UNLOCK,
    NESTED_EXECUTOR_UNLOCK,
    SWAP_AND_SETTLE,
    DONATE_AND_SETTLE,
    ADD_LIQUIDITY_AND_SETTLE,
    REMOVE_LIQUIDITY_AND_SETTLE,
    INITIALIZE
}
```



# PoolNestedActionsTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol)

**Inherits:** Test, [IUnlockCallback](https://docs.uniswap.org/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)

## State Variables

### manager

```solidity
IPoolManager manager;
```



### executor

```solidity
NestedActionExecutor public executor;
```



### user

```solidity
address user;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### unlock

```solidity
function unlock(bytes calldata data) external;
```



### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked

```solidity
function unlockCallback(bytes calldata data) external override returns (bytes memory);
```



### _nestedUnlock

```solidity
function _nestedUnlock() internal;
```



# NestedActionExecutor

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol)

**Inherits:** Test, [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## State Variables

### key

```solidity
PoolKey internal key;
```



### user

```solidity
address user;
```



### ADD_LIQUIDITY_PARAMS

```solidity
IPoolManager.ModifyLiquidityParams internal ADD_LIQUIDITY_PARAMS =
    IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: 1e18, salt: 0});
```



### REMOVE_LIQUIDITY_PARAMS

```solidity
IPoolManager.ModifyLiquidityParams internal REMOVE_LIQUIDITY_PARAMS =
    IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: -1e18, salt: 0});
```



### SWAP_PARAMS

```solidity
IPoolManager.SwapParams internal SWAP_PARAMS =
    IPoolManager.SwapParams({zeroForOne: true, amountSpecified: -100, sqrtPriceLimitX96: Constants.SQRT_PRICE_1_2});
```



### DONATE_AMOUNT0

```solidity
uint256 internal DONATE_AMOUNT0 = 12345e6;
```



### DONATE_AMOUNT1

```solidity
uint256 internal DONATE_AMOUNT1 = 98765e4;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager, address _user) PoolTestBase(_manager);
```



### setKey

```solidity
function setKey(PoolKey memory _key) external;
```



### execute

```solidity
function execute(Action[] memory actions) public;
```



### _nestedUnlock

```solidity
function _nestedUnlock() internal;
```



### _swap

```solidity
function _swap(address caller) internal;
```



### _addLiquidity

```solidity
function _addLiquidity(address caller) internal;
```



### _removeLiquidity

```solidity
function _removeLiquidity(address caller) internal;
```



### _donate

```solidity
function _donate(address caller) internal;
```



### _initialize

```solidity
function _initialize() internal;
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata) external pure override returns (bytes memory);
```



## Errors

### KeyNotSet

```solidity
error KeyNotSet();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolSwapTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolSwapTest)

# PoolSwapTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolSwapTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### swap

```solidity
function swap(
    PoolKey memory key,
    IPoolManager.SwapParams memory params,
    TestSettings memory testSettings,
    bytes memory hookData
) external payable returns (BalanceDelta delta);
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Errors

### NoSwapOccurred

```solidity
error NoSwapOccurred();
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    TestSettings testSettings;
    PoolKey key;
    IPoolManager.SwapParams params;
    bytes hookData;
}
```



### TestSettings

```solidity
struct TestSettings {
    bool takeClaims;
    bool settleUsingBurn;
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolTakeTest](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTakeTest)

# PoolTakeTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolTakeTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### take

```solidity
function take(PoolKey memory key, uint256 amount0, uint256 amount1) external payable;
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



### _testTake

```solidity
function _testTake(Currency currency, address sender, uint256 amount) internal;
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    uint256 amount0;
    uint256 amount1;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

# PoolTestBase

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolTestBase.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IUnlockCallback](https://docs.uniswap.org/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)

## State Variables

### manager

```solidity
IPoolManager public immutable manager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _manager);
```



### _fetchBalances

```solidity
function _fetchBalances(Currency currency, address user, address deltaHolder)
    internal
    view
    returns (uint256 userBalance, uint256 poolBalance, int256 delta);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[ProtocolFeesImplementation](https://docs.uniswap.org/contracts/v4/reference/core/test/ProtocolFeesImplementation)

# ProtocolFeesImplementation

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ProtocolFeesImplementation.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/ProtocolFees)

## State Variables

### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```



### isUnlocked

```solidity
bool internal isUnlocked;
```



## Functions

### constructor

```solidity
constructor() ProtocolFees(msg.sender);
```



### setPrice

```solidity
function setPrice(PoolKey memory key, uint160 sqrtPriceX96) public;
```



### _getPool

```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```



### setIsUnlocked

```solidity
function setIsUnlocked(bool newValue) public;
```



### _isUnlocked

```solidity
function _isUnlocked() internal view override returns (bool);
```



### updateProtocolFees

```solidity
function updateProtocolFees(Currency currency, uint256 amount) public;
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[ProxyPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/test/ProxyPoolManager)

# ProxyPoolManager

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ProxyPoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IPoolManager), [ProtocolFees](https://docs.uniswap.org/contracts/v4/reference/core/ProtocolFees), [NoDelegateCall](https://docs.uniswap.org/contracts/v4/reference/core/NoDelegateCall), [ERC6909Claims](https://docs.uniswap.org/contracts/v4/reference/core/ERC6909Claims), [Extsload](https://docs.uniswap.org/contracts/v4/reference/core/Extsload), [Exttload](https://docs.uniswap.org/contracts/v4/reference/core/Exttload)

A proxy pool manager that delegates calls to the real/delegate pool manager

## State Variables

### MAX_TICK_SPACING

```solidity
int24 private constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;
```



### MIN_TICK_SPACING

```solidity
int24 private constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;
```



### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```



### _delegateManager

```solidity
address internal immutable _delegateManager;
```



## Functions

### constructor

```solidity
constructor(address delegateManager) ProtocolFees(msg.sender);
```



### onlyWhenUnlocked

This will revert if the contract is locked

```solidity
modifier onlyWhenUnlocked();
```



### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*

```solidity
function unlock(bytes calldata data) external noDelegateCall returns (bytes memory result);
```



**Parameters**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `data` | `bytes` | Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)` |

**Returns**

| Name     | Type    | Description                                                  |
| -------- | ------- | ------------------------------------------------------------ |
| `result` | `bytes` | The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)` |

### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external noDelegateCall returns (int24 tick);
```



**Parameters**

| Name           | Type      | Description                             |
| -------------- | --------- | --------------------------------------- |
| `key`          | `PoolKey` | The pool key for the pool to initialize |
| `sqrtPriceX96` | `uint160` | The initial square root price           |

**Returns**

| Name   | Type    | Description                  |
| ------ | ------- | ---------------------------- |
| `tick` | `int24` | The initial tick of the pool |

### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*

```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```



**Parameters**

| Name       | Type                                 | Description                                               |
| ---------- | ------------------------------------ | --------------------------------------------------------- |
| `key`      | `PoolKey`                            | The pool to modify liquidity in                           |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for modifying the liquidity                |
| `hookData` | `bytes`                              | The data to pass through to the add/removeLiquidity hooks |

**Returns**

| Name          | Type           | Description                                                  |
| ------------- | -------------- | ------------------------------------------------------------ |
| `callerDelta` | `BalanceDelta` | The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable |
| `feesAccrued` | `BalanceDelta` | The balance delta of the fees generated in the liquidity range. Returned for informational purposes |

### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*

```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta swapDelta);
```



**Parameters**

| Name       | Type                      | Description                                |
| ---------- | ------------------------- | ------------------------------------------ |
| `key`      | `PoolKey`                 | The pool to swap in                        |
| `params`   | `IPoolManager.SwapParams` | The parameters for swapping                |
| `hookData` | `bytes`                   | The data to pass through to the swap hooks |

**Returns**

| Name        | Type           | Description                               |
| ----------- | -------------- | ----------------------------------------- |
| `swapDelta` | `BalanceDelta` | The balance delta of the address swapping |

### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds. Donors should keep this in mind when designing donation mechanisms.*

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta delta);
```



**Parameters**

| Name       | Type      | Description                                  |
| ---------- | --------- | -------------------------------------------- |
| `key`      | `PoolKey` | The key of the pool to donate to             |
| `amount0`  | `uint256` | The amount of currency0 to donate            |
| `amount1`  | `uint256` | The amount of currency1 to donate            |
| `hookData` | `bytes`   | The data to pass through to the donate hooks |

**Returns**

| Name    | Type           | Description                                           |
| ------- | -------------- | ----------------------------------------------------- |
| `delta` | `BalanceDelta` | BalanceDelta The delta of the caller after the donate |

### sync

Writes the current ERC20 balance of the specified currency to transient storage This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped for native tokens because the amount to settle is determined by the sent value. However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle native funds, this function can be called with the native currency to then be able to settle the native currency*

```solidity
function sync(Currency currency) public;
```



### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*

```solidity
function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```



**Parameters**

| Name       | Type       | Description                                    |
| ---------- | ---------- | ---------------------------------------------- |
| `currency` | `Currency` | The currency to withdraw from the pool manager |
| `to`       | `address`  | The address to withdraw to                     |
| `amount`   | `uint256`  | The amount of currency to withdraw             |

### settle

Called by the user to pay what is owed

```solidity
function settle() external payable onlyWhenUnlocked noDelegateCall returns (uint256 paid);
```



**Returns**

| Name   | Type      | Description                    |
| ------ | --------- | ------------------------------ |
| `paid` | `uint256` | The amount of currency settled |

### settleFor

Called by the user to pay on behalf of another address

```solidity
function settleFor(address recipient) external payable onlyWhenUnlocked noDelegateCall returns (uint256 paid);
```



**Parameters**

| Name        | Type      | Description                           |
| ----------- | --------- | ------------------------------------- |
| `recipient` | `address` | The address to credit for the payment |

**Returns**

| Name   | Type      | Description                    |
| ------ | --------- | ------------------------------ |
| `paid` | `uint256` | The amount of currency settled |

### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently. A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust. Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*

```solidity
function clear(Currency currency, uint256 amount) external onlyWhenUnlocked;
```



### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```



**Parameters**

| Name     | Type      | Description                                            |
| -------- | --------- | ------------------------------------------------------ |
| `to`     | `address` | The address to mint the tokens to                      |
| `id`     | `uint256` | The currency address to mint to ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to mint                         |

### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address If the upper 12 bytes are not 0, they will be 0-ed out*

```solidity
function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```



**Parameters**

| Name     | Type      | Description                                              |
| -------- | --------- | -------------------------------------------------------- |
| `from`   | `address` | The address to burn the tokens from                      |
| `id`     | `uint256` | The currency address to burn from ERC6909s, as a uint256 |
| `amount` | `uint256` | The amount of currency to burn                           |

### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*

```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```



**Parameters**

| Name              | Type      | Description                                       |
| ----------------- | --------- | ------------------------------------------------- |
| `key`             | `PoolKey` | The key of the pool to update dynamic LP fees for |
| `newDynamicLPFee` | `uint24`  | The new dynamic pool LP fee                       |

### _delegateCall

Make a delegate call, bubble up any error or return the result

```solidity
function _delegateCall(address target, bytes memory data) internal returns (bytes memory result);
```



### _getPool

Implementation of the _getPool function defined in ProtocolFees

```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```



### _isUnlocked

Implementation of the _isUnlocked function defined in ProtocolFees

```solidity
function _isUnlocked() internal view override returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[SkipCallsTestHook](https://docs.uniswap.org/contracts/v4/reference/core/test/SkipCallsTestHook)

# SkipCallsTestHook

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SkipCallsTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [BaseTestHooks](https://docs.uniswap.org/contracts/v4/reference/core/test/BaseTestHooks), Test

## State Variables

### counter

```solidity
uint256 public counter;
```



### manager

```solidity
IPoolManager manager;
```



## Functions

### setManager

```solidity
function setManager(IPoolManager _manager) external;
```



### beforeInitialize

```solidity
function beforeInitialize(address, PoolKey calldata key, uint160 sqrtPriceX96) external override returns (bytes4);
```



### afterInitialize

```solidity
function afterInitialize(address, PoolKey calldata key, uint160 sqrtPriceX96, int24)
    external
    override
    returns (bytes4);
```



### beforeAddLiquidity

```solidity
function beforeAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external override returns (bytes4);
```



### afterAddLiquidity

```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```



### beforeRemoveLiquidity

```solidity
function beforeRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external override returns (bytes4);
```



### afterRemoveLiquidity

```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```



### beforeSwap

```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

```solidity
function afterSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, int128);
```



### beforeDonate

```solidity
function beforeDonate(address, PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData)
    external
    override
    returns (bytes4);
```



### afterDonate

```solidity
function afterDonate(address, PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData)
    external
    override
    returns (bytes4);
```



### _initialize

```solidity
function _initialize(PoolKey memory key, uint160 sqrtPriceX96) public;
```



### _swap

```solidity
function _swap(PoolKey calldata key, IPoolManager.SwapParams memory params, bytes calldata hookData) public;
```



### _addLiquidity

```solidity
function _addLiquidity(PoolKey calldata key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    public;
```



### _removeLiquidity

```solidity
function _removeLiquidity(
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) public;
```



### _donate

```solidity
function _donate(PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData) public;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[SqrtPriceMathEchidnaTest](https://docs.uniswap.org/contracts/v4/reference/core/test/SqrtPriceMathEchidnaTest)

# SqrtPriceMathEchidnaTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SqrtPriceMathEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### mulDivRoundingUpInvariants

```solidity
function mulDivRoundingUpInvariants(uint256 x, uint256 y, uint256 z) external pure;
```



### getNextSqrtPriceFromInputInvariants

```solidity
function getNextSqrtPriceFromInputInvariants(uint160 sqrtP, uint128 liquidity, uint256 amountIn, bool zeroForOne)
    external
    pure;
```



### getNextSqrtPriceFromOutputInvariants

```solidity
function getNextSqrtPriceFromOutputInvariants(uint160 sqrtP, uint128 liquidity, uint256 amountOut, bool zeroForOne)
    external
    pure;
```



### getNextSqrtPriceFromAmount0RoundingUpInvariants

```solidity
function getNextSqrtPriceFromAmount0RoundingUpInvariants(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    external
    pure;
```



### getNextSqrtPriceFromAmount1RoundingDownInvariants

```solidity
function getNextSqrtPriceFromAmount1RoundingDownInvariants(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
) external pure;
```



### getAmount0DeltaInvariants

```solidity
function getAmount0DeltaInvariants(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity) external pure;
```



### getAmount0DeltaEquivalency

```solidity
function getAmount0DeltaEquivalency(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity, bool roundUp) external pure;
```



### getAmount1DeltaInvariants

```solidity
function getAmount1DeltaInvariants(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity) external pure;
```



### getAmount0DeltaSignedInvariants

```solidity
function getAmount0DeltaSignedInvariants(uint160 sqrtP, uint160 sqrtQ, int128 liquidity) external pure;
```



### getAmount1DeltaSignedInvariants

```solidity
function getAmount1DeltaSignedInvariants(uint160 sqrtP, uint160 sqrtQ, int128 liquidity) external pure;
```



### getOutOfRangeMintInvariants

```solidity
function getOutOfRangeMintInvariants(uint160 sqrtA, uint160 sqrtB, int128 liquidity) external pure;
```



### getInRangeMintInvariants

```solidity
function getInRangeMintInvariants(uint160 sqrtLower, uint160 sqrtCurrent, uint160 sqrtUpper, int128 liquidity)
    external
    pure;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[SwapRouterNoChecks](https://docs.uniswap.org/contracts/v4/reference/core/test/SwapRouterNoChecks)

# SwapRouterNoChecks

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SwapRouterNoChecks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [PoolTestBase](https://docs.uniswap.org/contracts/v4/reference/core/test/PoolTestBase)

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```



### swap

```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params) external payable;
```



### unlockCallback

```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```



## Errors

### NoSwapOccurred

```solidity
error NoSwapOccurred();
```



## Structs

### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.SwapParams params;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[TestERC20](https://docs.uniswap.org/contracts/v4/reference/core/test/TestERC20)

# TestERC20

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TestERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IERC20Minimal](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC20Minimal)

## State Variables

### balanceOf

```solidity
mapping(address => uint256) public override balanceOf;
```



### allowance

```solidity
mapping(address => mapping(address => uint256)) public override allowance;
```



## Functions

### constructor

```solidity
constructor(uint256 amountToMint);
```



### mint

```solidity
function mint(address to, uint256 amount) public;
```



### transfer

```solidity
function transfer(address recipient, uint256 amount) external override returns (bool);
```



### approve

```solidity
function approve(address spender, uint256 amount) external override returns (bool);
```



### transferFrom

```solidity
function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[TestInvalidERC20](https://docs.uniswap.org/contracts/v4/reference/core/test/TestInvalidERC20)

# TestInvalidERC20

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TestInvalidERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IERC20Minimal](https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IERC20Minimal)

## State Variables

### balanceOf

```solidity
mapping(address => uint256) public override balanceOf;
```



### allowance

```solidity
mapping(address => mapping(address => uint256)) public override allowance;
```



## Functions

### constructor

```solidity
constructor(uint256 amountToMint);
```



### mint

```solidity
function mint(address to, uint256 amount) public;
```



### transfer

```solidity
function transfer(address recipient, uint256 amount) external override returns (bool);
```



### approve

```solidity
function approve(address spender, uint256 amount) external override returns (bool);
```



### transferFrom

```solidity
function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[TickMathEchidnaTest](https://docs.uniswap.org/contracts/v4/reference/core/test/TickMathEchidnaTest)

# TickMathEchidnaTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickMathEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### checkGetSqrtPriceAtTickInvariants

```solidity
function checkGetSqrtPriceAtTickInvariants(int24 tick) external pure;
```



### checkGetTickAtSqrtPriceInvariants

```solidity
function checkGetTickAtSqrtPriceInvariants(uint160 price) external pure;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[TickMathTest](https://docs.uniswap.org/contracts/v4/reference/core/test/TickMathTest)

# TickMathTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickMathTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### getSqrtPriceAtTick

```solidity
function getSqrtPriceAtTick(int24 tick) external pure returns (uint160);
```



### getGasCostOfGetSqrtPriceAtTick

```solidity
function getGasCostOfGetSqrtPriceAtTick(int24 tick) external view returns (uint256);
```



### getTickAtSqrtPrice

```solidity
function getTickAtSqrtPrice(uint160 sqrtPriceX96) external pure returns (int24);
```



### getGasCostOfGetTickAtSqrtPrice

```solidity
function getGasCostOfGetTickAtSqrtPrice(uint160 sqrtPriceX96) external view returns (uint256);
```



### MIN_SQRT_PRICE

```solidity
function MIN_SQRT_PRICE() external pure returns (uint160);
```



### MAX_SQRT_PRICE

```solidity
function MAX_SQRT_PRICE() external pure returns (uint160);
```



### MIN_TICK

```solidity
function MIN_TICK() external pure returns (int24);
```



### MAX_TICK

```solidity
function MAX_TICK() external pure returns (int24);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferenceCoretest[TickOverflowSafetyEchidnaTest](https://docs.uniswap.org/contracts/v4/reference/core/test/TickOverflowSafetyEchidnaTest)

# TickOverflowSafetyEchidnaTest

[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickOverflowSafetyEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## State Variables

### MIN_TICK

```solidity
int24 private constant MIN_TICK = -16;
```



### MAX_TICK

```solidity
int24 private constant MAX_TICK = 16;
```



### pool

```solidity
Pool.State private pool;
```



### tick

```solidity
int24 private tick = 0;
```



### feeGrowthGlobal0X128

```solidity
uint256 feeGrowthGlobal0X128 = type(uint256).max / 2;
```



### feeGrowthGlobal1X128

```solidity
uint256 feeGrowthGlobal1X128 = type(uint256).max / 2;
```



### totalLiquidity

```solidity
int256 totalLiquidity = 0;
```



### totalGrowth0

```solidity
uint256 private totalGrowth0 = 0;
```



### totalGrowth1

```solidity
uint256 private totalGrowth1 = 0;
```



## Functions

### increaseFeeGrowthGlobal0X128

```solidity
function increaseFeeGrowthGlobal0X128(uint256 amount) external;
```



### increaseFeeGrowthGlobal1X128

```solidity
function increaseFeeGrowthGlobal1X128(uint256 amount) external;
```



### setPosition

```solidity
function setPosition(int24 tickLower, int24 tickUpper, int128 liquidityDelta) external;
```



### moveToTick

```solidity
function moveToTick(int24 target) external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeriphery[PositionDescriptor](https://docs.uniswap.org/contracts/v4/reference/periphery/PositionDescriptor)

# PositionDescriptor

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/PositionDescriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IPositionDescriptor](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPositionDescriptor)

Produces a string containing the data URI for a JSON metadata string

## State Variables

### DAI

```solidity
address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
```



### USDC

```solidity
address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
```



### USDT

```solidity
address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
```



### TBTC

```solidity
address private constant TBTC = 0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa;
```



### WBTC

```solidity
address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
```



### wrappedNative

```solidity
address public immutable wrappedNative;
```



### nativeCurrencyLabelBytes

```solidity
bytes32 private immutable nativeCurrencyLabelBytes;
```



### poolManager

```solidity
IPoolManager public immutable poolManager;
```



## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager, address _wrappedNative, bytes32 _nativeCurrencyLabelBytes);
```



### nativeCurrencyLabel

Returns the native currency label as a string

```solidity
function nativeCurrencyLabel() public view returns (string memory);
```



### tokenURI

Produces the URI describing a particular token ID

*Note this URI may be a data: URI with the JSON contents directly inlined*

```solidity
function tokenURI(IPositionManager positionManager, uint256 tokenId) external view override returns (string memory);
```



**Parameters**

| Name              | Type               | Description                                                  |
| ----------------- | ------------------ | ------------------------------------------------------------ |
| `positionManager` | `IPositionManager` | The position manager for which to describe the token         |
| `tokenId`         | `uint256`          | The ID of the token for which to produce a description, which may not be valid |

**Returns**

| Name     | Type     | Description                              |
| -------- | -------- | ---------------------------------------- |
| `<none>` | `string` | The URI of the ERC721-compliant metadata |

### flipRatio

Returns true if currency0 has higher priority than currency1

```solidity
function flipRatio(address currency0, address currency1) public view returns (bool);
```



**Parameters**

| Name        | Type      | Description                 |
| ----------- | --------- | --------------------------- |
| `currency0` | `address` | The first currency address  |
| `currency1` | `address` | The second currency address |

**Returns**

| Name     | Type   | Description                                          |
| -------- | ------ | ---------------------------------------------------- |
| `<none>` | `bool` | True if currency0 has higher priority than currency1 |

### currencyRatioPriority

Returns the priority of a currency. For certain currencies on mainnet, the smaller the currency, the higher the priority And those with the higher priority values (more positive values) will be in the numerator of the price ratio

```solidity
function currencyRatioPriority(address currency) public view returns (int256);
```



**Parameters**

| Name       | Type      | Description          |
| ---------- | --------- | -------------------- |
| `currency` | `address` | The currency address |

**Returns**

| Name     | Type     | Description                  |
| -------- | -------- | ---------------------------- |
| `<none>` | `int256` | The priority of the currency |







[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeriphery[UniswapV4DeployerCompetition](https://docs.uniswap.org/contracts/v4/reference/periphery/UniswapV4DeployerCompetition)

# UniswapV4DeployerCompetition

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/UniswapV4DeployerCompetition.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IUniswapV4DeployerCompetition](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IUniswapV4DeployerCompetition)

A contract to crowdsource a salt for the best Uniswap V4 address

## State Variables

### bestAddressSalt

*The salt for the best address found so far*

```solidity
bytes32 public bestAddressSalt;
```



### bestAddressSubmitter

*The submitter of the best address found so far*

```solidity
address public bestAddressSubmitter;
```



### competitionDeadline

*The deadline for the competition*

```solidity
uint256 public immutable competitionDeadline;
```



### initCodeHash

*The init code hash of the V4 contract*

```solidity
bytes32 public immutable initCodeHash;
```



### deployer

*The deployer who can initiate the deployment of the v4 PoolManager, until the exclusive deploy deadline.*

*After this deadline anyone can deploy.*

```solidity
address public immutable deployer;
```



### exclusiveDeployDeadline

*The deadline for exclusive deployment by deployer after deadline*

```solidity
uint256 public immutable exclusiveDeployDeadline;
```



## Functions

### constructor

```solidity
constructor(
    bytes32 _initCodeHash,
    uint256 _competitionDeadline,
    address _exclusiveDeployer,
    uint256 _exclusiveDeployLength
);
```



### updateBestAddress

Updates the best address if the new address has a better vanity score

*The first 20 bytes of the salt must be either address(0) or msg.sender*

```solidity
function updateBestAddress(bytes32 salt) external;
```



**Parameters**

| Name   | Type      | Description                                             |
| ------ | --------- | ------------------------------------------------------- |
| `salt` | `bytes32` | The salt to use to compute the new address with CREATE2 |

### deploy

deploys the Uniswap v4 PoolManager contract

*The bytecode must match the initCodeHash*

```solidity
function deploy(bytes memory bytecode) external;
```



**Parameters**

| Name       | Type    | Description                                         |
| ---------- | ------- | --------------------------------------------------- |
| `bytecode` | `bytes` | The bytecode of the Uniswap v4 PoolManager contract |

### bestAddress

*returns the best address found so far*

```solidity
function bestAddress() public view returns (address);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeriphery[V4Router](https://docs.uniswap.org/contracts/v4/reference/periphery/V4Router)

# V4Router

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/V4Router.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IV4Router](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IV4Router), [BaseActionsRouter](https://docs.uniswap.org/contracts/v4/reference/periphery/base/BaseActionsRouter), [DeltaResolver](https://docs.uniswap.org/contracts/v4/reference/periphery/base/DeltaResolver)

Abstract contract that contains all internal logic needed for routing through Uniswap v4 pools

*the entry point to executing actions in this contract is calling `BaseActionsRouter._executeActions` An inheriting contract should call _executeActions at the point that they wish actions to be executed*

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) BaseActionsRouter(_poolManager);
```



### _handleAction

```solidity
function _handleAction(uint256 action, bytes calldata params) internal override;
```



### _swapExactInputSingle

```solidity
function _swapExactInputSingle(IV4Router.ExactInputSingleParams calldata params) private;
```



### _swapExactInput

```solidity
function _swapExactInput(IV4Router.ExactInputParams calldata params) private;
```



### _swapExactOutputSingle

```solidity
function _swapExactOutputSingle(IV4Router.ExactOutputSingleParams calldata params) private;
```



### _swapExactOutput

```solidity
function _swapExactOutput(IV4Router.ExactOutputParams calldata params) private;
```



### _swap

```solidity
function _swap(PoolKey memory poolKey, bool zeroForOne, int256 amountSpecified, bytes calldata hookData)
    private
    returns (int128 reciprocalAmount);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[BaseActionsRouter](https://docs.uniswap.org/contracts/v4/reference/periphery/base/BaseActionsRouter)

# BaseActionsRouter

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/BaseActionsRouter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [SafeCallback](https://docs.uniswap.org/contracts/v4/reference/periphery/base/SafeCallback)

Abstract contract for performing a combination of actions on Uniswap v4.

*Suggested uint256 action values are defined in Actions.sol, however any definition can be used*

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) SafeCallback(_poolManager);
```



### _executeActions

internal function that triggers the execution of a set of actions on v4

*inheriting contracts should call this function to trigger execution*

```solidity
function _executeActions(bytes calldata unlockData) internal;
```



### _unlockCallback

function that is called by the PoolManager through the SafeCallback.unlockCallback

```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory);
```



**Parameters**

| Name   | Type    | Description                                                  |
| ------ | ------- | ------------------------------------------------------------ |
| `data` | `bytes` | Abi encoding of (bytes actions, bytes[] params) where params[i] is the encoded parameters for actions[i] |

### _executeActionsWithoutUnlock

```solidity
function _executeActionsWithoutUnlock(bytes calldata actions, bytes[] calldata params) internal;
```



### _handleAction

function to handle the parsing and execution of an action and its parameters

```solidity
function _handleAction(uint256 action, bytes calldata params) internal virtual;
```



### msgSender

function that returns address considered executor of the actions

*The other context functions, _msgData and _msgValue, are not supported by this contract In many contracts this will be the address that calls the initial entry point that calls `_executeActions` `msg.sender` shouldn't be used, as this will be the v4 pool manager contract that calls `unlockCallback` If using ReentrancyLock.sol, this function can return _getLocker()*

```solidity
function msgSender() public view virtual returns (address);
```



### _mapRecipient

Calculates the address for a action

```solidity
function _mapRecipient(address recipient) internal view returns (address);
```



### _mapPayer

Calculates the payer for an action

```solidity
function _mapPayer(bool payerIsUser) internal view returns (address);
```



## Errors

### InputLengthMismatch

emitted when different numbers of parameters and actions are provided

```solidity
error InputLengthMismatch();
```



### UnsupportedAction

emitted when an inheriting contract does not support an action

```solidity
error UnsupportedAction(uint256 action);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[BaseV4Quoter](https://docs.uniswap.org/contracts/v4/reference/periphery/base/BaseV4Quoter)

# BaseV4Quoter

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/BaseV4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [SafeCallback](https://docs.uniswap.org/contracts/v4/reference/periphery/base/SafeCallback)

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) SafeCallback(_poolManager);
```



### selfOnly

*Only this address may call this function. Used to mimic internal functions, using an external call to catch and parse revert reasons*

```solidity
modifier selfOnly();
```



### _unlockCallback

```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory);
```



### _swap

if amountSpecified < 0, the swap is exactInput, otherwise exactOutput

*Execute a swap and return the balance delta*

```solidity
function _swap(PoolKey memory poolKey, bool zeroForOne, int256 amountSpecified, bytes calldata hookData)
    internal
    returns (BalanceDelta swapDelta);
```



## Errors

### NotEnoughLiquidity

```solidity
error NotEnoughLiquidity(PoolId poolId);
```



### NotSelf

```solidity
error NotSelf();
```



### UnexpectedCallSuccess

```solidity
error UnexpectedCallSuccess();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[DeltaResolver](https://docs.uniswap.org/contracts/v4/reference/periphery/base/DeltaResolver)

# DeltaResolver

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/DeltaResolver.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState)

Abstract contract used to sync, send, and settle funds to the pool manager

*Note that sync() is called before any erc-20 transfer in `settle`.*

## Functions

### _take

Take an amount of currency out of the PoolManager

*Returns early if the amount is 0*

```solidity
function _take(Currency currency, address recipient, uint256 amount) internal;
```



**Parameters**

| Name        | Type       | Description                     |
| ----------- | ---------- | ------------------------------- |
| `currency`  | `Currency` | Currency to take                |
| `recipient` | `address`  | Address to receive the currency |
| `amount`    | `uint256`  | Amount to take                  |

### _settle

Pay and settle a currency to the PoolManager

*The implementing contract must ensure that the `payer` is a secure address*

*Returns early if the amount is 0*

```solidity
function _settle(Currency currency, address payer, uint256 amount) internal;
```



**Parameters**

| Name       | Type       | Description          |
| ---------- | ---------- | -------------------- |
| `currency` | `Currency` | Currency to settle   |
| `payer`    | `address`  | Address of the payer |
| `amount`   | `uint256`  | Amount to send       |

### _pay

Abstract function for contracts to implement paying tokens to the poolManager

*The recipient of the payment should be the poolManager*

```solidity
function _pay(Currency token, address payer, uint256 amount) internal virtual;
```



**Parameters**

| Name     | Type       | Description                                                  |
| -------- | ---------- | ------------------------------------------------------------ |
| `token`  | `Currency` | The token to settle. This is known not to be the native currency |
| `payer`  | `address`  | The address who should pay tokens                            |
| `amount` | `uint256`  | The number of tokens to send                                 |

### _getFullDebt

Obtain the full amount owed by this contract (negative delta)

```solidity
function _getFullDebt(Currency currency) internal view returns (uint256 amount);
```



**Parameters**

| Name       | Type       | Description                   |
| ---------- | ---------- | ----------------------------- |
| `currency` | `Currency` | Currency to get the delta for |

**Returns**

| Name     | Type      | Description                                   |
| -------- | --------- | --------------------------------------------- |
| `amount` | `uint256` | The amount owed by this contract as a uint256 |

### _getFullCredit

Obtain the full credit owed to this contract (positive delta)

```solidity
function _getFullCredit(Currency currency) internal view returns (uint256 amount);
```



**Parameters**

| Name       | Type       | Description                   |
| ---------- | ---------- | ----------------------------- |
| `currency` | `Currency` | Currency to get the delta for |

**Returns**

| Name     | Type      | Description                                   |
| -------- | --------- | --------------------------------------------- |
| `amount` | `uint256` | The amount owed to this contract as a uint256 |

### _mapSettleAmount

Calculates the amount for a settle action

```solidity
function _mapSettleAmount(uint256 amount, Currency currency) internal view returns (uint256);
```



### _mapTakeAmount

Calculates the amount for a take action

```solidity
function _mapTakeAmount(uint256 amount, Currency currency) internal view returns (uint256);
```



### _mapWrapUnwrapAmount

Calculates the sanitized amount before wrapping/unwrapping.

```solidity
function _mapWrapUnwrapAmount(Currency inputCurrency, uint256 amount, Currency outputCurrency)
    internal
    view
    returns (uint256);
```



**Parameters**

| Name             | Type       | Description                                                  |
| ---------------- | ---------- | ------------------------------------------------------------ |
| `inputCurrency`  | `Currency` | The currency, either native or wrapped native, that this contract holds |
| `amount`         | `uint256`  | The amount to wrap or unwrap. Can be CONTRACT_BALANCE, OPEN_DELTA or a specific amount |
| `outputCurrency` | `Currency` | The currency after the wrap/unwrap that the user may owe a balance in on the poolManager |

## Errors

### DeltaNotPositive

Emitted trying to settle a positive delta.

```solidity
error DeltaNotPositive(Currency currency);
```



### DeltaNotNegative

Emitted trying to take a negative delta.

```solidity
error DeltaNotNegative(Currency currency);
```



### InsufficientBalance

Emitted when the contract does not have enough balance to wrap or unwrap.

```solidity
error InsufficientBalance();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[EIP712_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/base/EIP712_v4)

# EIP712_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/EIP712_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IEIP712_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IEIP712_v4)

Generic EIP712 implementation

*Maintains cross-chain replay protection in the event of a fork*

*Should not be delegatecall'd because DOMAIN_SEPARATOR returns the cached hash and does not recompute with the delegatecallers address*

*Reference: https://github.com/Uniswap/permit2/blob/3f17e8db813189a03950dc7fc8382524a095c053/src/EIP712.sol*

*Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7bd2b2aaf68c21277097166a9a51eb72ae239b34/contracts/utils/cryptography/EIP712.sol*

## State Variables

### _CACHED_DOMAIN_SEPARATOR

```solidity
bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
```



### _CACHED_CHAIN_ID

```solidity
uint256 private immutable _CACHED_CHAIN_ID;
```



### _HASHED_NAME

```solidity
bytes32 private immutable _HASHED_NAME;
```



### _TYPE_HASH

```solidity
bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
```



## Functions

### constructor

```solidity
constructor(string memory name);
```



### DOMAIN_SEPARATOR

Returns the domain separator for the current chain.

```solidity
function DOMAIN_SEPARATOR() public view returns (bytes32);
```



**Returns**

| Name     | Type      | Description                  |
| -------- | --------- | ---------------------------- |
| `<none>` | `bytes32` | bytes32 The domain separator |

### _buildDomainSeparator

Builds a domain separator using the current chainId and contract address.

```solidity
function _buildDomainSeparator() private view returns (bytes32);
```



### _hashTypedData

Creates an EIP-712 typed data hash

```solidity
function _hashTypedData(bytes32 dataHash) internal view returns (bytes32 digest);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[ERC721Permit_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ERC721Permit_v4)

# ERC721Permit_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ERC721Permit_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** ERC721, [IERC721Permit_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IERC721Permit_v4), [EIP712_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/base/EIP712_v4), [UnorderedNonce](https://docs.uniswap.org/contracts/v4/reference/periphery/base/UnorderedNonce)

Nonfungible tokens that support an approve via signature, i.e. permit

## Functions

### constructor

Computes the nameHash and versionHash

```solidity
constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) EIP712_v4(name_);
```



### checkSignatureDeadline

Checks if the block's timestamp is before a signature's deadline

```solidity
modifier checkSignatureDeadline(uint256 deadline);
```



### permit

Approve of a specific token ID for spending by spender via signature

*payable so it can be multicalled with NATIVE related actions*

```solidity
function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)
    external
    payable
    checkSignatureDeadline(deadline);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `spender`   | `address` | The account that is being approved                           |
| `tokenId`   | `uint256` | The ID of the token that is being approved for spending      |
| `deadline`  | `uint256` | The deadline timestamp by which the call must be mined for the approve to work |
| `nonce`     | `uint256` | a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word |
| `signature` | `bytes`   | Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v) |

### permitForAll

Set an operator with full permission to an owner's tokens via signature

*payable so it can be multicalled with NATIVE related actions*

```solidity
function permitForAll(
    address owner,
    address operator,
    bool approved,
    uint256 deadline,
    uint256 nonce,
    bytes calldata signature
) external payable checkSignatureDeadline(deadline);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `owner`     | `address` | The address that is setting the operator                     |
| `operator`  | `address` | The address that will be set as an operator for the owner    |
| `approved`  | `bool`    | The permission to set on the operator                        |
| `deadline`  | `uint256` | The deadline timestamp by which the call must be mined for the approve to work |
| `nonce`     | `uint256` | a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word |
| `signature` | `bytes`   | Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v) |

### setApprovalForAll

Enable or disable approval for a third party ("operator") to manage all of `msg.sender`'s assets

*Emits the ApprovalForAll event. The contract MUST allow multiple operators per owner.*

*Override Solmate's ERC721 setApprovalForAll so setApprovalForAll() and permit() share the _approveForAll method*

```solidity
function setApprovalForAll(address operator, bool approved) public override;
```



**Parameters**

| Name       | Type      | Description                                                |
| ---------- | --------- | ---------------------------------------------------------- |
| `operator` | `address` | Address to add to the set of authorized operators          |
| `approved` | `bool`    | True if the operator is approved, false to revoke approval |

### _approveForAll

```solidity
function _approveForAll(address owner, address operator, bool approved) internal;
```



### approve

Change or reaffirm the approved address for an NFT

*override Solmate's ERC721 approve so approve() and permit() share the _approve method Passing a spender address of zero can be used to remove any outstanding approvals Throws error unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.*

```solidity
function approve(address spender, uint256 id) public override;
```



**Parameters**

| Name      | Type      | Description                       |
| --------- | --------- | --------------------------------- |
| `spender` | `address` | The new approved NFT controller   |
| `id`      | `uint256` | The tokenId of the NFT to approve |

### _approve

```solidity
function _approve(address owner, address spender, uint256 id) internal;
```



### _isApprovedOrOwner

```solidity
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState)

# ImmutableState

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ImmutableState.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState)

A collection of immutable state variables, commonly used across multiple contracts

## State Variables

### poolManager

The Uniswap v4 PoolManager contract

```solidity
IPoolManager public immutable poolManager;
```



## Functions

### onlyPoolManager

Only allow calls from the PoolManager contract

```solidity
modifier onlyPoolManager();
```



### constructor

```solidity
constructor(IPoolManager _poolManager);
```



## Errors

### NotPoolManager

Thrown when the caller is not PoolManager

```solidity
error NotPoolManager();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[Multicall_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/base/Multicall_v4)

# Multicall_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Multicall_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IMulticall_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IMulticall_v4)

Enables calling multiple methods in a single call to the contract

## Functions

### multicall

Call multiple functions in the current contract and return the data from all of them if they all succeed

*The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether. Subcalls can instead use `address(this).value` to see the available ETH, and consume it using {value: x}.*

```solidity
function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
```



**Parameters**

| Name   | Type      | Description                                                  |
| ------ | --------- | ------------------------------------------------------------ |
| `data` | `bytes[]` | The encoded function data for each of the calls to make to this contract |

**Returns**

| Name      | Type      | Description                                           |
| --------- | --------- | ----------------------------------------------------- |
| `results` | `bytes[]` | The results from each of the calls passed in via data |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[NativeWrapper](https://docs.uniswap.org/contracts/v4/reference/periphery/base/NativeWrapper)

# NativeWrapper

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/NativeWrapper.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState)

Used for wrapping and unwrapping native

## State Variables

### WETH9

The address for WETH9

```solidity
IWETH9 public immutable WETH9;
```



## Functions

### constructor

```solidity
constructor(IWETH9 _weth9);
```



### _wrap

*The amount should already be <= the current balance in this contract.*

```solidity
function _wrap(uint256 amount) internal;
```



### _unwrap

*The amount should already be <= the current balance in this contract.*

```solidity
function _unwrap(uint256 amount) internal;
```



### receive

```solidity
receive() external payable;
```



## Errors

### InvalidEthSender

Thrown when an unexpected address sends ETH to this contract

```solidity
error InvalidEthSender();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[Notifier](https://docs.uniswap.org/contracts/v4/reference/periphery/base/Notifier)

# Notifier

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Notifier.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [INotifier](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/INotifier)

Notifier is used to opt in to sending updates to external contracts about position modifications or transfers

## State Variables

### NO_SUBSCRIBER

```solidity
ISubscriber private constant NO_SUBSCRIBER = ISubscriber(address(0));
```



### unsubscribeGasLimit

Returns and determines the maximum allowable gas-used for notifying unsubscribe

```solidity
uint256 public immutable unsubscribeGasLimit;
```



### subscriber

Returns the subscriber for a respective position

```solidity
mapping(uint256 tokenId => ISubscriber subscriber) public subscriber;
```



## Functions

### constructor

```solidity
constructor(uint256 _unsubscribeGasLimit);
```



### onlyIfApproved

Only allow callers that are approved as spenders or operators of the tokenId

*to be implemented by the parent contract (PositionManager)*

```solidity
modifier onlyIfApproved(address caller, uint256 tokenId) virtual;
```



**Parameters**

| Name      | Type      | Description                 |
| --------- | --------- | --------------------------- |
| `caller`  | `address` | the address of the caller   |
| `tokenId` | `uint256` | the tokenId of the position |

### onlyIfPoolManagerLocked

Enforces that the PoolManager is locked.

```solidity
modifier onlyIfPoolManagerLocked() virtual;
```



### _setUnsubscribed

```solidity
function _setUnsubscribed(uint256 tokenId) internal virtual;
```



### _setSubscribed

```solidity
function _setSubscribed(uint256 tokenId) internal virtual;
```



### subscribe

Enables the subscriber to receive notifications for a respective position

*Calling subscribe when a position is already subscribed will revert*

```solidity
function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data)
    external
    payable
    onlyIfPoolManagerLocked
    onlyIfApproved(msg.sender, tokenId);
```



**Parameters**

| Name            | Type      | Description                                                  |
| --------------- | --------- | ------------------------------------------------------------ |
| `tokenId`       | `uint256` | the ERC721 tokenId                                           |
| `newSubscriber` | `address` | the address of the subscriber contract                       |
| `data`          | `bytes`   | caller-provided data that's forwarded to the subscriber contract |

### unsubscribe

Removes the subscriber from receiving notifications for a respective position

*Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified*

```solidity
function unsubscribe(uint256 tokenId) external payable onlyIfPoolManagerLocked onlyIfApproved(msg.sender, tokenId);
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

### _unsubscribe

```solidity
function _unsubscribe(uint256 tokenId) internal;
```



### _removeSubscriberAndNotifyBurn

*note this function also deletes the subscriber address from the mapping*

```solidity
function _removeSubscriberAndNotifyBurn(
    uint256 tokenId,
    address owner,
    PositionInfo info,
    uint256 liquidity,
    BalanceDelta feesAccrued
) internal;
```



### _notifyModifyLiquidity

```solidity
function _notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) internal;
```



### _call

```solidity
function _call(address target, bytes memory encodedCall) internal returns (bool success);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[Permit2Forwarder](https://docs.uniswap.org/contracts/v4/reference/periphery/base/Permit2Forwarder)

# Permit2Forwarder

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Permit2Forwarder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IPermit2Forwarder](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPermit2Forwarder)

Permit2Forwarder allows permitting this contract as a spender on permit2

*This contract does not enforce the spender to be this contract, but that is the intended use case*

## State Variables

### permit2

the Permit2 contract to forward approvals

```solidity
IAllowanceTransfer public immutable permit2;
```



## Functions

### constructor

```solidity
constructor(IAllowanceTransfer _permit2);
```



### permit

allows forwarding a single permit to permit2

*this function is payable to allow multicall with NATIVE based actions*

```solidity
function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```



**Parameters**

| Name           | Type                              | Description                                            |
| -------------- | --------------------------------- | ------------------------------------------------------ |
| `owner`        | `address`                         | the owner of the tokens                                |
| `permitSingle` | `IAllowanceTransfer.PermitSingle` | the permit data                                        |
| `signature`    | `bytes`                           | the signature of the permit; abi.encodePacked(r, s, v) |

**Returns**

| Name  | Type    | Description                                                  |
| ----- | ------- | ------------------------------------------------------------ |
| `err` | `bytes` | the error returned by a reverting permit call, empty if successful |

### permitBatch

allows forwarding batch permits to permit2

*this function is payable to allow multicall with NATIVE based actions*

```solidity
function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```



**Parameters**

| Name           | Type                             | Description                                            |
| -------------- | -------------------------------- | ------------------------------------------------------ |
| `owner`        | `address`                        | the owner of the tokens                                |
| `_permitBatch` | `IAllowanceTransfer.PermitBatch` | a batch of approvals                                   |
| `signature`    | `bytes`                          | the signature of the permit; abi.encodePacked(r, s, v) |

**Returns**

| Name  | Type    | Description                                                  |
| ----- | ------- | ------------------------------------------------------------ |
| `err` | `bytes` | the error returned by a reverting permit call, empty if successful |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[PoolInitializer_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/base/PoolInitializer_v4)

# PoolInitializer_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/PoolInitializer_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState), [IPoolInitializer_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4)

Initializes a Uniswap v4 Pool

*Enables create pool + mint liquidity in a single transaction with multicall*

## Functions

### initializePool

Initialize a Uniswap v4 Pool

*If the pool is already initialized, this function will not revert and just return type(int24).max*

```solidity
function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);
```



**Parameters**

| Name           | Type      | Description                                                  |
| -------------- | --------- | ------------------------------------------------------------ |
| `key`          | `PoolKey` | The PoolKey of the pool to initialize                        |
| `sqrtPriceX96` | `uint160` | The initial starting price of the pool, expressed as a sqrtPriceX96 |

**Returns**

| Name     | Type    | Description                                                  |
| -------- | ------- | ------------------------------------------------------------ |
| `<none>` | `int24` | The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[ReentrancyLock](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ReentrancyLock)

# ReentrancyLock

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ReentrancyLock.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A transient reentrancy lock, that stores the caller's address as the lock

## Functions

### isNotLocked

```solidity
modifier isNotLocked();
```



### _getLocker

```solidity
function _getLocker() internal view returns (address);
```



## Errors

### ContractLocked

```solidity
error ContractLocked();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[SafeCallback](https://docs.uniswap.org/contracts/v4/reference/periphery/base/SafeCallback)

# SafeCallback

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/SafeCallback.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState), IUnlockCallback

A contract that only allows the Uniswap v4 PoolManager to call the unlockCallback

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) ImmutableState(_poolManager);
```



### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked

*We force the onlyPoolManager modifier by exposing a virtual function after the onlyPoolManager check.*

```solidity
function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory);
```



**Parameters**

| Name   | Type    | Description                                    |
| ------ | ------- | ---------------------------------------------- |
| `data` | `bytes` | The data that was passed to the call to unlock |

**Returns**

| Name     | Type    | Description                                                |
| -------- | ------- | ---------------------------------------------------------- |
| `<none>` | `bytes` | Any data that you want to be returned from the unlock call |

### _unlockCallback

*to be implemented by the child contract, to safely guarantee the logic is only executed by the PoolManager*

```solidity
function _unlockCallback(bytes calldata data) internal virtual returns (bytes memory);
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherybase[UnorderedNonce](https://docs.uniswap.org/contracts/v4/reference/periphery/base/UnorderedNonce)

# UnorderedNonce

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/UnorderedNonce.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IUnorderedNonce](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IUnorderedNonce)

Contract state and methods for using unordered nonces in signatures

## State Variables

### nonces

mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap

*word is at most type(uint248).max*

```solidity
mapping(address owner => mapping(uint256 word => uint256 bitmap)) public nonces;
```



## Functions

### _useUnorderedNonce

Consume a nonce, reverting if it has already been used

```solidity
function _useUnorderedNonce(address owner, uint256 nonce) internal;
```



**Parameters**

| Name    | Type      | Description                                                  |
| ------- | --------- | ------------------------------------------------------------ |
| `owner` | `address` | address, the owner/signer of the nonce                       |
| `nonce` | `uint256` | uint256, the nonce to consume. The top 248 bits are the word, the bottom 8 bits indicate the bit position |

### revokeNonce

Revoke a nonce by spending it, preventing it from being used again

*Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce*

```solidity
function revokeNonce(uint256 nonce) external payable;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IEIP712_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IEIP712_v4)

# IEIP712_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IEIP712_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the EIP712 contract

## Functions

### DOMAIN_SEPARATOR

Returns the domain separator for the current chain.

```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```



**Returns**

| Name     | Type      | Description                  |
| -------- | --------- | ---------------------------- |
| `<none>` | `bytes32` | bytes32 The domain separator |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IERC721Permit_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IERC721Permit_v4)

# IERC721Permit_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IERC721Permit_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the ERC721Permit_v4 contract

## Functions

### permit

Approve of a specific token ID for spending by spender via signature

*payable so it can be multicalled with NATIVE related actions*

```solidity
function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)
    external
    payable;
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `spender`   | `address` | The account that is being approved                           |
| `tokenId`   | `uint256` | The ID of the token that is being approved for spending      |
| `deadline`  | `uint256` | The deadline timestamp by which the call must be mined for the approve to work |
| `nonce`     | `uint256` | a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word |
| `signature` | `bytes`   | Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v) |

### permitForAll

Set an operator with full permission to an owner's tokens via signature

*payable so it can be multicalled with NATIVE related actions*

```solidity
function permitForAll(
    address owner,
    address operator,
    bool approved,
    uint256 deadline,
    uint256 nonce,
    bytes calldata signature
) external payable;
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `owner`     | `address` | The address that is setting the operator                     |
| `operator`  | `address` | The address that will be set as an operator for the owner    |
| `approved`  | `bool`    | The permission to set on the operator                        |
| `deadline`  | `uint256` | The deadline timestamp by which the call must be mined for the approve to work |
| `nonce`     | `uint256` | a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word |
| `signature` | `bytes`   | Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v) |

## Errors

### SignatureDeadlineExpired

```solidity
error SignatureDeadlineExpired();
```



### NoSelfPermit

```solidity
error NoSelfPermit();
```



### Unauthorized

```solidity
error Unauthorized();
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState)

# IImmutableState

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IImmutableState.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the ImmutableState contract

## Functions

### poolManager

The Uniswap v4 PoolManager contract

```solidity
function poolManager() external view returns (IPoolManager);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IMulticall_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IMulticall_v4)

# IMulticall_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IMulticall_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Multicall_v4 contract

## Functions

### multicall

Call multiple functions in the current contract and return the data from all of them if they all succeed

*The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether. Subcalls can instead use `address(this).value` to see the available ETH, and consume it using {value: x}.*

```solidity
function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
```



**Parameters**

| Name   | Type      | Description                                                  |
| ------ | --------- | ------------------------------------------------------------ |
| `data` | `bytes[]` | The encoded function data for each of the calls to make to this contract |

**Returns**

| Name      | Type      | Description                                           |
| --------- | --------- | ----------------------------------------------------- |
| `results` | `bytes[]` | The results from each of the calls passed in via data |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[INotifier](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/INotifier)

# INotifier

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/INotifier.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Notifier contract

## Functions

### subscriber

Returns the subscriber for a respective position

```solidity
function subscriber(uint256 tokenId) external view returns (ISubscriber subscriber);
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

**Returns**

| Name         | Type          | Description             |
| ------------ | ------------- | ----------------------- |
| `subscriber` | `ISubscriber` | the subscriber contract |

### subscribe

Enables the subscriber to receive notifications for a respective position

*Calling subscribe when a position is already subscribed will revert*

*payable so it can be multicalled with NATIVE related actions*

*will revert if pool manager is locked*

```solidity
function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data) external payable;
```



**Parameters**

| Name            | Type      | Description                                                  |
| --------------- | --------- | ------------------------------------------------------------ |
| `tokenId`       | `uint256` | the ERC721 tokenId                                           |
| `newSubscriber` | `address` | the address of the subscriber contract                       |
| `data`          | `bytes`   | caller-provided data that's forwarded to the subscriber contract |

### unsubscribe

Removes the subscriber from receiving notifications for a respective position

*Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified*

*payable so it can be multicalled with NATIVE related actions*

*Must always allow a user to unsubscribe. In the case of a malicious subscriber, a user can always unsubscribe safely, ensuring liquidity is always modifiable.*

*will revert if pool manager is locked*

```solidity
function unsubscribe(uint256 tokenId) external payable;
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

### unsubscribeGasLimit

Returns and determines the maximum allowable gas-used for notifying unsubscribe

```solidity
function unsubscribeGasLimit() external view returns (uint256);
```



**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `<none>` | `uint256` | uint256 the maximum gas limit when notifying a subscriber's `notifyUnsubscribe` function |

## Events

### Subscription

Emitted on a successful call to subscribe

```solidity
event Subscription(uint256 indexed tokenId, address indexed subscriber);
```



### Unsubscription

Emitted on a successful call to unsubscribe

```solidity
event Unsubscription(uint256 indexed tokenId, address indexed subscriber);
```



## Errors

### NotSubscribed

Thrown when unsubscribing without a subscriber

```solidity
error NotSubscribed();
```



### NoCodeSubscriber

Thrown when a subscriber does not have code

```solidity
error NoCodeSubscriber();
```



### GasLimitTooLow

Thrown when a user specifies a gas limit too low to avoid valid unsubscribe notifications

```solidity
error GasLimitTooLow();
```



### SubscriptionReverted

Wraps the revert message of the subscriber contract on a reverting subscription

```solidity
error SubscriptionReverted(address subscriber, bytes reason);
```



### ModifyLiquidityNotificationReverted

Wraps the revert message of the subscriber contract on a reverting modify liquidity notification

```solidity
error ModifyLiquidityNotificationReverted(address subscriber, bytes reason);
```



### BurnNotificationReverted

Wraps the revert message of the subscriber contract on a reverting burn notification

```solidity
error BurnNotificationReverted(address subscriber, bytes reason);
```



### AlreadySubscribed

Thrown when a tokenId already has a subscriber

```solidity
error AlreadySubscribed(uint256 tokenId, address subscriber);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IPermit2Forwarder](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPermit2Forwarder)

# IPermit2Forwarder

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPermit2Forwarder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Permit2Forwarder contract

## Functions

### permit

allows forwarding a single permit to permit2

*this function is payable to allow multicall with NATIVE based actions*

```solidity
function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```



**Parameters**

| Name           | Type                              | Description                                            |
| -------------- | --------------------------------- | ------------------------------------------------------ |
| `owner`        | `address`                         | the owner of the tokens                                |
| `permitSingle` | `IAllowanceTransfer.PermitSingle` | the permit data                                        |
| `signature`    | `bytes`                           | the signature of the permit; abi.encodePacked(r, s, v) |

**Returns**

| Name  | Type    | Description                                                  |
| ----- | ------- | ------------------------------------------------------------ |
| `err` | `bytes` | the error returned by a reverting permit call, empty if successful |

### permitBatch

allows forwarding batch permits to permit2

*this function is payable to allow multicall with NATIVE based actions*

```solidity
function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```



**Parameters**

| Name           | Type                             | Description                                            |
| -------------- | -------------------------------- | ------------------------------------------------------ |
| `owner`        | `address`                        | the owner of the tokens                                |
| `_permitBatch` | `IAllowanceTransfer.PermitBatch` | a batch of approvals                                   |
| `signature`    | `bytes`                          | the signature of the permit; abi.encodePacked(r, s, v) |

**Returns**

| Name  | Type    | Description                                                  |
| ----- | ------- | ------------------------------------------------------------ |
| `err` | `bytes` | the error returned by a reverting permit call, empty if successful |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IPoolInitializer_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4)

# IPoolInitializer_v4

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPoolInitializer_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the PoolInitializer_v4 contract

## Functions

### initializePool

Initialize a Uniswap v4 Pool

*If the pool is already initialized, this function will not revert and just return type(int24).max*

```solidity
function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);
```



**Parameters**

| Name           | Type      | Description                                                  |
| -------------- | --------- | ------------------------------------------------------------ |
| `key`          | `PoolKey` | The PoolKey of the pool to initialize                        |
| `sqrtPriceX96` | `uint160` | The initial starting price of the pool, expressed as a sqrtPriceX96 |

**Returns**

| Name     | Type    | Description                                                  |
| -------- | ------- | ------------------------------------------------------------ |
| `<none>` | `int24` | The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IPositionDescriptor](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPositionDescriptor)

# IPositionDescriptor

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPositionDescriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the PositionDescriptor contract

## Functions

### tokenURI

Produces the URI describing a particular token ID

*Note this URI may be a data: URI with the JSON contents directly inlined*

```solidity
function tokenURI(IPositionManager positionManager, uint256 tokenId) external view returns (string memory);
```



**Parameters**

| Name              | Type               | Description                                                  |
| ----------------- | ------------------ | ------------------------------------------------------------ |
| `positionManager` | `IPositionManager` | The position manager for which to describe the token         |
| `tokenId`         | `uint256`          | The ID of the token for which to produce a description, which may not be valid |

**Returns**

| Name     | Type     | Description                              |
| -------- | -------- | ---------------------------------------- |
| `<none>` | `string` | The URI of the ERC721-compliant metadata |

### flipRatio

Returns true if currency0 has higher priority than currency1

```solidity
function flipRatio(address currency0, address currency1) external view returns (bool);
```



**Parameters**

| Name        | Type      | Description                 |
| ----------- | --------- | --------------------------- |
| `currency0` | `address` | The first currency address  |
| `currency1` | `address` | The second currency address |

**Returns**

| Name     | Type   | Description                                          |
| -------- | ------ | ---------------------------------------------------- |
| `<none>` | `bool` | True if currency0 has higher priority than currency1 |

### currencyRatioPriority

Returns the priority of a currency. For certain currencies on mainnet, the smaller the currency, the higher the priority And those with the higher priority values (more positive values) will be in the numerator of the price ratio

```solidity
function currencyRatioPriority(address currency) external view returns (int256);
```



**Parameters**

| Name       | Type      | Description          |
| ---------- | --------- | -------------------- |
| `currency` | `address` | The currency address |

**Returns**

| Name     | Type     | Description                  |
| -------- | -------- | ---------------------------- |
| `<none>` | `int256` | The priority of the currency |

### wrappedNative

```solidity
function wrappedNative() external view returns (address);
```



**Returns**

| Name     | Type      | Description                                  |
| -------- | --------- | -------------------------------------------- |
| `<none>` | `address` | The wrapped native token for this descriptor |

### nativeCurrencyLabel

```solidity
function nativeCurrencyLabel() external view returns (string memory);
```



**Returns**

| Name     | Type     | Description                                   |
| -------- | -------- | --------------------------------------------- |
| `<none>` | `string` | The native currency label for this descriptor |

### poolManager

```solidity
function poolManager() external view returns (IPoolManager);
```



**Returns**

| Name     | Type           | Description                          |
| -------- | -------------- | ------------------------------------ |
| `<none>` | `IPoolManager` | The pool manager for this descriptor |

## Errors

### InvalidTokenId

```solidity
error InvalidTokenId(uint256 tokenId);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IPositionManager](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPositionManager)

# IPositionManager

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPositionManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [INotifier](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/INotifier), [IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState), [IERC721Permit_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IERC721Permit_v4), [IEIP712_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IEIP712_v4), [IMulticall_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IMulticall_v4), [IPoolInitializer_v4](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4), [IUnorderedNonce](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IUnorderedNonce), [IPermit2Forwarder](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IPermit2Forwarder)

Interface for the PositionManager contract

## Functions

### modifyLiquidities

Unlocks Uniswap v4 PoolManager and batches actions for modifying liquidity

*This is the standard entrypoint for the PositionManager*

```solidity
function modifyLiquidities(bytes calldata unlockData, uint256 deadline) external payable;
```



**Parameters**

| Name         | Type      | Description                                                 |
| ------------ | --------- | ----------------------------------------------------------- |
| `unlockData` | `bytes`   | is an encoding of actions, and parameters for those actions |
| `deadline`   | `uint256` | is the deadline for the batched actions to be executed      |

### modifyLiquiditiesWithoutUnlock

Batches actions for modifying liquidity without unlocking v4 PoolManager

*This must be called by a contract that has already unlocked the v4 PoolManager*

```solidity
function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params) external payable;
```



**Parameters**

| Name      | Type      | Description                               |
| --------- | --------- | ----------------------------------------- |
| `actions` | `bytes`   | the actions to perform                    |
| `params`  | `bytes[]` | the parameters to provide for the actions |

### nextTokenId

Used to get the ID that will be used for the next minted liquidity position

```solidity
function nextTokenId() external view returns (uint256);
```



**Returns**

| Name     | Type      | Description               |
| -------- | --------- | ------------------------- |
| `<none>` | `uint256` | uint256 The next token ID |

### getPositionLiquidity

Returns the liquidity of a position

*this value can be processed as an amount0 and amount1 by using the LiquidityAmounts library*

```solidity
function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity);
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

**Returns**

| Name        | Type      | Description                                    |
| ----------- | --------- | ---------------------------------------------- |
| `liquidity` | `uint128` | the position's liquidity, as a liquidityAmount |

### getPoolAndPositionInfo

Returns the pool key and position info of a position

```solidity
function getPoolAndPositionInfo(uint256 tokenId) external view returns (PoolKey memory, PositionInfo);
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `PoolKey`      | poolKey the pool key of the position                         |
| `<none>` | `PositionInfo` | PositionInfo a uint256 packed value holding information about the position including the range (tickLower, tickUpper) |

### positionInfo

Returns the position info of a position

```solidity
function positionInfo(uint256 tokenId) external view returns (PositionInfo);
```



**Parameters**

| Name      | Type      | Description        |
| --------- | --------- | ------------------ |
| `tokenId` | `uint256` | the ERC721 tokenId |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `PositionInfo` | a uint256 packed value holding information about the position including the range (tickLower, tickUpper) |

## Errors

### NotApproved

Thrown when the caller is not approved to modify a position

```solidity
error NotApproved(address caller);
```



### DeadlinePassed

Thrown when the block.timestamp exceeds the user-provided deadline

```solidity
error DeadlinePassed(uint256 deadline);
```



### PoolManagerMustBeLocked

Thrown when calling transfer, subscribe, or unsubscribe when the PoolManager is unlocked.

*This is to prevent hooks from being able to trigger notifications at the same time the position is being modified.*

```solidity
error PoolManagerMustBeLocked();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IStateView](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IStateView)

# IStateView

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IStateView.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState)

Interface for the StateView contract

## Functions

### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*

```solidity
function getSlot0(PoolId poolId)
    external
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name           | Type      | Description                                                 |
| -------------- | --------- | ----------------------------------------------------------- |
| `sqrtPriceX96` | `uint160` | The square root of the price of the pool, in Q96 precision. |
| `tick`         | `int24`   | The current tick of the pool.                               |
| `protocolFee`  | `uint24`  | The protocol fee of the pool.                               |
| `lpFee`        | `uint24`  | The swap fee of the pool.                                   |

### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*

```solidity
function getTickInfo(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name     | Type     | Description                           |
| -------- | -------- | ------------------------------------- |
| `poolId` | `PoolId` | The ID of the pool.                   |
| `tick`   | `int24`  | The tick to retrieve information for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross`        | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`          | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*

```solidity
function getTickLiquidity(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```



**Parameters**

| Name     | Type     | Description                         |
| -------- | -------- | ----------------------------------- |
| `poolId` | `PoolId` | The ID of the pool.                 |
| `tick`   | `int24`  | The tick to retrieve liquidity for. |

**Returns**

| Name             | Type      | Description                                                  |
| ---------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross` | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`   | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |

### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*

```solidity
function getTickFeeGrowthOutside(PoolId poolId, int24 tick)
    external
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name     | Type     | Description                          |
| -------- | -------- | ------------------------------------ |
| `poolId` | `PoolId` | The ID of the pool.                  |
| `tick`   | `int24`  | The tick to retrieve fee growth for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*

```solidity
function getFeeGrowthGlobals(PoolId poolId)
    external
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name               | Type      | Description                       |
| ------------------ | --------- | --------------------------------- |
| `feeGrowthGlobal0` | `uint256` | The global fee growth for token0. |
| `feeGrowthGlobal1` | `uint256` | The global fee growth for token1. |

### getLiquidity

Retrieves the total liquidity of a pool.

*Corresponds to pools[poolId].liquidity*

```solidity
function getLiquidity(PoolId poolId) external view returns (uint128 liquidity);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name        | Type      | Description                |
| ----------- | --------- | -------------------------- |
| `liquidity` | `uint128` | The liquidity of the pool. |

### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*

```solidity
function getTickBitmap(PoolId poolId, int16 tick) external view returns (uint256 tickBitmap);
```



**Parameters**

| Name     | Type     | Description                          |
| -------- | -------- | ------------------------------------ |
| `poolId` | `PoolId` | The ID of the pool.                  |
| `tick`   | `int16`  | The tick to retrieve the bitmap for. |

**Returns**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `tickBitmap` | `uint256` | The bitmap of the tick. |

### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(PoolId poolId, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `poolId`    | `PoolId`  | The ID of the pool.                                          |
| `owner`     | `address` | The owner of the liquidity position.                         |
| `tickLower` | `int24`   | The lower tick of the liquidity range.                       |
| `tickUpper` | `int24`   | The upper tick of the liquidity range.                       |
| `salt`      | `bytes32` | The bytes32 randomness to further distinguish position state. |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionInfo

Retrieves the position information of a pool at a specific position ID.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(PoolId poolId, bytes32 positionId)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `poolId`     | `PoolId`  | The ID of the pool.     |
| `positionId` | `bytes32` | The ID of the position. |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieving liquidity as compared to getPositionInfo*

```solidity
function getPositionLiquidity(PoolId poolId, bytes32 positionId) external view returns (uint128 liquidity);
```



**Parameters**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `poolId`     | `PoolId`  | The ID of the pool.     |
| `positionId` | `bytes32` | The ID of the position. |

**Returns**

| Name        | Type      | Description                    |
| ----------- | --------- | ------------------------------ |
| `liquidity` | `uint128` | The liquidity of the position. |

### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.Info is cached and can become stale. This function will calculate the up to date feeGrowthInside*

```solidity
function getFeeGrowthInside(PoolId poolId, int24 tickLower, int24 tickUpper)
    external
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```



**Parameters**

| Name        | Type     | Description                  |
| ----------- | -------- | ---------------------------- |
| `poolId`    | `PoolId` | The ID of the pool.          |
| `tickLower` | `int24`  | The lower tick of the range. |
| `tickUpper` | `int24`  | The upper tick of the range. |

**Returns**

| Name                   | Type      | Description                                      |
| ---------------------- | --------- | ------------------------------------------------ |
| `feeGrowthInside0X128` | `uint256` | The fee growth inside the tick range for token0. |
| `feeGrowthInside1X128` | `uint256` | The fee growth inside the tick range for token1. |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[ISubscriber](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/ISubscriber)

# ISubscriber

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/ISubscriber.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface that a Subscriber contract should implement to receive updates from the v4 position manager

## Functions

### notifySubscribe

Called when a position subscribes to this subscriber contract

```solidity
function notifySubscribe(uint256 tokenId, bytes memory data) external;
```



**Parameters**

| Name      | Type      | Description                             |
| --------- | --------- | --------------------------------------- |
| `tokenId` | `uint256` | the token ID of the position            |
| `data`    | `bytes`   | additional data passed in by the caller |

### notifyUnsubscribe

Called when a position unsubscribes from the subscriber

*This call's gas is capped at `unsubscribeGasLimit` (set at deployment)*

*Because of EIP-150, solidity may only allocate 63/64 of gasleft()*

```solidity
function notifyUnsubscribe(uint256 tokenId) external;
```



**Parameters**

| Name      | Type      | Description                  |
| --------- | --------- | ---------------------------- |
| `tokenId` | `uint256` | the token ID of the position |

### notifyBurn

Called when a position is burned

```solidity
function notifyBurn(uint256 tokenId, address owner, PositionInfo info, uint256 liquidity, BalanceDelta feesAccrued)
    external;
```



**Parameters**

| Name          | Type           | Description                                                 |
| ------------- | -------------- | ----------------------------------------------------------- |
| `tokenId`     | `uint256`      | the token ID of the position                                |
| `owner`       | `address`      | the current owner of the tokenId                            |
| `info`        | `PositionInfo` | information about the position                              |
| `liquidity`   | `uint256`      | the amount of liquidity decreased in the position, may be 0 |
| `feesAccrued` | `BalanceDelta` | the fees accrued by the position if liquidity was decreased |

### notifyModifyLiquidity

Called when a position modifies its liquidity or collects fees

*Note that feesAccrued can be artificially inflated by a malicious user Pools with a single liquidity position can inflate feeGrowthGlobal (and consequently feesAccrued) by donating to themselves; atomically donating and collecting fees within the same unlockCallback may further inflate feeGrowthGlobal/feesAccrued*

```solidity
function notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) external;
```



**Parameters**

| Name              | Type           | Description                                                  |
| ----------------- | -------------- | ------------------------------------------------------------ |
| `tokenId`         | `uint256`      | the token ID of the position                                 |
| `liquidityChange` | `int256`       | the change in liquidity on the underlying position           |
| `feesAccrued`     | `BalanceDelta` | the fees to be collected from the position as a result of the modifyLiquidity call |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IUniswapV4DeployerCompetition](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IUniswapV4DeployerCompetition)

# IUniswapV4DeployerCompetition

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IUniswapV4DeployerCompetition.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the UniswapV4DeployerCompetition contract

## Functions

### updateBestAddress

Updates the best address if the new address has a better vanity score

*The first 20 bytes of the salt must be either address(0) or msg.sender*

```solidity
function updateBestAddress(bytes32 salt) external;
```



**Parameters**

| Name   | Type      | Description                                             |
| ------ | --------- | ------------------------------------------------------- |
| `salt` | `bytes32` | The salt to use to compute the new address with CREATE2 |

### deploy

deploys the Uniswap v4 PoolManager contract

*The bytecode must match the initCodeHash*

```solidity
function deploy(bytes memory bytecode) external;
```



**Parameters**

| Name       | Type    | Description                                         |
| ---------- | ------- | --------------------------------------------------- |
| `bytecode` | `bytes` | The bytecode of the Uniswap v4 PoolManager contract |

## Events

### NewAddressFound

```solidity
event NewAddressFound(address indexed bestAddress, address indexed submitter, uint256 score);
```



## Errors

### InvalidBytecode

```solidity
error InvalidBytecode();
```



### CompetitionNotOver

```solidity
error CompetitionNotOver(uint256 currentTime, uint256 deadline);
```



### CompetitionOver

```solidity
error CompetitionOver(uint256 currentTime, uint256 deadline);
```



### NotAllowedToDeploy

```solidity
error NotAllowedToDeploy(address sender, address deployer);
```



### WorseAddress

```solidity
error WorseAddress(address newAddress, address bestAddress, uint256 newScore, uint256 bestScore);
```



### InvalidSender

```solidity
error InvalidSender(bytes32 salt, address sender);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IUnorderedNonce](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IUnorderedNonce)

# IUnorderedNonce

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IUnorderedNonce.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the UnorderedNonce contract

## Functions

### nonces

mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap

*word is at most type(uint248).max*

```solidity
function nonces(address owner, uint256 word) external view returns (uint256);
```



### revokeNonce

Revoke a nonce by spending it, preventing it from being used again

*Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce*

*payable so it can be multicalled with native-token related actions*

```solidity
function revokeNonce(uint256 nonce) external payable;
```



## Errors

### NonceAlreadyUsed

```solidity
error NonceAlreadyUsed();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IV4Quoter](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IV4Quoter)

# IV4Quoter

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IV4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState)

Interface for the V4Quoter contract

## Functions

### quoteExactInputSingle

Returns the delta amounts for a given exact input swap of a single pool

```solidity
function quoteExactInputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountOut, uint256 gasEstimate);
```



**Parameters**

| Name     | Type                     | Description                                                  |
| -------- | ------------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactSingleParams` | The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired input amount hookData arbitrary hookData to pass into the associated hooks |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountOut`   | `uint256` | The output quote for the exactIn swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactInput

Returns the delta amounts along the swap path for a given exact input swap

```solidity
function quoteExactInput(QuoteExactParams memory params) external returns (uint256 amountOut, uint256 gasEstimate);
```



**Parameters**

| Name     | Type               | Description                                                  |
| -------- | ------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactParams` | the params for the quote, encoded as 'QuoteExactParams' currencyIn The input currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired input amount |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountOut`   | `uint256` | The output quote for the exactIn swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactOutputSingle

Returns the delta amounts for a given exact output swap of a single pool

```solidity
function quoteExactOutputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountIn, uint256 gasEstimate);
```



**Parameters**

| Name     | Type                     | Description                                                  |
| -------- | ------------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactSingleParams` | The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired output amount hookData arbitrary hookData to pass into the associated hooks |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountIn`    | `uint256` | The input quote for the exactOut swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactOutput

Returns the delta amounts along the swap path for a given exact output swap

```solidity
function quoteExactOutput(QuoteExactParams memory params) external returns (uint256 amountIn, uint256 gasEstimate);
```



**Parameters**

| Name     | Type               | Description                                                  |
| -------- | ------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactParams` | the params for the quote, encoded as 'QuoteExactParams' currencyOut The output currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired output amount |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountIn`    | `uint256` | The input quote for the exactOut swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

## Structs

### QuoteExactSingleParams

```solidity
struct QuoteExactSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 exactAmount;
    bytes hookData;
}
```



### QuoteExactParams

```solidity
struct QuoteExactParams {
    Currency exactCurrency;
    PathKey[] path;
    uint128 exactAmount;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IV4Router](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IV4Router)

# IV4Router

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IV4Router.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IImmutableState)

Interface for the V4Router contract

## Errors

### V4TooLittleReceived

Emitted when an exactInput swap does not receive its minAmountOut

```solidity
error V4TooLittleReceived(uint256 minAmountOutReceived, uint256 amountReceived);
```



### V4TooMuchRequested

Emitted when an exactOutput is asked for more than its maxAmountIn

```solidity
error V4TooMuchRequested(uint256 maxAmountInRequested, uint256 amountRequested);
```



## Structs

### ExactInputSingleParams

Parameters for a single-hop exact-input swap

```solidity
struct ExactInputSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 amountIn;
    uint128 amountOutMinimum;
    bytes hookData;
}
```



### ExactInputParams

Parameters for a multi-hop exact-input swap

```solidity
struct ExactInputParams {
    Currency currencyIn;
    PathKey[] path;
    uint128 amountIn;
    uint128 amountOutMinimum;
}
```



### ExactOutputSingleParams

Parameters for a single-hop exact-output swap

```solidity
struct ExactOutputSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 amountOut;
    uint128 amountInMaximum;
    bytes hookData;
}
```



### ExactOutputParams

Parameters for a multi-hop exact-output swap

```solidity
struct ExactOutputParams {
    Currency currencyOut;
    PathKey[] path;
    uint128 amountOut;
    uint128 amountInMaximum;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryinterfaces[IWETH9](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IWETH9)

# IWETH9

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/external/IWETH9.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** IERC20

## Functions

### deposit

Deposit ether to get wrapped ether

```solidity
function deposit() external payable;
```



### withdraw

Withdraw wrapped ether to get ether

```solidity
function withdraw(uint256) external;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylens[StateView](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/StateView)

# StateView

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/lens/StateView.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState), [IStateView](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IStateView)

A view only contract wrapping the StateLibrary.sol library for reading storage in v4-core.

*The contract is intended for offchain clients. Use StateLibrary.sol directly if reading state onchain.*

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) ImmutableState(_poolManager);
```



### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*

```solidity
function getSlot0(PoolId poolId)
    external
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name           | Type      | Description                                                 |
| -------------- | --------- | ----------------------------------------------------------- |
| `sqrtPriceX96` | `uint160` | The square root of the price of the pool, in Q96 precision. |
| `tick`         | `int24`   | The current tick of the pool.                               |
| `protocolFee`  | `uint24`  | The protocol fee of the pool.                               |
| `lpFee`        | `uint24`  | The swap fee of the pool.                                   |

### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*

```solidity
function getTickInfo(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name     | Type     | Description                           |
| -------- | -------- | ------------------------------------- |
| `poolId` | `PoolId` | The ID of the pool.                   |
| `tick`   | `int24`  | The tick to retrieve information for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross`        | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`          | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*

```solidity
function getTickLiquidity(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```



**Parameters**

| Name     | Type     | Description                         |
| -------- | -------- | ----------------------------------- |
| `poolId` | `PoolId` | The ID of the pool.                 |
| `tick`   | `int24`  | The tick to retrieve liquidity for. |

**Returns**

| Name             | Type      | Description                                                  |
| ---------------- | --------- | ------------------------------------------------------------ |
| `liquidityGross` | `uint128` | The total position liquidity that references this tick       |
| `liquidityNet`   | `int128`  | The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left) |

### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*

```solidity
function getTickFeeGrowthOutside(PoolId poolId, int24 tick)
    external
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```



**Parameters**

| Name     | Type     | Description                          |
| -------- | -------- | ------------------------------------ |
| `poolId` | `PoolId` | The ID of the pool.                  |
| `tick`   | `int24`  | The tick to retrieve fee growth for. |

**Returns**

| Name                    | Type      | Description                                                  |
| ----------------------- | --------- | ------------------------------------------------------------ |
| `feeGrowthOutside0X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |
| `feeGrowthOutside1X128` | `uint256` | fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick) |

### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*

```solidity
function getFeeGrowthGlobals(PoolId poolId)
    external
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name               | Type      | Description                       |
| ------------------ | --------- | --------------------------------- |
| `feeGrowthGlobal0` | `uint256` | The global fee growth for token0. |
| `feeGrowthGlobal1` | `uint256` | The global fee growth for token1. |

### getLiquidity

Retrieves the total liquidity of a pool.

*Corresponds to pools[poolId].liquidity*

```solidity
function getLiquidity(PoolId poolId) external view returns (uint128 liquidity);
```



**Parameters**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `poolId` | `PoolId` | The ID of the pool. |

**Returns**

| Name        | Type      | Description                |
| ----------- | --------- | -------------------------- |
| `liquidity` | `uint128` | The liquidity of the pool. |

### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*

```solidity
function getTickBitmap(PoolId poolId, int16 tick) external view returns (uint256 tickBitmap);
```



**Parameters**

| Name     | Type     | Description                          |
| -------- | -------- | ------------------------------------ |
| `poolId` | `PoolId` | The ID of the pool.                  |
| `tick`   | `int16`  | The tick to retrieve the bitmap for. |

**Returns**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `tickBitmap` | `uint256` | The bitmap of the tick. |

### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(PoolId poolId, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name        | Type      | Description                                                  |
| ----------- | --------- | ------------------------------------------------------------ |
| `poolId`    | `PoolId`  | The ID of the pool.                                          |
| `owner`     | `address` | The owner of the liquidity position.                         |
| `tickLower` | `int24`   | The lower tick of the liquidity range.                       |
| `tickUpper` | `int24`   | The upper tick of the liquidity range.                       |
| `salt`      | `bytes32` | The bytes32 randomness to further distinguish position state. |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*

```solidity
function getPositionInfo(PoolId poolId, bytes32 positionId)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```



**Parameters**

| Name         | Type      | Description         |
| ------------ | --------- | ------------------- |
| `poolId`     | `PoolId`  | The ID of the pool. |
| `positionId` | `bytes32` |                     |

**Returns**

| Name                       | Type      | Description                                    |
| -------------------------- | --------- | ---------------------------------------------- |
| `liquidity`                | `uint128` | The liquidity of the position.                 |
| `feeGrowthInside0LastX128` | `uint256` | The fee growth inside the position for token0. |
| `feeGrowthInside1LastX128` | `uint256` | The fee growth inside the position for token1. |

### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieving liquidity as compared to getPositionInfo*

```solidity
function getPositionLiquidity(PoolId poolId, bytes32 positionId) external view returns (uint128 liquidity);
```



**Parameters**

| Name         | Type      | Description             |
| ------------ | --------- | ----------------------- |
| `poolId`     | `PoolId`  | The ID of the pool.     |
| `positionId` | `bytes32` | The ID of the position. |

**Returns**

| Name        | Type      | Description                    |
| ----------- | --------- | ------------------------------ |
| `liquidity` | `uint128` | The liquidity of the position. |

### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.Info is cached and can become stale. This function will calculate the up to date feeGrowthInside*

```solidity
function getFeeGrowthInside(PoolId poolId, int24 tickLower, int24 tickUpper)
    external
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```



**Parameters**

| Name        | Type     | Description                  |
| ----------- | -------- | ---------------------------- |
| `poolId`    | `PoolId` | The ID of the pool.          |
| `tickLower` | `int24`  | The lower tick of the range. |
| `tickUpper` | `int24`  | The upper tick of the range. |

**Returns**

| Name                   | Type      | Description                                      |
| ---------------------- | --------- | ------------------------------------------------ |
| `feeGrowthInside0X128` | `uint256` | The fee growth inside the tick range for token0. |
| `feeGrowthInside1X128` | `uint256` | The fee growth inside the tick range for token1. |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylens[V4Quoter](https://docs.uniswap.org/contracts/v4/reference/periphery/lens/V4Quoter)

# V4Quoter

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/lens/V4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** [IV4Quoter](https://docs.uniswap.org/contracts/v4/reference/periphery/interfaces/IV4Quoter), [BaseV4Quoter](https://docs.uniswap.org/contracts/v4/reference/periphery/base/BaseV4Quoter)

Supports quoting the delta amounts for exact input or exact output swaps.

*These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.*

## Functions

### constructor

```solidity
constructor(IPoolManager _poolManager) BaseV4Quoter(_poolManager);
```



### quoteExactInputSingle

Returns the delta amounts for a given exact input swap of a single pool

```solidity
function quoteExactInputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountOut, uint256 gasEstimate);
```



**Parameters**

| Name     | Type                     | Description                                                  |
| -------- | ------------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactSingleParams` | The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired input amount hookData arbitrary hookData to pass into the associated hooks |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountOut`   | `uint256` | The output quote for the exactIn swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactInput

Returns the delta amounts along the swap path for a given exact input swap

```solidity
function quoteExactInput(QuoteExactParams memory params) external returns (uint256 amountOut, uint256 gasEstimate);
```



**Parameters**

| Name     | Type               | Description                                                  |
| -------- | ------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactParams` | the params for the quote, encoded as 'QuoteExactParams' currencyIn The input currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired input amount |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountOut`   | `uint256` | The output quote for the exactIn swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactOutputSingle

Returns the delta amounts for a given exact output swap of a single pool

```solidity
function quoteExactOutputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountIn, uint256 gasEstimate);
```



**Parameters**

| Name     | Type                     | Description                                                  |
| -------- | ------------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactSingleParams` | The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired output amount hookData arbitrary hookData to pass into the associated hooks |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountIn`    | `uint256` | The input quote for the exactOut swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### quoteExactOutput

Returns the delta amounts along the swap path for a given exact output swap

```solidity
function quoteExactOutput(QuoteExactParams memory params) external returns (uint256 amountIn, uint256 gasEstimate);
```



**Parameters**

| Name     | Type               | Description                                                  |
| -------- | ------------------ | ------------------------------------------------------------ |
| `params` | `QuoteExactParams` | the params for the quote, encoded as 'QuoteExactParams' currencyOut The output currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired output amount |

**Returns**

| Name          | Type      | Description                           |
| ------------- | --------- | ------------------------------------- |
| `amountIn`    | `uint256` | The input quote for the exactOut swap |
| `gasEstimate` | `uint256` | Estimated gas units used for the swap |

### _quoteExactInput

*external function called within the _unlockCallback, to simulate an exact input swap, then revert with the result*

```solidity
function _quoteExactInput(QuoteExactParams calldata params) external selfOnly returns (bytes memory);
```



### _quoteExactInputSingle

*external function called within the _unlockCallback, to simulate a single-hop exact input swap, then revert with the result*

```solidity
function _quoteExactInputSingle(QuoteExactSingleParams calldata params) external selfOnly returns (bytes memory);
```



### _quoteExactOutput

*external function called within the _unlockCallback, to simulate an exact output swap, then revert with the result*

```solidity
function _quoteExactOutput(QuoteExactParams calldata params) external selfOnly returns (bytes memory);
```



### _quoteExactOutputSingle

*external function called within the _unlockCallback, to simulate a single-hop exact output swap, then revert with the result*

```solidity
function _quoteExactOutputSingle(QuoteExactSingleParams calldata params) external selfOnly returns (bytes memory);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[ActionConstants](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/ActionConstants)

# ActionConstants

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/ActionConstants.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Common constants used in actions

*Constants are gas efficient alternatives to their literal values*

## State Variables

### OPEN_DELTA

used to signal that an action should use the input value of the open delta on the pool manager or of the balance that the contract holds

```solidity
uint128 internal constant OPEN_DELTA = 0;
```



### CONTRACT_BALANCE

used to signal that an action should use the contract's entire balance of a currency This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.

```solidity
uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;
```



### MSG_SENDER

used to signal that the recipient of an action should be the msgSender

```solidity
address internal constant MSG_SENDER = address(1);
```



### ADDRESS_THIS

used to signal that the recipient of an action should be the address(this)

```solidity
address internal constant ADDRESS_THIS = address(2);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[Actions](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/Actions)

# Actions

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Actions.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Library to define different pool actions.

*These are suggested common commands, however additional commands should be defined as required Some of these actions are not supported in the Router contracts or Position Manager contracts, but are left as they may be helpful commands for other peripheral contracts.*

## State Variables

### INCREASE_LIQUIDITY

```solidity
uint256 internal constant INCREASE_LIQUIDITY = 0x00;
```



### DECREASE_LIQUIDITY

```solidity
uint256 internal constant DECREASE_LIQUIDITY = 0x01;
```



### MINT_POSITION

```solidity
uint256 internal constant MINT_POSITION = 0x02;
```



### BURN_POSITION

```solidity
uint256 internal constant BURN_POSITION = 0x03;
```



### INCREASE_LIQUIDITY_FROM_DELTAS

```solidity
uint256 internal constant INCREASE_LIQUIDITY_FROM_DELTAS = 0x04;
```



### MINT_POSITION_FROM_DELTAS

```solidity
uint256 internal constant MINT_POSITION_FROM_DELTAS = 0x05;
```



### SWAP_EXACT_IN_SINGLE

```solidity
uint256 internal constant SWAP_EXACT_IN_SINGLE = 0x06;
```



### SWAP_EXACT_IN

```solidity
uint256 internal constant SWAP_EXACT_IN = 0x07;
```



### SWAP_EXACT_OUT_SINGLE

```solidity
uint256 internal constant SWAP_EXACT_OUT_SINGLE = 0x08;
```



### SWAP_EXACT_OUT

```solidity
uint256 internal constant SWAP_EXACT_OUT = 0x09;
```



### DONATE

```solidity
uint256 internal constant DONATE = 0x0a;
```



### SETTLE

```solidity
uint256 internal constant SETTLE = 0x0b;
```



### SETTLE_ALL

```solidity
uint256 internal constant SETTLE_ALL = 0x0c;
```



### SETTLE_PAIR

```solidity
uint256 internal constant SETTLE_PAIR = 0x0d;
```



### TAKE

```solidity
uint256 internal constant TAKE = 0x0e;
```



### TAKE_ALL

```solidity
uint256 internal constant TAKE_ALL = 0x0f;
```



### TAKE_PORTION

```solidity
uint256 internal constant TAKE_PORTION = 0x10;
```



### TAKE_PAIR

```solidity
uint256 internal constant TAKE_PAIR = 0x11;
```



### CLOSE_CURRENCY

```solidity
uint256 internal constant CLOSE_CURRENCY = 0x12;
```



### CLEAR_OR_TAKE

```solidity
uint256 internal constant CLEAR_OR_TAKE = 0x13;
```



### SWEEP

```solidity
uint256 internal constant SWEEP = 0x14;
```



### WRAP

```solidity
uint256 internal constant WRAP = 0x15;
```



### UNWRAP

```solidity
uint256 internal constant UNWRAP = 0x16;
```



### MINT_6909

```solidity
uint256 internal constant MINT_6909 = 0x17;
```



### BURN_6909

```solidity
uint256 internal constant BURN_6909 = 0x18;
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[AddressStringUtil](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/AddressStringUtil)

# AddressStringUtil

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/AddressStringUtil.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

provides utility functions for converting addresses to strings

*Reference: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/AddressStringUtil.sol*

## Functions

### toAsciiString

Converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)

```solidity
function toAsciiString(address addr, uint256 len) internal pure returns (string memory);
```



**Parameters**

| Name   | Type      | Description                    |
| ------ | --------- | ------------------------------ |
| `addr` | `address` | the address to convert         |
| `len`  | `uint256` | the number of bytes to extract |

**Returns**

| Name     | Type     | Description    |
| -------- | -------- | -------------- |
| `<none>` | `string` | the hex string |

### char

Converts a value into is corresponding ASCII character for the hex representation

```solidity
function char(uint8 b) private pure returns (bytes1 c);
```



**Parameters**

| Name | Type    | Description          |
| ---- | ------- | -------------------- |
| `b`  | `uint8` | the value to convert |

**Returns**

| Name | Type     | Description         |
| ---- | -------- | ------------------- |
| `c`  | `bytes1` | the ASCII character |

## Errors

### InvalidAddressLength

```solidity
error InvalidAddressLength(uint256 len);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[BipsLibrary](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/BipsLibrary)

# BipsLibrary

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/BipsLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## State Variables

### BPS_DENOMINATOR

```solidity
uint256 internal constant BPS_DENOMINATOR = 10_000;
```



## Functions

### calculatePortion

```solidity
function calculatePortion(uint256 amount, uint256 bips) internal pure returns (uint256);
```



**Parameters**

| Name     | Type      | Description                                   |
| -------- | --------- | --------------------------------------------- |
| `amount` | `uint256` | The total amount to calculate a percentage of |
| `bips`   | `uint256` | The percentage to calculate, in bips          |

## Errors

### InvalidBips

emitted when an invalid percentage is provided

```solidity
error InvalidBips();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[CalldataDecoder](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/CalldataDecoder)

# CalldataDecoder

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/CalldataDecoder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## State Variables

### OFFSET_OR_LENGTH_MASK

mask used for offsets and lengths to ensure no overflow

*no sane abi encoding will pass in an offset or length greater than type(uint32).max (note that this does deviate from standard solidity behavior and offsets/lengths will be interpreted as mod type(uint32).max which will only impact malicious/buggy callers)*

```solidity
uint256 constant OFFSET_OR_LENGTH_MASK = 0xffffffff;
```



### OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN

```solidity
uint256 constant OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN = 0xffffffe0;
```



### SLICE_ERROR_SELECTOR

equivalent to SliceOutOfBounds.selector, stored in least-significant bits

```solidity
uint256 constant SLICE_ERROR_SELECTOR = 0x3b99b53d;
```



## Functions

### decodeActionsRouterParams

*equivalent to: abi.decode(params, (bytes, bytes[])) in calldata (requires strict abi encoding)*

```solidity
function decodeActionsRouterParams(bytes calldata _bytes)
    internal
    pure
    returns (bytes calldata actions, bytes[] calldata params);
```



### decodeModifyLiquidityParams

*equivalent to: abi.decode(params, (uint256, uint256, uint128, uint128, bytes)) in calldata*

```solidity
function decodeModifyLiquidityParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint256 liquidity, uint128 amount0, uint128 amount1, bytes calldata hookData);
```



### decodeIncreaseLiquidityFromDeltasParams

*equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata*

```solidity
function decodeIncreaseLiquidityFromDeltasParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData);
```



### decodeMintParams

*equivalent to: abi.decode(params, (PoolKey, int24, int24, uint256, uint128, uint128, address, bytes)) in calldata*

```solidity
function decodeMintParams(bytes calldata params)
    internal
    pure
    returns (
        PoolKey calldata poolKey,
        int24 tickLower,
        int24 tickUpper,
        uint256 liquidity,
        uint128 amount0Max,
        uint128 amount1Max,
        address owner,
        bytes calldata hookData
    );
```



### decodeMintFromDeltasParams

*equivalent to: abi.decode(params, (PoolKey, int24, int24, uint128, uint128, address, bytes)) in calldata*

```solidity
function decodeMintFromDeltasParams(bytes calldata params)
    internal
    pure
    returns (
        PoolKey calldata poolKey,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Max,
        uint128 amount1Max,
        address owner,
        bytes calldata hookData
    );
```



### decodeBurnParams

*equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata*

```solidity
function decodeBurnParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData);
```



### decodeSwapExactInParams

*equivalent to: abi.decode(params, (IV4Router.ExactInputParams))*

```solidity
function decodeSwapExactInParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactInputParams calldata swapParams);
```



### decodeSwapExactInSingleParams

*equivalent to: abi.decode(params, (IV4Router.ExactInputSingleParams))*

```solidity
function decodeSwapExactInSingleParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactInputSingleParams calldata swapParams);
```



### decodeSwapExactOutParams

*equivalent to: abi.decode(params, (IV4Router.ExactOutputParams))*

```solidity
function decodeSwapExactOutParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactOutputParams calldata swapParams);
```



### decodeSwapExactOutSingleParams

*equivalent to: abi.decode(params, (IV4Router.ExactOutputSingleParams))*

```solidity
function decodeSwapExactOutSingleParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactOutputSingleParams calldata swapParams);
```



### decodeCurrency

*equivalent to: abi.decode(params, (Currency)) in calldata*

```solidity
function decodeCurrency(bytes calldata params) internal pure returns (Currency currency);
```



### decodeCurrencyPair

*equivalent to: abi.decode(params, (Currency, Currency)) in calldata*

```solidity
function decodeCurrencyPair(bytes calldata params) internal pure returns (Currency currency0, Currency currency1);
```



### decodeCurrencyPairAndAddress

*equivalent to: abi.decode(params, (Currency, Currency, address)) in calldata*

```solidity
function decodeCurrencyPairAndAddress(bytes calldata params)
    internal
    pure
    returns (Currency currency0, Currency currency1, address _address);
```



### decodeCurrencyAndAddress

*equivalent to: abi.decode(params, (Currency, address)) in calldata*

```solidity
function decodeCurrencyAndAddress(bytes calldata params) internal pure returns (Currency currency, address _address);
```



### decodeCurrencyAddressAndUint256

*equivalent to: abi.decode(params, (Currency, address, uint256)) in calldata*

```solidity
function decodeCurrencyAddressAndUint256(bytes calldata params)
    internal
    pure
    returns (Currency currency, address _address, uint256 amount);
```



### decodeCurrencyAndUint256

*equivalent to: abi.decode(params, (Currency, uint256)) in calldata*

```solidity
function decodeCurrencyAndUint256(bytes calldata params) internal pure returns (Currency currency, uint256 amount);
```



### decodeUint256

*equivalent to: abi.decode(params, (uint256)) in calldata*

```solidity
function decodeUint256(bytes calldata params) internal pure returns (uint256 amount);
```



### decodeCurrencyUint256AndBool

*equivalent to: abi.decode(params, (Currency, uint256, bool)) in calldata*

```solidity
function decodeCurrencyUint256AndBool(bytes calldata params)
    internal
    pure
    returns (Currency currency, uint256 amount, bool boolean);
```



### toBytes

Decode the `_arg`-th element in `_bytes` as `bytes`

```solidity
function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res);
```



**Parameters**

| Name     | Type      | Description                                           |
| -------- | --------- | ----------------------------------------------------- |
| `_bytes` | `bytes`   | The input bytes string to extract a bytes string from |
| `_arg`   | `uint256` | The index of the argument to extract                  |

## Errors

### SliceOutOfBounds

```solidity
error SliceOutOfBounds();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[CurrencyRatioSortOrder](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/CurrencyRatioSortOrder)

# CurrencyRatioSortOrder

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/CurrencyRatioSortOrder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides constants for sorting currencies when displaying price ratios Currencies given larger values will be in the numerator of the price ratio

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/TokenRatioSortOrder.sol*

## State Variables

### NUMERATOR_MOST

```solidity
int256 constant NUMERATOR_MOST = 300;
```



### NUMERATOR_MORE

```solidity
int256 constant NUMERATOR_MORE = 200;
```



### NUMERATOR

```solidity
int256 constant NUMERATOR = 100;
```



### DENOMINATOR_MOST

```solidity
int256 constant DENOMINATOR_MOST = -300;
```



### DENOMINATOR_MORE

```solidity
int256 constant DENOMINATOR_MORE = -200;
```



### DENOMINATOR

```solidity
int256 constant DENOMINATOR = -100;
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[Descriptor](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/Descriptor)

# Descriptor

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Descriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Describes NFT token positions

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol*

## State Variables

### sqrt10X128

```solidity
uint256 constant sqrt10X128 = 1076067327063303206878105757264492625226;
```



## Functions

### constructTokenURI

Constructs the token URI for a Uniswap v4 NFT

```solidity
function constructTokenURI(ConstructTokenURIParams memory params) internal pure returns (string memory);
```



**Parameters**

| Name     | Type                      | Description                                  |
| -------- | ------------------------- | -------------------------------------------- |
| `params` | `ConstructTokenURIParams` | Parameters needed to construct the token URI |

**Returns**

| Name     | Type     | Description               |
| -------- | -------- | ------------------------- |
| `<none>` | `string` | The token URI as a string |

### escapeSpecialCharacters

Escapes special characters in a string if they are present

```solidity
function escapeSpecialCharacters(string memory symbol) internal pure returns (string memory);
```



### generateDescriptionPartOne

Generates the first part of the description for a Uniswap v4 NFT

```solidity
function generateDescriptionPartOne(
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol,
    string memory poolManager
) private pure returns (string memory);
```



**Parameters**

| Name                  | Type     | Description                      |
| --------------------- | -------- | -------------------------------- |
| `quoteCurrencySymbol` | `string` | The symbol of the quote currency |
| `baseCurrencySymbol`  | `string` | The symbol of the base currency  |
| `poolManager`         | `string` | The address of the pool manager  |

**Returns**

| Name     | Type     | Description                       |
| -------- | -------- | --------------------------------- |
| `<none>` | `string` | The first part of the description |

### generateDescriptionPartTwo

Generates the second part of the description for a Uniswap v4 NFTs

```solidity
function generateDescriptionPartTwo(
    string memory tokenId,
    string memory baseCurrencySymbol,
    string memory quoteCurrency,
    string memory baseCurrency,
    string memory hooks,
    string memory feeTier
) private pure returns (string memory);
```



**Parameters**

| Name                 | Type     | Description                       |
| -------------------- | -------- | --------------------------------- |
| `tokenId`            | `string` | The token ID                      |
| `baseCurrencySymbol` | `string` | The symbol of the base currency   |
| `quoteCurrency`      | `string` | The address of the quote currency |
| `baseCurrency`       | `string` | The address of the base currency  |
| `hooks`              | `string` | The address of the hooks contract |
| `feeTier`            | `string` | The fee tier of the pool          |

**Returns**

| Name     | Type     | Description                        |
| -------- | -------- | ---------------------------------- |
| `<none>` | `string` | The second part of the description |

### generateName

Generates the name for a Uniswap v4 NFT

```solidity
function generateName(ConstructTokenURIParams memory params, string memory feeTier)
    private
    pure
    returns (string memory);
```



**Parameters**

| Name      | Type                      | Description                            |
| --------- | ------------------------- | -------------------------------------- |
| `params`  | `ConstructTokenURIParams` | Parameters needed to generate the name |
| `feeTier` | `string`                  | The fee tier of the pool               |

**Returns**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `<none>` | `string` | The name of the NFT |

### generateDecimalString

```solidity
function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory);
```



### tickToDecimalString

Gets the price (quote/base) at a specific tick in decimal form MIN or MAX are returned if tick is at the bottom or top of the price curve

```solidity
function tickToDecimalString(
    int24 tick,
    int24 tickSpacing,
    uint8 baseCurrencyDecimals,
    uint8 quoteCurrencyDecimals,
    bool flipRatio
) internal pure returns (string memory);
```



**Parameters**

| Name                    | Type    | Description                              |
| ----------------------- | ------- | ---------------------------------------- |
| `tick`                  | `int24` | The tick (either tickLower or tickUpper) |
| `tickSpacing`           | `int24` | The tick spacing of the pool             |
| `baseCurrencyDecimals`  | `uint8` | The decimals of the base currency        |
| `quoteCurrencyDecimals` | `uint8` | The decimals of the quote currency       |
| `flipRatio`             | `bool`  | True if the ratio was flipped            |

**Returns**

| Name     | Type     | Description                 |
| -------- | -------- | --------------------------- |
| `<none>` | `string` | The ratio value as a string |

### sigfigsRounded

```solidity
function sigfigsRounded(uint256 value, uint8 digits) private pure returns (uint256, bool);
```



### adjustForDecimalPrecision

Adjusts the sqrt price for different currencies with different decimals

```solidity
function adjustForDecimalPrecision(uint160 sqrtRatioX96, uint8 baseCurrencyDecimals, uint8 quoteCurrencyDecimals)
    private
    pure
    returns (uint256 adjustedSqrtRatioX96);
```



**Parameters**

| Name                    | Type      | Description                        |
| ----------------------- | --------- | ---------------------------------- |
| `sqrtRatioX96`          | `uint160` | The sqrt price at a specific tick  |
| `baseCurrencyDecimals`  | `uint8`   | The decimals of the base currency  |
| `quoteCurrencyDecimals` | `uint8`   | The decimals of the quote currency |

**Returns**

| Name                   | Type      | Description             |
| ---------------------- | --------- | ----------------------- |
| `adjustedSqrtRatioX96` | `uint256` | The adjusted sqrt price |

### abs

Absolute value of a signed integer

```solidity
function abs(int256 x) private pure returns (uint256);
```



**Parameters**

| Name | Type     | Description        |
| ---- | -------- | ------------------ |
| `x`  | `int256` | The signed integer |

**Returns**

| Name     | Type      | Description             |
| -------- | --------- | ----------------------- |
| `<none>` | `uint256` | The absolute value of x |

### fixedPointToDecimalString

```solidity
function fixedPointToDecimalString(uint160 sqrtRatioX96, uint8 baseCurrencyDecimals, uint8 quoteCurrencyDecimals)
    internal
    pure
    returns (string memory);
```



### feeToPercentString

Converts fee amount in pips to decimal string with percent sign

```solidity
function feeToPercentString(uint24 fee) internal pure returns (string memory);
```



**Parameters**

| Name  | Type     | Description |
| ----- | -------- | ----------- |
| `fee` | `uint24` | fee amount  |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `string` | fee as a decimal string with percent sign |

### addressToString

```solidity
function addressToString(address addr) internal pure returns (string memory);
```



### generateSVGImage

Generates the SVG image for a Uniswap v4 NFT

```solidity
function generateSVGImage(ConstructTokenURIParams memory params) internal pure returns (string memory svg);
```



**Parameters**

| Name     | Type                      | Description                                 |
| -------- | ------------------------- | ------------------------------------------- |
| `params` | `ConstructTokenURIParams` | Parameters needed to generate the SVG image |

**Returns**

| Name  | Type     | Description               |
| ----- | -------- | ------------------------- |
| `svg` | `string` | The SVG image as a string |

### overRange

Checks if the current price is within your position range, above, or below

```solidity
function overRange(int24 tickLower, int24 tickUpper, int24 tickCurrent) private pure returns (int8);
```



**Parameters**

| Name          | Type    | Description      |
| ------------- | ------- | ---------------- |
| `tickLower`   | `int24` | The lower tick   |
| `tickUpper`   | `int24` | The upper tick   |
| `tickCurrent` | `int24` | The current tick |

**Returns**

| Name     | Type   | Description                                                  |
| -------- | ------ | ------------------------------------------------------------ |
| `<none>` | `int8` | 0 if the current price is within the position range, -1 if below, 1 if above |

### isSpecialCharacter

```solidity
function isSpecialCharacter(bytes1 b) private pure returns (bool);
```



### scale

```solidity
function scale(uint256 n, uint256 inMn, uint256 inMx, uint256 outMn, uint256 outMx)
    private
    pure
    returns (string memory);
```



### currencyToColorHex

```solidity
function currencyToColorHex(uint256 currency, uint256 offset) internal pure returns (string memory str);
```



### getCircleCoord

```solidity
function getCircleCoord(uint256 currency, uint256 offset, uint256 tokenId) internal pure returns (uint256);
```



### sliceCurrencyHex

```solidity
function sliceCurrencyHex(uint256 currency, uint256 offset) internal pure returns (uint256);
```



## Structs

### ConstructTokenURIParams

```solidity
struct ConstructTokenURIParams {
    uint256 tokenId;
    address quoteCurrency;
    address baseCurrency;
    string quoteCurrencySymbol;
    string baseCurrencySymbol;
    uint8 quoteCurrencyDecimals;
    uint8 baseCurrencyDecimals;
    bool flipRatio;
    int24 tickLower;
    int24 tickUpper;
    int24 tickCurrent;
    int24 tickSpacing;
    uint24 fee;
    address poolManager;
    address hooks;
}
```



### DecimalStringParams

```solidity
struct DecimalStringParams {
    uint256 sigfigs;
    uint8 bufferLength;
    uint8 sigfigIndex;
    uint8 decimalIndex;
    uint8 zerosStartIndex;
    uint8 zerosEndIndex;
    bool isLessThanOne;
    bool isPercent;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[ERC721PermitHash](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/ERC721PermitHash)

# ERC721PermitHash

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/ERC721PermitHash.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## State Variables

### PERMIT_TYPEHASH

*Value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)");*

```solidity
bytes32 constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;
```



### PERMIT_FOR_ALL_TYPEHASH

*Value is equal to keccak256("PermitForAll(address operator,bool approved,uint256 nonce,uint256 deadline)");*

```solidity
bytes32 constant PERMIT_FOR_ALL_TYPEHASH = 0x6673cb397ee2a50b6b8401653d3638b4ac8b3db9c28aa6870ffceb7574ec2f76;
```



## Functions

### hashPermit

Hashes the data that will be signed for IERC721Permit_v4.permit()

```solidity
function hashPermit(address spender, uint256 tokenId, uint256 nonce, uint256 deadline)
    internal
    pure
    returns (bytes32 digest);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `spender`  | `address` | The address which may spend the tokenId                      |
| `tokenId`  | `uint256` | The tokenId of the owner, which may be spent by spender      |
| `nonce`    | `uint256` | A unique non-ordered value for each signature to prevent replay attacks |
| `deadline` | `uint256` | The time at which the signature expires                      |

**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `digest` | `bytes32` | The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonce, deadline)); |

### hashPermitForAll

Hashes the data that will be signed for IERC721Permit_v4.permit()

```solidity
function hashPermitForAll(address operator, bool approved, uint256 nonce, uint256 deadline)
    internal
    pure
    returns (bytes32 digest);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `operator` | `address` | The address which may spend any of the owner's tokenIds      |
| `approved` | `bool`    | true if the operator is to have full permission over the owner's tokenIds; false otherwise |
| `nonce`    | `uint256` | A unique non-ordered value for each signature to prevent replay attacks |
| `deadline` | `uint256` | The time at which the signature expires                      |

**Returns**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `digest` | `bytes32` | The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, operator, approved, nonce, deadline)); |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[HexStrings](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/HexStrings)

# HexStrings

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/HexStrings.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides function for converting numbers to hexadecimal strings

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/HexStrings.sol*

## State Variables

### ALPHABET

```solidity
bytes16 internal constant ALPHABET = "0123456789abcdef";
```



## Functions

### toHexStringNoPrefix

Convert a number to a hex string without the '0x' prefix with a fixed length

```solidity
function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory);
```



**Parameters**

| Name     | Type      | Description                                                  |
| -------- | --------- | ------------------------------------------------------------ |
| `value`  | `uint256` | The number to convert                                        |
| `length` | `uint256` | The length of the output string, starting from the last character of the string |

**Returns**

| Name     | Type     | Description    |
| -------- | -------- | -------------- |
| `<none>` | `string` | The hex string |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[LiquidityAmounts](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/LiquidityAmounts)

# LiquidityAmounts

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/LiquidityAmounts.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides functions for computing liquidity amounts from token amounts and prices

## Functions

### getLiquidityForAmount0

Computes the amount of liquidity received for a given amount of token0 and price range

*Calculates amount0 \* (sqrt(upper) \* sqrt(lower)) / (sqrt(upper) - sqrt(lower))*

```solidity
function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)
    internal
    pure
    returns (uint128 liquidity);
```



**Parameters**

| Name            | Type      | Description                                        |
| --------------- | --------- | -------------------------------------------------- |
| `sqrtPriceAX96` | `uint160` | A sqrt price representing the first tick boundary  |
| `sqrtPriceBX96` | `uint160` | A sqrt price representing the second tick boundary |
| `amount0`       | `uint256` | The amount0 being sent in                          |

**Returns**

| Name        | Type      | Description                      |
| ----------- | --------- | -------------------------------- |
| `liquidity` | `uint128` | The amount of returned liquidity |

### getLiquidityForAmount1

Computes the amount of liquidity received for a given amount of token1 and price range

*Calculates amount1 / (sqrt(upper) - sqrt(lower)).*

```solidity
function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)
    internal
    pure
    returns (uint128 liquidity);
```



**Parameters**

| Name            | Type      | Description                                        |
| --------------- | --------- | -------------------------------------------------- |
| `sqrtPriceAX96` | `uint160` | A sqrt price representing the first tick boundary  |
| `sqrtPriceBX96` | `uint160` | A sqrt price representing the second tick boundary |
| `amount1`       | `uint256` | The amount1 being sent in                          |

**Returns**

| Name        | Type      | Description                      |
| ----------- | --------- | -------------------------------- |
| `liquidity` | `uint128` | The amount of returned liquidity |

### getLiquidityForAmounts

Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries

```solidity
function getLiquidityForAmounts(
    uint160 sqrtPriceX96,
    uint160 sqrtPriceAX96,
    uint160 sqrtPriceBX96,
    uint256 amount0,
    uint256 amount1
) internal pure returns (uint128 liquidity);
```



**Parameters**

| Name            | Type      | Description                                        |
| --------------- | --------- | -------------------------------------------------- |
| `sqrtPriceX96`  | `uint160` | A sqrt price representing the current pool prices  |
| `sqrtPriceAX96` | `uint160` | A sqrt price representing the first tick boundary  |
| `sqrtPriceBX96` | `uint160` | A sqrt price representing the second tick boundary |
| `amount0`       | `uint256` | The amount of token0 being sent in                 |
| `amount1`       | `uint256` | The amount of token1 being sent in                 |

**Returns**

| Name        | Type      | Description                              |
| ----------- | --------- | ---------------------------------------- |
| `liquidity` | `uint128` | The maximum amount of liquidity received |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[Locker](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/Locker)

# Locker

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Locker.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload) TODO: This library can be deleted when we have the transient keyword support in solidity.

## State Variables

### LOCKED_BY_SLOT

```solidity
bytes32 constant LOCKED_BY_SLOT = 0x0aedd6bde10e3aa2adec092b02a3e3e805795516cda41f27aa145b8f300af87a;
```



## Functions

### set

```solidity
function set(address locker) internal;
```



### get

```solidity
function get() internal view returns (address locker);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[PathKey](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/PathKey)

# PathKey

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PathKey.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
struct PathKey {
    Currency intermediateCurrency;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
    bytes hookData;
}
```



## PathKeyLibrary

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PathKey.sol)

Functions for working with PathKeys

## Functions

### getPoolAndSwapDirection

Get the pool and swap direction for a given PathKey

```solidity
function getPoolAndSwapDirection(PathKey calldata params, Currency currencyIn)
    internal
    pure
    returns (PoolKey memory poolKey, bool zeroForOne);
```



**Parameters**

| Name         | Type       | Description        |
| ------------ | ---------- | ------------------ |
| `params`     | `PathKey`  | the given PathKey  |
| `currencyIn` | `Currency` | the input currency |

**Returns**

| Name         | Type      | Description                                                  |
| ------------ | --------- | ------------------------------------------------------------ |
| `poolKey`    | `PoolKey` | the pool key of the swap                                     |
| `zeroForOne` | `bool`    | the direction of the swap, true if currency0 is being swapped for currency1 |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[PositionConfig](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/PositionConfig)

# PositionConfig

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfig.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

```solidity
struct PositionConfig {
    PoolKey poolKey;
    int24 tickLower;
    int24 tickUpper;
}
```



## PositionConfigLibrary

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfig.sol)

Library to calculate the PositionConfigId from the PositionConfig struct

## Functions

### toId

```solidity
function toId(PositionConfig calldata config) internal pure returns (bytes32 id);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[PositionConfigId](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/PositionConfigId)

# PositionConfigId

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfigId.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A configId is set per tokenId The lower 255 bits are used to store the truncated hash of the corresponding PositionConfig The upper bit is used to signal if the tokenId has a subscriber

```solidity
struct PositionConfigId {
    bytes32 id;
}
```



## PositionConfigIdLibrary

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfigId.sol)

## State Variables

### MASK_UPPER_BIT

```solidity
bytes32 constant MASK_UPPER_BIT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
```



### DIRTY_UPPER_BIT

```solidity
bytes32 constant DIRTY_UPPER_BIT = 0x8000000000000000000000000000000000000000000000000000000000000000;
```



## Functions

### getConfigId

returns the truncated hash of the PositionConfig for a given tokenId

```solidity
function getConfigId(PositionConfigId storage _configId) internal view returns (bytes32 configId);
```



### setConfigId

*We only set the config on mint, guaranteeing that the most significant bit is unset, so we can just assign the entire 32 bytes to the id.*

```solidity
function setConfigId(PositionConfigId storage _configId, bytes32 configId) internal;
```



### setSubscribe

```solidity
function setSubscribe(PositionConfigId storage configId) internal;
```



### setUnsubscribe

```solidity
function setUnsubscribe(PositionConfigId storage configId) internal;
```



### hasSubscriber

```solidity
function hasSubscriber(PositionConfigId storage configId) internal view returns (bool subscribed);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[PositionInfo](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/PositionInfoLibrary)

# PositionInfo

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionInfoLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*PositionInfo is a packed version of solidity structure. Using the packaged version saves gas and memory by not storing the structure fields in memory slots. Layout: 200 bits poolId | 24 bits tickUpper | 24 bits tickLower | 8 bits hasSubscriber Fields in the direction from the least significant bit: A flag to know if the tokenId is subscribed to an address uint8 hasSubscriber; The tickUpper of the position int24 tickUpper; The tickLower of the position int24 tickLower; The truncated poolId. Truncates a bytes32 value so the most signifcant (highest) 200 bits are used. bytes25 poolId; Note: If more bits are needed, hasSubscriber can be a single bit.*

```solidity
type PositionInfo is uint256;
```



## PositionInfoLibrary

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionInfoLibrary.sol)

## State Variables

### EMPTY_POSITION_INFO

```solidity
PositionInfo internal constant EMPTY_POSITION_INFO = PositionInfo.wrap(0);
```



### MASK_UPPER_200_BITS

```solidity
uint256 internal constant MASK_UPPER_200_BITS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000;
```



### MASK_8_BITS

```solidity
uint256 internal constant MASK_8_BITS = 0xFF;
```



### MASK_24_BITS

```solidity
uint24 internal constant MASK_24_BITS = 0xFFFFFF;
```



### SET_UNSUBSCRIBE

```solidity
uint256 internal constant SET_UNSUBSCRIBE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;
```



### SET_SUBSCRIBE

```solidity
uint256 internal constant SET_SUBSCRIBE = 0x01;
```



### TICK_LOWER_OFFSET

```solidity
uint8 internal constant TICK_LOWER_OFFSET = 8;
```



### TICK_UPPER_OFFSET

```solidity
uint8 internal constant TICK_UPPER_OFFSET = 32;
```



## Functions

### poolId

*This poolId is NOT compatible with the poolId used in UniswapV4 core. It is truncated to 25 bytes, and just used to lookup PoolKey in the poolKeys mapping.*

```solidity
function poolId(PositionInfo info) internal pure returns (bytes25 _poolId);
```



### tickLower

```solidity
function tickLower(PositionInfo info) internal pure returns (int24 _tickLower);
```



### tickUpper

```solidity
function tickUpper(PositionInfo info) internal pure returns (int24 _tickUpper);
```



### hasSubscriber

```solidity
function hasSubscriber(PositionInfo info) internal pure returns (bool _hasSubscriber);
```



### setSubscribe

*this does not actually set any storage*

```solidity
function setSubscribe(PositionInfo info) internal pure returns (PositionInfo _info);
```



### setUnsubscribe

*this does not actually set any storage*

```solidity
function setUnsubscribe(PositionInfo info) internal pure returns (PositionInfo _info);
```



### initialize

Creates the default PositionInfo struct

*Called when minting a new position*

```solidity
function initialize(PoolKey memory _poolKey, int24 _tickLower, int24 _tickUpper)
    internal
    pure
    returns (PositionInfo info);
```



**Parameters**

| Name         | Type      | Description                    |
| ------------ | --------- | ------------------------------ |
| `_poolKey`   | `PoolKey` | the pool key of the position   |
| `_tickLower` | `int24`   | the lower tick of the position |
| `_tickUpper` | `int24`   | the upper tick of the position |

**Returns**

| Name   | Type           | Description                                                  |
| ------ | -------------- | ------------------------------------------------------------ |
| `info` | `PositionInfo` | packed position info, with the truncated poolId and the hasSubscriber flag set to false |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[QuoterRevert](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/QuoterRevert)

# QuoterRevert

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/QuoterRevert.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

## Functions

### revertQuote

reverts, where the revert data is the provided bytes

*called when quoting, to record the quote amount in an error*

*QuoteSwap is used to differentiate this error from other errors thrown when simulating the swap*

```solidity
function revertQuote(uint256 quoteAmount) internal pure;
```



### bubbleReason

reverts using the revertData as the reason

*to bubble up both the valid QuoteSwap(amount) error, or an alternative error thrown during simulation*

```solidity
function bubbleReason(bytes memory revertData) internal pure;
```



### parseQuoteAmount

validates whether a revert reason is a valid swap quote or not if valid, it decodes the quote to return. Otherwise it reverts.

```solidity
function parseQuoteAmount(bytes memory reason) internal pure returns (uint256 quoteAmount);
```



## Errors

### UnexpectedRevertBytes

error thrown when invalid revert bytes are thrown by the quote

```solidity
error UnexpectedRevertBytes(bytes revertData);
```



### QuoteSwap

error thrown containing the quote as the data, to be caught and parsed later

```solidity
error QuoteSwap(uint256 amount);
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[SVG](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/SVG)

# SVG

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SVG.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides a function for generating an SVG associated with a Uniswap NFT

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTSVG.sol*

## State Variables

### curve1

```solidity
string constant curve1 = "M1 1C41 41 105 105 145 145";
```



### curve2

```solidity
string constant curve2 = "M1 1C33 49 97 113 145 145";
```



### curve3

```solidity
string constant curve3 = "M1 1C33 57 89 113 145 145";
```



### curve4

```solidity
string constant curve4 = "M1 1C25 65 81 121 145 145";
```



### curve5

```solidity
string constant curve5 = "M1 1C17 73 73 129 145 145";
```



### curve6

```solidity
string constant curve6 = "M1 1C9 81 65 137 145 145";
```



### curve7

```solidity
string constant curve7 = "M1 1C1 89 57.5 145 145 145";
```



### curve8

```solidity
string constant curve8 = "M1 1C1 97 49 145 145 145";
```



## Functions

### generateSVG

Generate the SVG associated with a Uniswap v4 NFT

```solidity
function generateSVG(SVGParams memory params) internal pure returns (string memory svg);
```



**Parameters**

| Name     | Type        | Description                                                |
| -------- | ----------- | ---------------------------------------------------------- |
| `params` | `SVGParams` | The SVGParams struct containing the parameters for the SVG |

**Returns**

| Name  | Type     | Description                            |
| ----- | -------- | -------------------------------------- |
| `svg` | `string` | The SVG string associated with the NFT |

### generateSVGDefs

Generate the SVG defs that create the color scheme for the SVG

```solidity
function generateSVGDefs(SVGParams memory params) private pure returns (string memory svg);
```



**Parameters**

| Name     | Type        | Description                                                  |
| -------- | ----------- | ------------------------------------------------------------ |
| `params` | `SVGParams` | The SVGParams struct containing the parameters to generate the SVG defs |

**Returns**

| Name  | Type     | Description         |
| ----- | -------- | ------------------- |
| `svg` | `string` | The SVG defs string |

### generateSVGBorderText

Generate the SVG for the moving border text displaying the quote and base currency addresses with their symbols

```solidity
function generateSVGBorderText(
    string memory quoteCurrency,
    string memory baseCurrency,
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol
) private pure returns (string memory svg);
```



**Parameters**

| Name                  | Type     | Description               |
| --------------------- | -------- | ------------------------- |
| `quoteCurrency`       | `string` | The quote currency        |
| `baseCurrency`        | `string` | The base currency         |
| `quoteCurrencySymbol` | `string` | The quote currency symbol |
| `baseCurrencySymbol`  | `string` | The base currency symbol  |

**Returns**

| Name  | Type     | Description                              |
| ----- | -------- | ---------------------------------------- |
| `svg` | `string` | The SVG for the border NFT's border text |

### generateSVGCardMantle

Generate the SVG for the card mantle displaying the quote and base currency symbols and fee tier

```solidity
function generateSVGCardMantle(
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol,
    string memory feeTier
) private pure returns (string memory svg);
```



**Parameters**

| Name                  | Type     | Description               |
| --------------------- | -------- | ------------------------- |
| `quoteCurrencySymbol` | `string` | The quote currency symbol |
| `baseCurrencySymbol`  | `string` | The base currency symbol  |
| `feeTier`             | `string` | The fee tier              |

**Returns**

| Name  | Type     | Description                 |
| ----- | -------- | --------------------------- |
| `svg` | `string` | The SVG for the card mantle |

### generageSvgCurve

Generate the SVG for the curve that represents the position. Fade up (top is faded) if current price is above your position range, fade down (bottom is faded) if current price is below your position range Circles are generated at the ends of the curve if the position is in range, or at one end of the curve it is on if not in range

```solidity
function generageSvgCurve(int24 tickLower, int24 tickUpper, int24 tickSpacing, int8 overRange)
    private
    pure
    returns (string memory svg);
```



**Parameters**

| Name          | Type    | Description                                                  |
| ------------- | ------- | ------------------------------------------------------------ |
| `tickLower`   | `int24` | The lower tick                                               |
| `tickUpper`   | `int24` | The upper tick                                               |
| `tickSpacing` | `int24` | The tick spacing                                             |
| `overRange`   | `int8`  | Whether the current tick is in range, over range, or under range |

**Returns**

| Name  | Type     | Description           |
| ----- | -------- | --------------------- |
| `svg` | `string` | The SVG for the curve |

### getCurve

Get the curve based on the tick range The smaller the tick range, the smaller/more linear the curve

```solidity
function getCurve(int24 tickLower, int24 tickUpper, int24 tickSpacing) internal pure returns (string memory curve);
```



**Parameters**

| Name          | Type    | Description      |
| ------------- | ------- | ---------------- |
| `tickLower`   | `int24` | The lower tick   |
| `tickUpper`   | `int24` | The upper tick   |
| `tickSpacing` | `int24` | The tick spacing |

**Returns**

| Name    | Type     | Description    |
| ------- | -------- | -------------- |
| `curve` | `string` | The curve path |

### generateSVGCurveCircle

Generate the SVG for the circles on the curve

```solidity
function generateSVGCurveCircle(int8 overRange) internal pure returns (string memory svg);
```



**Parameters**

| Name        | Type   | Description                                                  |
| ----------- | ------ | ------------------------------------------------------------ |
| `overRange` | `int8` | 0 if the current tick is in range, 1 if the current tick is over range, -1 if the current tick is under range |

**Returns**

| Name  | Type     | Description             |
| ----- | -------- | ----------------------- |
| `svg` | `string` | The SVG for the circles |

### generateSVGPositionDataAndLocationCurve

If the position is over or under range, generate one circle at the end of the curve on the side of the range it is on with a larger circle around it If the position is in range, generate two circles at the ends of the curve

Generate the SVG for the position data (token ID, hooks address, min tick, max tick) and the location curve (where your position falls on the curve)

```solidity
function generateSVGPositionDataAndLocationCurve(string memory tokenId, address hook, int24 tickLower, int24 tickUpper)
    private
    pure
    returns (string memory svg);
```



**Parameters**

| Name        | Type      | Description       |
| ----------- | --------- | ----------------- |
| `tokenId`   | `string`  | The token ID      |
| `hook`      | `address` | The hooks address |
| `tickLower` | `int24`   | The lower tick    |
| `tickUpper` | `int24`   | The upper tick    |

**Returns**

| Name  | Type     | Description                                      |
| ----- | -------- | ------------------------------------------------ |
| `svg` | `string` | The SVG for the position data and location curve |

### substring

```solidity
function substring(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory);
```



### tickToString

```solidity
function tickToString(int24 tick) private pure returns (string memory);
```



### rangeLocation

Get the location of where your position falls on the curve

```solidity
function rangeLocation(int24 tickLower, int24 tickUpper) internal pure returns (string memory, string memory);
```



**Parameters**

| Name        | Type    | Description    |
| ----------- | ------- | -------------- |
| `tickLower` | `int24` | The lower tick |
| `tickUpper` | `int24` | The upper tick |

**Returns**

| Name     | Type     | Description                                              |
| -------- | -------- | -------------------------------------------------------- |
| `<none>` | `string` | The x and y coordinates of the location of the liquidity |
| `<none>` | `string` |                                                          |

### generateSVGRareSparkle

Generates the SVG for a rare sparkle if the NFT is rare. Else, returns an empty string

```solidity
function generateSVGRareSparkle(uint256 tokenId, address hooks) private pure returns (string memory svg);
```



**Parameters**

| Name      | Type      | Description       |
| --------- | --------- | ----------------- |
| `tokenId` | `uint256` | The token ID      |
| `hooks`   | `address` | The hooks address |

**Returns**

| Name  | Type     | Description                  |
| ----- | -------- | ---------------------------- |
| `svg` | `string` | The SVG for the rare sparkle |

### isRare

Determines if an NFT is rare based on the token ID and hooks address

```solidity
function isRare(uint256 tokenId, address hooks) internal pure returns (bool);
```



**Parameters**

| Name      | Type      | Description       |
| --------- | --------- | ----------------- |
| `tokenId` | `uint256` | The token ID      |
| `hooks`   | `address` | The hooks address |

**Returns**

| Name     | Type   | Description                    |
| -------- | ------ | ------------------------------ |
| `<none>` | `bool` | Whether the NFT is rare or not |

## Structs

### SVGParams

```solidity
struct SVGParams {
    string quoteCurrency;
    string baseCurrency;
    address hooks;
    string quoteCurrencySymbol;
    string baseCurrencySymbol;
    string feeTier;
    int24 tickLower;
    int24 tickUpper;
    int24 tickSpacing;
    int8 overRange;
    uint256 tokenId;
    string color0;
    string color1;
    string color2;
    string color3;
    string x1;
    string y1;
    string x2;
    string y2;
    string x3;
    string y3;
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[SafeCurrencyMetadata](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/SafeCurrencyMetadata)

# SafeCurrencyMetadata

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SafeCurrencyMetadata.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

can produce symbols and decimals from inconsistent or absent ERC20 implementations

*Reference: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/SafeERC20Namer.sol*

## State Variables

### MAX_SYMBOL_LENGTH

```solidity
uint8 constant MAX_SYMBOL_LENGTH = 12;
```



## Functions

### currencySymbol

attempts to extract the currency symbol. if it does not implement symbol, returns a symbol derived from the address

```solidity
function currencySymbol(address currency, string memory nativeLabel) internal view returns (string memory);
```



**Parameters**

| Name          | Type      | Description          |
| ------------- | --------- | -------------------- |
| `currency`    | `address` | The currency address |
| `nativeLabel` | `string`  | The native label     |

**Returns**

| Name     | Type     | Description         |
| -------- | -------- | ------------------- |
| `<none>` | `string` | the currency symbol |

### currencyDecimals

attempts to extract the token decimals, returns 0 if not implemented or not a uint8

```solidity
function currencyDecimals(address currency) internal view returns (uint8);
```



**Parameters**

| Name       | Type      | Description          |
| ---------- | --------- | -------------------- |
| `currency` | `address` | The currency address |

**Returns**

| Name     | Type    | Description           |
| -------- | ------- | --------------------- |
| `<none>` | `uint8` | the currency decimals |

### bytes32ToString

```solidity
function bytes32ToString(bytes32 x) private pure returns (string memory);
```



### addressToSymbol

produces a symbol from the address - the first 6 hex of the address string in upper case

```solidity
function addressToSymbol(address currencyAddress) private pure returns (string memory);
```



**Parameters**

| Name              | Type      | Description                 |
| ----------------- | --------- | --------------------------- |
| `currencyAddress` | `address` | the address of the currency |

**Returns**

| Name     | Type     | Description |
| -------- | -------- | ----------- |
| `<none>` | `string` | the symbol  |

### callAndParseStringReturn

calls an external view contract method that returns a symbol, and parses the output into a string

```solidity
function callAndParseStringReturn(address currencyAddress, bytes4 selector) private view returns (string memory);
```



**Parameters**

| Name              | Type      | Description                       |
| ----------------- | --------- | --------------------------------- |
| `currencyAddress` | `address` | the address of the currency       |
| `selector`        | `bytes4`  | the selector of the symbol method |

**Returns**

| Name     | Type     | Description |
| -------- | -------- | ----------- |
| `<none>` | `string` | the symbol  |

### truncateSymbol

truncates the symbol to the MAX_SYMBOL_LENGTH

*assumes the string is already longer than MAX_SYMBOL_LENGTH (or the same)*

```solidity
function truncateSymbol(string memory str) internal pure returns (string memory);
```



**Parameters**

| Name  | Type     | Description |
| ----- | -------- | ----------- |
| `str` | `string` | the symbol  |

**Returns**

| Name     | Type     | Description          |
| -------- | -------- | -------------------- |
| `<none>` | `string` | the truncated symbol |


[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[SlippageCheck](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/SlippageCheck)

# SlippageCheck

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SlippageCheck.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

a library for checking if a delta exceeds a maximum ceiling or fails to meet a minimum floor

## Functions

### validateMinOut

Revert if one or both deltas does not meet a minimum output

*This should be called when removing liquidity (burn or decrease)*

```solidity
function validateMinOut(BalanceDelta delta, uint128 amount0Min, uint128 amount1Min) internal pure;
```



**Parameters**

| Name         | Type           | Description                                                  |
| ------------ | -------------- | ------------------------------------------------------------ |
| `delta`      | `BalanceDelta` | The principal amount of tokens to be removed, does not include any fees accrued |
| `amount0Min` | `uint128`      | The minimum amount of token0 to receive                      |
| `amount1Min` | `uint128`      | The minimum amount of token1 to receive                      |

### validateMaxIn

Revert if one or both deltas exceeds a maximum input

*This should be called when adding liquidity (mint or increase)*

```solidity
function validateMaxIn(BalanceDelta delta, uint128 amount0Max, uint128 amount1Max) internal pure;
```



**Parameters**

| Name         | Type           | Description                                                  |
| ------------ | -------------- | ------------------------------------------------------------ |
| `delta`      | `BalanceDelta` | The principal amount of tokens to be added, does not include any fees accrued (which is possible on increase) |
| `amount0Max` | `uint128`      | The maximum amount of token0 to spend                        |
| `amount1Max` | `uint128`      | The maximum amount of token1 to spend                        |

## Errors

### MaximumAmountExceeded

```solidity
error MaximumAmountExceeded(uint128 maximumAmount, uint128 amountRequested);
```



### MinimumAmountInsufficient

```solidity
error MinimumAmountInsufficient(uint128 minimumAmount, uint128 amountReceived);
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripherylibraries[VanityAddressLib](https://docs.uniswap.org/contracts/v4/reference/periphery/libraries/VanityAddressLib)

# VanityAddressLib

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/VanityAddressLib.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A library to score addresses based on their vanity

## Functions

### betterThan

Compares two addresses and returns true if the first address has a better vanity score

```solidity
function betterThan(address first, address second) internal pure returns (bool better);
```



**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `first`  | `address` | The first address to compare  |
| `second` | `address` | The second address to compare |

**Returns**

| Name     | Type   | Description                                         |
| -------- | ------ | --------------------------------------------------- |
| `better` | `bool` | True if the first address has a better vanity score |

### score

Scores an address based on its vanity

*Scoring rules: Requirement: The first nonzero nibble must be 4 10 points for every leading 0 nibble 40 points if the first 4 is followed by 3 more 4s 20 points if the first nibble after the 4 4s is NOT a 4 20 points if the last 4 nibbles are 4s 1 point for every 4*

```solidity
function score(address addr) internal pure returns (uint256 calculatedScore);
```



**Parameters**

| Name   | Type      | Description          |
| ------ | --------- | -------------------- |
| `addr` | `address` | The address to score |

**Returns**

| Name              | Type      | Description                     |
| ----------------- | --------- | ------------------------------- |
| `calculatedScore` | `uint256` | The vanity score of the address |

### getLeadingNibbleCount

Returns the number of leading nibbles in an address that match a given value

```solidity
function getLeadingNibbleCount(bytes20 addrBytes, uint256 startIndex, uint8 comparison)
    internal
    pure
    returns (uint256 count);
```



**Parameters**

| Name         | Type      | Description                                      |
| ------------ | --------- | ------------------------------------------------ |
| `addrBytes`  | `bytes20` | The address to count the leading zero nibbles in |
| `startIndex` | `uint256` |                                                  |
| `comparison` | `uint8`   |                                                  |

### getNibble

Returns the nibble at a given index in an address

```solidity
function getNibble(bytes20 input, uint256 nibbleIndex) internal pure returns (uint8 currentNibble);
```



**Parameters**

| Name          | Type      | Description                        |
| ------------- | --------- | ---------------------------------- |
| `input`       | `bytes20` | The address to get the nibble from |
| `nibbleIndex` | `uint256` | The index of the nibble to get     |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v4 ProtocolTechnical ReferencePeripheryutils[BaseHook](https://docs.uniswap.org/contracts/v4/reference/periphery/utils/BaseHook)

# BaseHook

[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/utils/BaseHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:** IHooks, [ImmutableState](https://docs.uniswap.org/contracts/v4/reference/periphery/base/ImmutableState)

abstract contract for hook implementations

## Functions

### constructor

```solidity
constructor(IPoolManager _manager) ImmutableState(_manager);
```



### getHookPermissions

Returns a struct of permissions to signal which hook functions are to be implemented

*Used at deployment to validate the address correctly represents the expected permissions*

```solidity
function getHookPermissions() public pure virtual returns (Hooks.Permissions memory);
```



### validateHookAddress

Validates the deployed hook address agrees with the expected permissions of the hook

*this function is virtual so that we can override it during testing, which allows us to deploy an implementation to any address and then etch the bytecode into the correct address*

```solidity
function validateHookAddress(BaseHook _this) internal pure virtual;
```



### beforeInitialize

The hook called before the state of a pool is initialized

```solidity
function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)
    external
    onlyPoolManager
    returns (bytes4);
```



**Parameters**

| Name           | Type      | Description                                    |
| -------------- | --------- | ---------------------------------------------- |
| `sender`       | `address` | The initial msg.sender for the initialize call |
| `key`          | `PoolKey` | The key for the pool being initialized         |
| `sqrtPriceX96` | `uint160` | The sqrt(price) of the pool as a Q64.96        |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _beforeInitialize

```solidity
function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4);
```



### afterInitialize

The hook called after the state of a pool is initialized

```solidity
function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)
    external
    onlyPoolManager
    returns (bytes4);
```



**Parameters**

| Name           | Type      | Description                                               |
| -------------- | --------- | --------------------------------------------------------- |
| `sender`       | `address` | The initial msg.sender for the initialize call            |
| `key`          | `PoolKey` | The key for the pool being initialized                    |
| `sqrtPriceX96` | `uint160` | The sqrt(price) of the pool as a Q64.96                   |
| `tick`         | `int24`   | The current tick after the state of a pool is initialized |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _afterInitialize

```solidity
function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4);
```



### beforeAddLiquidity

The hook called before liquidity is added

```solidity
function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4);
```



**Parameters**

| Name       | Type                                 | Description                                                  |
| ---------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`   | `address`                            | The initial msg.sender for the add liquidity call            |
| `key`      | `PoolKey`                            | The key for the pool                                         |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for adding liquidity                          |
| `hookData` | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _beforeAddLiquidity

```solidity
function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4);
```



### beforeRemoveLiquidity

The hook called before liquidity is removed

```solidity
function beforeRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4);
```



**Parameters**

| Name       | Type                                 | Description                                                  |
| ---------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`   | `address`                            | The initial msg.sender for the remove liquidity call         |
| `key`      | `PoolKey`                            | The key for the pool                                         |
| `params`   | `IPoolManager.ModifyLiquidityParams` | The parameters for removing liquidity                        |
| `hookData` | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _beforeRemoveLiquidity

```solidity
function _beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4);
```



### afterAddLiquidity

The hook called after liquidity is added

```solidity
function afterAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BalanceDelta);
```



**Parameters**

| Name          | Type                                 | Description                                                  |
| ------------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`      | `address`                            | The initial msg.sender for the add liquidity call            |
| `key`         | `PoolKey`                            | The key for the pool                                         |
| `params`      | `IPoolManager.ModifyLiquidityParams` | The parameters for adding liquidity                          |
| `delta`       | `BalanceDelta`                       | The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta |
| `feesAccrued` | `BalanceDelta`                       | The fees accrued since the last time fees were collected from this position |
| `hookData`    | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`       | bytes4 The function selector for the hook                    |
| `<none>` | `BalanceDelta` | BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### _afterAddLiquidity

```solidity
function _afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) internal virtual returns (bytes4, BalanceDelta);
```



### afterRemoveLiquidity

The hook called after liquidity is removed

```solidity
function afterRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BalanceDelta);
```



**Parameters**

| Name          | Type                                 | Description                                                  |
| ------------- | ------------------------------------ | ------------------------------------------------------------ |
| `sender`      | `address`                            | The initial msg.sender for the remove liquidity call         |
| `key`         | `PoolKey`                            | The key for the pool                                         |
| `params`      | `IPoolManager.ModifyLiquidityParams` | The parameters for removing liquidity                        |
| `delta`       | `BalanceDelta`                       | The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta |
| `feesAccrued` | `BalanceDelta`                       | The fees accrued since the last time fees were collected from this position |
| `hookData`    | `bytes`                              | Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook |

**Returns**

| Name     | Type           | Description                                                  |
| -------- | -------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`       | bytes4 The function selector for the hook                    |
| `<none>` | `BalanceDelta` | BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### _afterRemoveLiquidity

```solidity
function _afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) internal virtual returns (bytes4, BalanceDelta);
```



### beforeSwap

The hook called before a swap

```solidity
function beforeSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24);
```



**Parameters**

| Name       | Type                      | Description                                                  |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| `sender`   | `address`                 | The initial msg.sender for the swap call                     |
| `key`      | `PoolKey`                 | The key for the pool                                         |
| `params`   | `IPoolManager.SwapParams` | The parameters for the swap                                  |
| `hookData` | `bytes`                   | Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook |

**Returns**

| Name     | Type              | Description                                                  |
| -------- | ----------------- | ------------------------------------------------------------ |
| `<none>` | `bytes4`          | bytes4 The function selector for the hook                    |
| `<none>` | `BeforeSwapDelta` | BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |
| `<none>` | `uint24`          | uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million) |

### _beforeSwap

```solidity
function _beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4, BeforeSwapDelta, uint24);
```



### afterSwap

The hook called after a swap

```solidity
function afterSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, int128);
```



**Parameters**

| Name       | Type                      | Description                                                  |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| `sender`   | `address`                 | The initial msg.sender for the swap call                     |
| `key`      | `PoolKey`                 | The key for the pool                                         |
| `params`   | `IPoolManager.SwapParams` | The parameters for the swap                                  |
| `delta`    | `BalanceDelta`            | The amount owed to the caller (positive) or owed to the pool (negative) |
| `hookData` | `bytes`                   | Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                                                  |
| -------- | -------- | ------------------------------------------------------------ |
| `<none>` | `bytes4` | bytes4 The function selector for the hook                    |
| `<none>` | `int128` | int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency |

### _afterSwap

```solidity
function _afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    internal
    virtual
    returns (bytes4, int128);
```



### beforeDonate

The hook called before donate

```solidity
function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyPoolManager
    returns (bytes4);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `sender`   | `address` | The initial msg.sender for the donate call                   |
| `key`      | `PoolKey` | The key for the pool                                         |
| `amount0`  | `uint256` | The amount of token0 being donated                           |
| `amount1`  | `uint256` | The amount of token1 being donated                           |
| `hookData` | `bytes`   | Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _beforeDonate

```solidity
function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) internal virtual returns (bytes4);
```



### afterDonate

The hook called after donate

```solidity
function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyPoolManager
    returns (bytes4);
```



**Parameters**

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `sender`   | `address` | The initial msg.sender for the donate call                   |
| `key`      | `PoolKey` | The key for the pool                                         |
| `amount0`  | `uint256` | The amount of token0 being donated                           |
| `amount1`  | `uint256` | The amount of token1 being donated                           |
| `hookData` | `bytes`   | Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook |

**Returns**

| Name     | Type     | Description                               |
| -------- | -------- | ----------------------------------------- |
| `<none>` | `bytes4` | bytes4 The function selector for the hook |

### _afterDonate

```solidity
function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) internal virtual returns (bytes4);
```



## Errors

### HookNotImplemented

```solidity
error HookNotImplemented();
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 Protocol[Overview](https://docs.uniswap.org/contracts/v3/overview)

# Overview

Welcome to the Uniswap v3 smart contracts documentation.

The pages here contain guides and technical documentation for the Uniswap v3 Smart Contracts. You can use these docs to learn about the v3 Protocol Smart Contracts and develop on-chain integrations.

## Guides

If you are new to the Uniswap Protocol, we recommend you start with the [basic concepts](https://docs.uniswap.org/concepts/uniswap-protocol) first.

You can then setup your [local environment](https://docs.uniswap.org/contracts/v3/guides/local-environment) and execute your [first swap](https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps).

## Reference

For a deeper dive, read through the [technical reference](https://docs.uniswap.org/contracts/v3/reference/overview) docs.

## Resources

- [**v3 Core**](https://github.com/Uniswap/v3-core)
- [**v3 Periphery**](https://github.com/Uniswap/v3-periphery)

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolConcepts[Security](https://docs.uniswap.org/contracts/v3/concepts/security)

# Audits

In early 2021, ABDK Consulting performed a general security review and thereafter published an audit report for the Uniswap V3 core contracts in March 2021 prior to its release.

> [Read the report](https://github.com/Uniswap/v3-core/blob/main/audits/abdk/audit.pdf)

In April 2021, ABDK Consulting also published an audit report for the Uniswap V3 Periphery contracts.

> [Read the report](https://github.com/Uniswap/v3-periphery/blob/main/audits/abdk/audit.pdf)

During the week of January 4th, 2021 and from February 15th to March 12th, three engineers from Trail of Bits conducted a security review on the Uniswap V3 core contracts and subsequently published an audit report including results from [Echidna end-to-end tests](https://github.com/Uniswap/v3-core/tree/main/audits/tob#end-to-end-testing-with-echidna) and [verification](https://github.com/Uniswap/v3-core/tree/main/audits/tob#verification-with-manticore) from the symbolic execution tool Manticore.

> [Read the report](https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf)

# Bug Bounty

Uniswap has an open and ongoing bug [bounty program](https://cantina.xyz/bounties/f9df94db-c7b1-434b-bb06-d1360abdd1be) on Cantina.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuides[Set Up Your Local Environment](https://docs.uniswap.org/contracts/v3/guides/local-environment)

# Set Up Your Local Environment

One of the most common questions we get asked is what development toolset to use to build on-chain integrations with Uniswap. There’s no right answer to this question but for this guide we’ll recommend a common one: `Node.js` , `NPM` and `Hardhat`.

At the end of this guide you’ll have a development environment set up that you can use to build the rest of the examples in the Guides section of the docs, or start your own integration project!

To get you started as quickly as possible, we have provided the `Quick Start` section below where you can clone some boiler plate and get building. To start from scratch and learn the underlying concepts, jump to the `Start from Scratch` section.

## Quick Start

The Uniswap [boilerplate repo](https://github.com/Uniswap/uniswap-first-contract-example) provides a basic Hardhat environment with required imports already pre-loaded for you. You can simply clone it and install the dependencies:

```bash
git clone https://github.com/Uniswap/uniswap-first-contract-example
cd uniswap-first-contract-example
npm install
```



Then hop to the `Local Node with a Mainnet Fork` to complete your set up and start developing.

## Start from Scratch

In the following sections, we’ll walk through the steps to create the same environment set up as the boiler plate from scratch and learn the underlying concepts.

### Set Up Dependencies

Node is one of the most common Javascript runtimes. For our purposes it will provide scripting we can use to compile and test our contracts. If you haven’t already, install NodeJS and its package manager NPM ([instructions](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)). Once those dependencies are set up, we can initialize our project:

```bash
$ npm init
```



[Hardhat](https://hardhat.org/) is an Ethereum development toolset that provides a number of powerful features including Solidity compilation, testing and deployment, all in a single convenient wrapper. We’ll use NPM to add Hardhat to our project:

```bash
$ npm add --save-dev hardhat
```



With Hardhat installed we can invoke it to scaffold our development environment. When you first run Hardhat you’ll have the option of starting with a templated Javascript or Typescript project or an empty project. Since Hardhat relies heavily on folder structure, we recommend starting with either of the templated options. Initialize Hardhat and follow the prompts to make your selection and answer yes to the follow up prompts:

```bash
$ npx hardhat init
```



Once the Hardhat initialization completes, take a look around at what got set up. The folder structure should be intuitive, `./contracts` is where you’ll write your Solidity contracts, `./test` is where you’ll write your tests and `./scripts` is where you can write scripts to perform actions like deploying. Out of the box, Hardhat is configured to use this folder structure so don’t change it unless you know what you’re doing!

Next we’ll use NPM to add the Uniswap V3 contracts which will allow us to seamlessly integrate with the protocol in our new contracts:

```bash
$ npm add @uniswap/v3-periphery @uniswap/v3-core
```



The Uniswap V3 contracts were written using a past version of the solidity compiler. Since we’re building integrations on V3 we have to tell Hardhat to use the correct compiler to build these files. Go to the `./hardhat.config.js` file and change the Solidity version to “0.7.6”:

```jsx
// ...
module.exports = {
  solidity: "0.7.6",
};
```



That’s it! You should now have a functional development environment to start building on chain Uniswap integrations. Let’s run a quick test to confirm everything is set up properly.

## Compile a Basic Contract

To confirm that our environment is configured correctly we’ll attempt to compile a basic Swap contract. Create a new file, `./contracts/Swap.sol` and paste the following code into it (a detailed guide to this contract can be found [here](https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps)):

```jsx
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';

contract SimpleSwap {
    ISwapRouter public immutable swapRouter;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    uint24 public constant feeTier = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    function swapWETHForDAI(uint256 amountIn) external returns (uint256 amountOut) {

        // Transfer the specified amount of WETH9 to this contract.
        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);
        // Approve the router to spend WETH9.
        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);
        // Note: To use this example, you should explicitly set slippage limits, omitting for simplicity
        uint256 minOut = /* Calculate min output */ 0;
        uint160 priceLimit = /* Calculate price limit */ 0;
        // Create the params that will be used to execute the swap
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: WETH9,
                tokenOut: DAI,
                fee: feeTier,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: minOut,
                sqrtPriceLimitX96: priceLimit
            });
        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }
}
```



To compile all the contracts in the `./contracts` folder, we’ll use the Hardhat compile command:

```bash
$ npx hardhat compile
```



If the environment is compiled correctly you should see the message:

```bash
Compiled { x } Solidity files successfully
```



## Local Node with a Mainnet Fork

When building and testing integrations with on chain protocols, developers often hit a problem: the liquidity on the live chain is critical to thoroughly testing their code but testing against a live network like Mainnet can be extremely expensive.

See [the SDK getting started guide](https://docs.uniswap.org/sdk/v3/guides/local-development) for a full example on how to use forks.

With your local node up and running, you can use the `--network localhost` flag in tests to point the Hardhat testing suite to that local node:

```bash
$ npx hardhat test --network localhost
```



## Next Steps

With your environment set up you’re ready to start building. Jump over to the guides section to learn about the Uniswap functions you can integrate with. Remember to add all contracts (.sol files) to the `./contracts` folder and their subsequent tests to the `./tests` folder. You can then test them against your local forked node by running:

```bash
$ npx hardhat test --network localhost
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement A Swap[Single Swaps](https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps)

# Single Swaps

Swaps are the most common interaction with the Uniswap protocol. The following example shows you how to implement a single-path swap contract that uses two functions that you create:

- `swapExactInputSingle`
- `swapExactOutputSingle`

The `swapExactInputSingle` function is for performing *exact input* swaps, which swap a fixed amount of one token for a maximum possible amount of another token. This function uses the `ExactInputSingleParams` struct and the `exactInputSingle` function from the [ISwapRouter](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter) interface.

The `swapExactOutputSingle` function is for performing *exact output* swaps, which swap a minimum possible amount of one token for a fixed amount of another token. This function uses the `ExactOutputSingleParams` struct and the `exactOutputSingle` function from the [ISwapRouter](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter) interface.

For simplification, the example hardcodes the token contract addresses, but as explained further below the contract could be modified to change pools and tokens on a per transaction basis.

When trading from a smart contract, the most important thing to keep in mind is that access to an external price source is required. Without this, trades can be frontrun for considerable loss.

**Note:** The swap examples are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, and `abicoder v2` to allow arbitrary nested arrays and structs to be encoded and decoded in calldata, a feature used when executing a swap.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```



Import the two relevant contracts from the npm package installation

```solidity
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
```



Create a contract called `SwapExamples`, and declare an immutable public variable `swapRouter` of type `ISwapRouter`. This allows us to call functions in the `ISwapRouter` interface.

```solidity
contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.
    // It should be noted that for the sake of these examples we pass in the swap router as a constructor argument instead of inheriting it.
    // More advanced example contracts will detail how to inherit the swap router safely.
    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    ISwapRouter public immutable swapRouter;
```



Hardcode the token contract addresses and pool fee tiers for the example. In production, you would likely use an input parameter for this and pass the input into a memory variable, allowing the contract to change the pools and tokens it interacts with on a per transaction basis, but for conceptual simplicity, we are hardcoding them here.

```solidity
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }
```



## Exact Input Swaps

The caller must `approve` the contract to withdraw the tokens from the calling address's account to execute a swap. Remember that because our contract is a contract itself and not an extension of the caller (us); we must also approve the Uniswap protocol router contract to use the tokens that our contract will be in possession of after they have been withdrawn from the calling address (us).

Then, transfer the `amount` of Dai from the calling address into our contract, and use `amount` as the value passed to the second `approve`.

```solidity
    /// @notice swapExactInputSingle swaps a fixed amount of DAI for a maximum possible amount of WETH9
    /// using the DAI/WETH9 0.3% pool by calling `exactInputSingle` in the swap router.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The exact amount of DAI that will be swapped for WETH9.
    /// @return amountOut The amount of WETH9 received.
    function swapExactInputSingle(uint256 amountIn) external returns (uint256 amountOut) {
        // msg.sender must approve this contract

        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);
```



### Swap Input Parameters

To execute the swap function, we need to populate the `ExactInputSingleParams` with the necessary swap data. These parameters are found in the smart contract interfaces, which can be browsed [here](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter).

A brief overview of the parameters:

- `tokenIn` The contract address of the inbound token

- `tokenOut` The contract address of the outbound token

- `fee` The fee tier of the pool, used to determine the correct pool contract in which to execute the swap

- `recipient` the destination address of the outbound token

- `deadline`: the unix time after which a swap will fail, to protect against long-pending transactions and wild swings in prices

- `amountOutMinimum`: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation

- `sqrtPriceLimitX96`: We set this to zero - which makes this parameter inactive. In production, this value can be used to set the limit for the price the swap will push the pool to, which can help protect against price impact or for setting up logic in a variety of price-relevant mechanisms.

  **WARNING: Passing in a non-zero `sqrtPriceLimitX96` can mean that less tokens that the amount specified by `amountIn` are swapped**. Any contract that uses a non-zero `sqrtPriceLimitX96` parameter will need to refund any unswapped tokens.

### Call the function

```solidity
        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.
        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }
```



## Exact Output Swaps

Exact Output swaps a minimum possible amount of the input token for a fixed amount of the outbound token. This is the less common swap style - but useful in a variety of circumstances.

Because this example transfers in the inbound asset in anticipation of the swap - its possible that some of the inbound token will be left over after the swap is executed, which is why we pay it back to the calling address at the end of the swap.

### Call the function

```solidity
/// @notice swapExactOutputSingle swaps a minimum possible amount of DAI for a fixed amount of WETH.
/// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
/// the calling address will need to approve for a slightly higher amount, anticipating some variance.
/// @param amountOut The exact amount of WETH9 to receive from the swap.
/// @param amountInMaximum The amount of DAI we are willing to spend to receive the specified amount of WETH9.
/// @return amountIn The amount of DAI actually spent in the swap.
function swapExactOutputSingle(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);

        // Approve the router to spend the specified `amountInMaximum` of DAI.
        // In production, you should choose the maximum amount to spend based on oracles or other data sources to achieve a better swap.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        ISwapRouter.ExactOutputSingleParams memory params =
            ISwapRouter.ExactOutputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum,
                sqrtPriceLimitX96: 0
            });

        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.
        amountIn = swapRouter.exactOutputSingle(params);

        // For exact output swaps, the amountInMaximum may not have all been spent.
        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
```



## A Complete Single Swap Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using
    // `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.

    // It should be noted that for the sake of these examples, we purposefully pass in the swap router instead of inherit the swap router for simplicity.
    // More advanced example contracts will detail how to inherit the swap router safely.

    ISwapRouter public immutable swapRouter;

    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    /// @notice swapExactInputSingle swaps a fixed amount of DAI for a maximum possible amount of WETH9
    /// using the DAI/WETH9 0.3% pool by calling `exactInputSingle` in the swap router.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The exact amount of DAI that will be swapped for WETH9.
    /// @return amountOut The amount of WETH9 received.
    function swapExactInputSingle(uint256 amountIn) external returns (uint256 amountOut) {
        // msg.sender must approve this contract

        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.
        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }

    /// @notice swapExactOutputSingle swaps a minimum possible amount of DAI for a fixed amount of WETH.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The exact amount of WETH9 to receive from the swap.
    /// @param amountInMaximum The amount of DAI we are willing to spend to receive the specified amount of WETH9.
    /// @return amountIn The amount of DAI actually spent in the swap.
    function swapExactOutputSingle(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);

        // Approve the router to spend the specified `amountInMaximum` of DAI.
        // In production, you should choose the maximum amount to spend based on oracles or other data sources to achieve a better swap.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        ISwapRouter.ExactOutputSingleParams memory params =
            ISwapRouter.ExactOutputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum,
                sqrtPriceLimitX96: 0
            });

        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.
        amountIn = swapRouter.exactOutputSingle(params);

        // For exact output swaps, the amountInMaximum may not have all been spent.
        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement A Swap[Multihop Swaps](https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps)

# Multihop Swaps

## Introduction

The examples below are implementations of the two styles of multi-hop swapping available on v3. The examples below are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Setting up the Contract

Declare the solidity version that will be used to compile the contract, and the `abicoder v2` to allow arbitrary nested arrays and structs to be encoded and decoded in calldata, a feature we use when executing a swap.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```



Import the two needed contracts from the npm package installation.

```solidity
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
```



Create a contract called `SwapExamples`, and declare an immutable public variable `swapRouter` of type `ISwapRouter`. This allows us to call functions in the `ISwapRouter` interface.

```solidity
contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.
    // It should be noted that for the sake of these examples we pass in the swap router as a constructor argument instead of inheriting it.
    // More advanced example contracts will detail how to inherit the swap router safely.
    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    ISwapRouter public immutable swapRouter;
```



Hardcode the token contract addresses and pool fee tiers for the example. In production, you would likely use an input parameter for this and pass the input into a memory variable, allowing the contract to change the pools and tokens it interacts with on a per transaction basis, but for conceptual simplicity, we are hardcoding them here.

```solidity
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }
```



## Exact Input Multi Hop Swaps

Exact input multi hop swaps will swap a fixed amount on a given input token for the maximum amount possible for a given output, and can include an arbitrary number of intermediary swaps.

### Input Parameters

- `path`: The path is a sequence of (`tokenAddress` - `fee` - `tokenAddress`), which are the variables needed to compute each pool contract address in our sequence of swaps. The multihop swap router code will automatically find the correct pool with these variables, and execute the swap needed within each pool in our sequence.
- `recipient`: the destination address of the outbound asset.
- `deadline`: the unix time after which a transaction will be reverted, to protect against long delays and the increased chance of large price swings therein.
- `amountIn`: the amount of the inbound asset
- `amountOutMin`: the minimum amount of the outbound asset, less than which will cause the transaction to revert. For the sake of this example we will set it to `0`, in production one will need to use the SDK to quote an expected price, or an on chain price oracle for more advanced manipulation resistant systems.

### Calling the function

```solidity
    /// @notice swapExactInputMultihop swaps a fixed amount of DAI for a maximum possible amount of WETH9 through an intermediary pool.
    /// For this example, we will swap DAI to USDC, then USDC to WETH9 to achieve our desired output.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The amount of DAI to be swapped.
    /// @return amountOut The amount of WETH9 received after the swap.
    function swapExactInputMultihop(uint256 amountIn) external returns (uint256 amountOut) {
        // Transfer `amountIn` of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Multiple pool swaps are encoded through bytes called a `path`. A path is a sequence of token addresses and poolFees that define the pools used in the swaps.
        // The format for pool encoding is (tokenIn, fee, tokenOut/tokenIn, fee, tokenOut) where tokenOut/tokenIn parameter is the shared token across the pools.
        // Since we are swapping DAI to USDC and then USDC to WETH9 the path encoding is (DAI, 0.3%, USDC, 0.3%, WETH9).
        ISwapRouter.ExactInputParams memory params =
            ISwapRouter.ExactInputParams({
                path: abi.encodePacked(DAI, poolFee, USDC, poolFee, WETH9),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0
            });

        // Executes the swap.
        amountOut = swapRouter.exactInput(params);
    }
```



## Exact Output Multihop Swap

An exact output swap will swap a variable amount of the input token for a fixed amount of the outbound token. This is the less common technique for multihop swaps. The code for swapping is largely the same except for one notable difference, the `Path` is encoded backwards, as an exact output swap is executed in reverse order to pass down the necessary variables for the chain of transactions

### Input Parameters

- `path`: The path is a sequence of `tokenAddress` `Fee` `tokenAddress`, *encoded in reverse order*, which are the variables needed to compute each pool contract address in our sequence of swaps. The multihop swap router code will automatically find the correct pool with these variables, and execute the swap needed within each pool in our sequence.
- `recipient`: the destination address of the outbound asset.
- `deadline`: the unix time after which a transaction will be reverted, to protect against long delays and the increased chance of large price swings therein.
- `amountOut`: The desired amount of WETH9.
- `amountInMaximum`: The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.

### Calling the function

```solidity
    /// @notice swapExactOutputMultihop swaps a minimum possible amount of DAI for a fixed amount of WETH through an intermediary pool.
    /// For this example, we want to swap DAI for WETH9 through a USDC pool but we specify the desired amountOut of WETH9. Notice how the path encoding is slightly different in for exact output swaps.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The desired amount of WETH9.
    /// @param amountInMaximum The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.
    /// @return amountIn The amountIn of DAI actually spent to receive the desired amountOut.
    function swapExactOutputMultihop(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified `amountInMaximum` to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);
        // Approve the router to spend  `amountInMaximum`.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)
        // The tokenIn/tokenOut field is the shared token between the two pools used in the multiple pool swap. In this case USDC is the "shared" token.
        // For an exactOutput swap, the first swap that occurs is the swap which returns the eventual desired token.
        // In this case, our desired output token is WETH9 so that swap happens first, and is encoded in the path accordingly.
        ISwapRouter.ExactOutputParams memory params =
            ISwapRouter.ExactOutputParams({
                path: abi.encodePacked(WETH9, poolFee, USDC, poolFee, DAI),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum
            });

        // Executes the swap, returning the amountIn actually spent.
        amountIn = swapRouter.exactOutput(params);

        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
```



## The Full Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using
    // `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.

    // It should be noted that for the sake of these examples, we purposefully pass in the swap router instead of inherit the swap router for simplicity.
    // More advanced example contracts will detail how to inherit the swap router safely.

    ISwapRouter public immutable swapRouter;

    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    /// @notice swapInputMultiplePools swaps a fixed amount of DAI for a maximum possible amount of WETH9 through an intermediary pool.
    /// For this example, we will swap DAI to USDC, then USDC to WETH9 to achieve our desired output.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The amount of DAI to be swapped.
    /// @return amountOut The amount of WETH9 received after the swap.
    function swapExactInputMultihop(uint256 amountIn) external returns (uint256 amountOut) {
        // Transfer `amountIn` of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Multiple pool swaps are encoded through bytes called a `path`. A path is a sequence of token addresses and poolFees that define the pools used in the swaps.
        // The format for pool encoding is (tokenIn, fee, tokenOut/tokenIn, fee, tokenOut) where tokenOut/tokenIn parameter is the shared token across the pools.
        // Since we are swapping DAI to USDC and then USDC to WETH9 the path encoding is (DAI, 0.3%, USDC, 0.3%, WETH9).
        ISwapRouter.ExactInputParams memory params =
            ISwapRouter.ExactInputParams({
                path: abi.encodePacked(DAI, poolFee, USDC, poolFee, WETH9),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0
            });

        // Executes the swap.
        amountOut = swapRouter.exactInput(params);
    }

    /// @notice swapExactOutputMultihop swaps a minimum possible amount of DAI for a fixed amount of WETH through an intermediary pool.
    /// For this example, we want to swap DAI for WETH9 through a USDC pool but we specify the desired amountOut of WETH9. Notice how the path encoding is slightly different in for exact output swaps.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The desired amount of WETH9.
    /// @param amountInMaximum The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.
    /// @return amountIn The amountIn of DAI actually spent to receive the desired amountOut.
    function swapExactOutputMultihop(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified `amountInMaximum` to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);
        // Approve the router to spend  `amountInMaximum`.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)
        // The tokenIn/tokenOut field is the shared token between the two pools used in the multiple pool swap. In this case USDC is the "shared" token.
        // For an exactOutput swap, the first swap that occurs is the swap which returns the eventual desired token.
        // In this case, our desired output token is WETH9 so that swap happens first, and is encoded in the path accordingly.
        ISwapRouter.ExactOutputParams memory params =
            ISwapRouter.ExactOutputParams({
                path: abi.encodePacked(WETH9, poolFee, USDC, poolFee, DAI),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum
            });

        // Executes the swap, returning the amountIn actually spent.
        amountIn = swapRouter.exactOutput(params);

        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[Set Up Your Contract](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/setting-up)

# Set Up Your Contract

## Setting up the Contract

This guide is an example of a custodial contract Uniswap V3 positions, which allows interaction with the Uniswap V3 Periphery by minting a position, adding liquidity to a position, decreasing liquidity, and collecting fees.

First, declare the solidity version used to compile the contract and `abicoder v2` to allow arbitrary nested arrays and structs to be encoded and decoded in calldata, a feature we use when transacting with a pool.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```



Import the contracts needed from the npm package installation.

```solidity
import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/base/LiquidityManagement.sol';
```



Create a contract called `LiquidityExamples` and inherit both `IERC721Receiver` and `LiquidityManagement`.

We've chosen to hardcode the token contract addresses and pool fee tiers for our example. In production, you would likely use an input parameter for this, allowing you to change the pools and tokens you are interacting with on a per transaction basis.

```solidity
contract LiquidityExamples is IERC721Receiver {

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;
```



Declare an immutable public variable `nonfungiblePositionManager` of type `INonfungiblePositionManager`.

```solidity
    INonfungiblePositionManager public immutable nonfungiblePositionManager;
```



## Allowing ERC721 Interactions

Every [NFT](https://ethereum.org/en/nft/) is identified by a unique uint256 ID inside the ERC-721 smart contract, declared as the `tokenId`

To allow deposits of ERC721 expressions of liquidity, create a struct called `Deposit`, a mapping of `uint256` to the `Deposit` struct, then declare that mapping as a public variable `deposits`.

```solidity
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    mapping(uint256 => Deposit) public deposits;
```



## The Constructor

Declare the constructor here, which is executed once when the contract is deployed. Our constructor hard codes the address of the nonfungible position manager interface, V3 router, and the periphery immutable state constructor, which requires the factory and the address of weth9 (the [ERC-20 wrapper](https://weth.io/) for ether).

```solidity
    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }
```



## Allowing custody of ERC721 tokens

To allow the contract to custody ERC721 tokens, implement the `onERC721Received` function within the inherited `IERC721Receiver.sol` [contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol).

The `from` identifier may be omitted because it is not used.

```solidity
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information
        _createDeposit(operator, tokenId);
        return this.onERC721Received.selector;
    }
```



## Creating a Deposit

To add a `Deposit` instance to the `deposits` mapping, create an internal function called `_createDeposit` that destructures the `positions` struct returned by `positions` in `nonfungiblePositionManager.sol`. Pass the relevant variables `token0` `token1` and `liquidity` to the `deposits` mapping.

```solidity
    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }
```



## The Full Contract Setup

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '../libraries/TransferHelper.sol';
import '../interfaces/INonfungiblePositionManager.sol';
import '../base/LiquidityManagement.sol';

contract LiquidityExamples is IERC721Receiver {
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;

    INonfungiblePositionManager public immutable nonfungiblePositionManager;

    /// @notice Represents the deposit of an NFT
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    /// @dev deposits[tokenId] => Deposit
    mapping(uint256 => Deposit) public deposits;

    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager
    ) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }

    // Implementing `onERC721Received` so this contract can receive custody of erc721 tokens
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information

        _createDeposit(operator, tokenId);

        return this.onERC721Received.selector;
    }

    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }
}
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[Mint a New Position](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/mint-a-position)

# Mint a New Position

## Input Parameters

To mint a new position, we use the `nonFungiblePositionManager` and call `mint`.

For the sake of this example, we're hard coding the token amounts to be minted. In production, this would be a user-configurable function argument.

```solidity
    /// @notice Calls the mint function defined in periphery, mints the same amount of each token. For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;
```



## Calling Mint

Here we approve the `nonfungiblePositionManager` to use the contracts' tokens, then populate the `MintParams` struct and assign it to a local variable `params` that will be passed to the `nonfungiblePositionManager` when we call `mint`.

- By using `TickMath.MIN_TICK` and `TickMath.MAX_TICK`, we are providing liquidity across the whole range of the pool. These will give a min tick of `-887272` and a max tick of `887272`. This works as is with the 0.01% pool, However other pools will need to use the correct tick spacing for the pool you are working with. Tick spacing for the pools are `0.01% == 1 tick spacing, 0.3% == 60 tick spacing, 0.05 == 10 tick spacing, 1% == 200 tick spacing`. So when setting up a pool with a different tick spacing, you will need to use a tick that is evenly divisible by the spacing. You can get the tick spacing by casting the contract of the pool address, and calling `tickSpacing()`. In production you may want to specify a more concentrated position, where you would take x of these tick spaces around the current active tick range.

```solidity
    tickLower: (TickMath.MIN_TICK / tickSpacing) * tickSpacing,
    tickUpper: (TickMath.MAX_TICK / tickSpacing) * tickSpacing,
```



- We set `amount0Min` and `amount1Min` to zero for the example - but this would be a vulnerability in production. A function calling `mint` with no slippage protection would be vulnerable to a frontrunning attack designed to execute the `mint` call at an inaccurate price.
- For a more secure practice the developer would need to implement a slippage estimation process.
- Note that this function will not initialize a pool where one does not yet exist.

```solidity
        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);
```



## Updating The Deposit Mapping And Refunding The Calling Address

Now we can call the internal function we previously wrote in [Setting Up Your Contract](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/setting-up). After that, we can take any liquidity leftover from minting and refund it to `msg.sender`.

```solidity
        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }
```



## The Full Example

```solidity
    /// @notice Calls the mint function defined in periphery, mints the same amount of each token. For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;

        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);

        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[Collecting Fees](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/collect-fees)

# Collecting Fees

- Make sure to go through the [first guide](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/setting-up) before continuing to this section.
- For each of these liquidity interaction examples, our contract must be in possession of the liquidity position NFT. Therefore, in any example where the NFT deposit is not coded into a function, the contract is assumed to already be in possession of it.

To collect the fees of an owner position, transfer the NFT from the calling address, assign the relevant variables from the NFT to local variables within our function, and pass those variables to the`nonfungiblePositionManager` to call `collect`.

This function collects all fees, sending them to the original owner of the NFT, while maintaining custody of the position NFT.

```solidity
    /// @notice Collects the fees associated with provided liquidity
    /// @dev The contract must hold the erc721 token before it can collect fees
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collectAllFees(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // Caller must own the ERC721 position
        // Call to safeTransfer will trigger `onERC721Received` which must return the selector else transfer will fail
        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);

        // set amount0Max and amount1Max to uint256.max to collect all fees
        // alternatively can set recipient to msg.sender and avoid another transaction in `sendToOwner`
        INonfungiblePositionManager.CollectParams memory params =
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            });

        (amount0, amount1) = nonfungiblePositionManager.collect(params);

        // send collected feed back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }
```



## Sending Fees To The Calling Address

This internal helper function sends any tokens, in the form of fees or position tokens, to the owner of an NFT.

In `_sendToOwner`, we pass the amount of fees due, previously populated in the last function, as arguments to `safeTransfer`, which transfers the fees to `owner`.

```solidity
    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[Decrease Liquidity](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/decrease-liquidity)

# Decrease Liquidity

Make sure to go through the [Setting Up Your Contract](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/setting-up) before continuing to this section

Here we decrease the liquidity of our position without withdrawing all of it.

- This example assumes the contract already has possession of the position NFT, and requires the calling address to be the same address that deposited the position NFT to our contract.
- In production, `amount0Min` and `amount1Min` should be adjusted to create slippage protections.

## Decrease Liquidity

```solidity
    /// @notice A function that decreases the current liquidity by half. An example to show how to call the `decreaseLiquidity` function defined in periphery.
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount received back in token0
    /// @return amount1 The amount returned back in token1
    function decreaseLiquidityInHalf(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // caller must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // get liquidity data for tokenId
        uint128 liquidity = deposits[tokenId].liquidity;
        uint128 halfLiquidity = liquidity / 2;

        // amount0Min and amount1Min are price slippage checks
        // if the amount received after burning is not greater than these minimums, transaction will fail
        INonfungiblePositionManager.DecreaseLiquidityParams memory params =
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: tokenId,
                liquidity: halfLiquidity,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        nonfungiblePositionManager.decreaseLiquidity(params);

        (amount0, amount1) = nonfungiblePositionManager.collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );

        //send liquidity back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }
```



## Sending Fees To The Calling Address

This internal helper function sends any tokens, in the form of fees or position tokens, to the owner of an NFT.

In `_sendToOwner`, we pass the amount of fees due, previously populated in the last function, as arguments to `safeTransfer`, which transfers the fees to `owner`.

```solidity
    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[Increase Liquidity](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/increase-liquidity)

# Increase Liquidity

## Increase Liquidity Within The Current Range

Make sure to go through the [first guide](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/setting-up) before continuing to this section

- This example assumes the contract already has custody of the NFT.
- We cannot change the boundaries of a given liquidity position using the Uniswap v3 protocol; `increaseLiquidity` can only increase the liquidity of a position.
- In production, `amount0Min` and `amount1Min` should be adjusted to create slippage protections.

```solidity
    /// @notice Increases liquidity in the current range
    /// @dev Pool must be initialized already to add liquidity
    /// @param tokenId The id of the erc721 token
    /// @param amount0 The amount to add of token0
    /// @param amount1 The amount to add of token1
    function increaseLiquidityCurrentRange(
        uint256 tokenId,
        uint256 amountAdd0,
        uint256 amountAdd1
    )
        external
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        INonfungiblePositionManager.IncreaseLiquidityParams memory params =
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: tokenId,
                amount0Desired: amountAdd0,
                amount1Desired: amountAdd1,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        (liquidity, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(params);
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesProviding Liquidity[The Full Contract](https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/the-full-contract)

# The Full Contract

Below we have the complete functioning code example: a contract that can custody Uniswap V3 position NFT's and manipulate the positions and liquidity therein by collecting fees, increasing or decreasing liquidity, and minting new positions. View on github [here](https://github.com/Uniswap/uniswap-docs/blob/main/examples/smart-contracts/LiquidityExamples.sol).

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '../libraries/TransferHelper.sol';
import '../interfaces/INonfungiblePositionManager.sol';
import '../base/LiquidityManagement.sol';

contract LiquidityExamples is IERC721Receiver {
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;

    INonfungiblePositionManager public immutable nonfungiblePositionManager;

    /// @notice Represents the deposit of an NFT
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    /// @dev deposits[tokenId] => Deposit
    mapping(uint256 => Deposit) public deposits;

    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager
    ) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }

    // Implementing `onERC721Received` so this contract can receive custody of erc721 tokens
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information

        _createDeposit(operator, tokenId);

        return this.onERC721Received.selector;
    }

    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }

    /// @notice Calls the mint function defined in periphery, mints the same amount of each token.
    /// For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;

        // transfer tokens to contract
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amount0ToMint);
        TransferHelper.safeTransferFrom(USDC, msg.sender, address(this), amount1ToMint);

        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);

        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }

    /// @notice Collects the fees associated with provided liquidity
    /// @dev The contract must hold the erc721 token before it can collect fees
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collectAllFees(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // Caller must own the ERC721 position, meaning it must be a deposit

        // set amount0Max and amount1Max to uint256.max to collect all fees
        // alternatively can set recipient to msg.sender and avoid another transaction in `sendToOwner`
        INonfungiblePositionManager.CollectParams memory params =
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            });

        (amount0, amount1) = nonfungiblePositionManager.collect(params);

        // send collected feed back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }

    /// @notice A function that decreases the current liquidity by half. An example to show how to call the `decreaseLiquidity` function defined in periphery.
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount received back in token0
    /// @return amount1 The amount returned back in token1
    function decreaseLiquidityInHalf(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // caller must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // get liquidity data for tokenId
        uint128 liquidity = deposits[tokenId].liquidity;
        uint128 halfLiquidity = liquidity / 2;

        // amount0Min and amount1Min are price slippage checks
        // if the amount received after burning is not greater than these minimums, transaction will fail
        INonfungiblePositionManager.DecreaseLiquidityParams memory params =
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: tokenId,
                liquidity: halfLiquidity,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);

        //send liquidity back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }

    /// @notice Increases liquidity in the current range
    /// @dev Pool must be initialized already to add liquidity
    /// @param tokenId The id of the erc721 token
    /// @param amount0 The amount to add of token0
    /// @param amount1 The amount to add of token1
    function increaseLiquidityCurrentRange(
        uint256 tokenId,
        uint256 amountAdd0,
        uint256 amountAdd1
    )
        external
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        ) {

        TransferHelper.safeTransferFrom(deposits[tokenId].token0, msg.sender, address(this), amountAdd0);
        TransferHelper.safeTransferFrom(deposits[tokenId].token1, msg.sender, address(this), amountAdd1);

        TransferHelper.safeApprove(deposits[tokenId].token0, address(nonfungiblePositionManager), amountAdd0);
        TransferHelper.safeApprove(deposits[tokenId].token1, address(nonfungiblePositionManager), amountAdd1);

        INonfungiblePositionManager.IncreaseLiquidityParams memory params = INonfungiblePositionManager.IncreaseLiquidityParams({
            tokenId: tokenId,
            amount0Desired: amountAdd0,
            amount1Desired: amountAdd1,
            amount0Min: 0,
            amount1Min: 0,
            deadline: block.timestamp
        });

        (liquidity, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(params);

    }

    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }

    /// @notice Transfers the NFT to the owner
    /// @param tokenId The id of the erc721
    function retrieveNFT(uint256 tokenId) external {
        // must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // transfer ownership to original owner
        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);
        //remove information related to tokenId
        delete deposits[tokenId];
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesLiquidity Mining[Overview](https://docs.uniswap.org/contracts/v3/guides/liquidity-mining/overview)

# Overview

## Introduction

As a DeFi project, token creator, or other interested party, you may want to *incentivize in-range liquidity provision* on a Uniswap V3 pool. This guide describes one particular incentivization scheme at a high level, as implemented in [uniswap-v3-staker](https://github.com/Uniswap/uniswap-v3-staker).

## The Setting

Let's start by defining some terms. We refer to programs which incentivize liquidity as `Incentive`s; they're characterized by the following parameters:

- `rewardToken`: Perhaps the most important parameter, would-be incentivizers must pick the ERC20 token which they would like to distribute as a reward for providing liquidity.
- `pool`: The address of the Uniswap V3 pool in which liquidity must be provided.
- `startTime`: The UNIX timestamp at which rewards start to be distributed.
- `endTime`: The UNIX timestamp at which rewards start to decay.
- `refundee`: The address which has the right to reclaim any leftover rewards after the `Incentive` has concluded.

Finally, every `Incentive` has an associated `reward`, the total amount of `rewardToken`s that are allocated to be distributed over the lifecycle of the program.

## Reward Math

Now that we have an idea of what an `Incentive` looks like, let's explore how rewards are actually allocated to participants. The next section will touch on the participation mechanics, so for now let's abstract this away and just focus on the high-level design.

Recall that `Incentive` creators pick a `reward` amount and a program duration. This directly corresponds to picking *an amount of `rewardToken`s to distribute per second*; let's call this the reward rate. So, for every second between `startTime` and `endTime`, a constant amount of tokens are distributed proportionally *among all in-range liquidity at that second*. Crucially, this counts *all* liquidity, not just liquidity that opts in to participating in the program. So, incentive creators should pick a reward rate that they deem worthwhile to distribute across (potentially) all in-range LPs for the duration of the program.

## Staking

So, how do users participate in these programs? Note that this section requires a basic understanding of [how Uniswap V3 position NFTs work](https://docs.uniswap.org/contracts/v3/reference/periphery/NonfungiblePositionManager)

The first action a user must take in order to begin participating in an `Incentive` is to *deposit* their position NFT into the [canonical staking contract address](https://github.com/Uniswap/uniswap-v3-staker#deployments), effectively temporarily giving custody over their NFT to this contract. This is necessary because, as we'll see later on, the staking contract needs to be able to guarantee that liquidity cannot be removed from NFTs participating in the program.

Once deposited, a user may then *stake* their NFT into any number of active `Incentive`s for the Uniswap V3 pool their NFT is tied to (note that this can happen atomically with an initial *deposit*). Staked NFTs then immediately start to earn rewards, according to the algorithm outlined above. Users may periodically claim accrued `rewardToken`s while the program is ongoing, or wait to claim until the program has concluded to minimize overhead.

## Program Conclusion

There are two conditions that must be met for a program to be considered concluded:

1. `block.timestamp >= endTime`: In other words, the program's duration must have expired. However, this doesn't mark the official end of the program, as some users may still be participating right up until this `endTime` boundary and beyond, to maximize their rewards. This leads directly to the second condition.
2. All NFTs must be unstaked: A program can conclude only when every NFT which participated in it is unstaked. To ensure this is always possible, after the `endTime` of a program *anyone* may unstake *any* NFT (though of course they may not claim outstanding `rewardToken`s due to the NFT owner). This ensures that even if all users do not unstake themselves, someone can unstake them manually so that the program can end.

It's important that most or all programs fully conclude, primarily so that the `refundee` can reclaim any unallocated rewards. What are the conditions under which unallocated rewards will remain? Well, recall that the reward rate is the same across *all* in-range liquidity. However, only program participants may actually claim accrued tokens, so it's likely that all programs will end up with a balance of `rewardToken`s that cannot be claimed. So, `refundee`s will typically be incentivized to bring programs to an official conclusion. This slightly cumbersome design is a consequence of the difficulty of consistently allocating rewards proportional to Uniswap V3 liquidity.

A final note: stakers who remain in the program after `endTime` may actually see their rewards marginally augmented or (more likely) gradually diluted. The magnitude of these changes depend on stakers' share of the total active liquidity, the time spend staked after `endTime`, and the sequence of unstaking. In the worst case, rewards decay proportionally to the duration. For example, at 2x the duration, ½ of rewards could remain, at 3x, ⅓ could remain, etc. While somewhat complex, this behavior can largely be ignored from a game-theoretic standpoint. Stakers should simply attempt to unstake and claim rewards as soon as possible after `endTime`, an outcome that is likely in any case, as `refundee`s will be eager to reclaim leftover rewards, and mass unstake stragglers.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement Flash Swaps[Getting Started](https://docs.uniswap.org/contracts/v3/guides/flash-integrations/inheritance-constructors)

# Getting Started

In this guide, we will write a smart contract that calls `flash` on a V3 pool and swaps the full amount withdrawn of `token0` and `token1` in the corresponding pools with the same token pair - but different fee tiers. After the swap, the contract will pay back the first pool and transfer profits to the original calling address.

The ability to make a profit comes from the difference in the price ratio between `token0` and `token1` in the different pools, not necessarily from the different fee tiers. While the fee tiers can affect the overall cost of the trade, the primary factor that allows for profitable swaps is the difference in price ratios.

The contract is designed to withdraw tokens from a V3 pool, swap them in a different V3 pool with the same token pair but different price ratio and fee tier, and then pay back the original pool and transfer any profits to the calling address. By swapping the tokens in a different pool with a different price ratio, the contract is able to take advantage of the price difference and make a profit.

The fees charged by the pools have an impact on the profitability of the trade. Lower fees can make it easier to profit from the trade because the price difference needed to cover the fees and still make a profit is smaller. However, other factors such as the amount of liquidity available in the pools, slippage, gas fees, and market volatility also play a role in determining the profitability of the trade. So while lower fees can make it easier to profit from a trade, it's not the only factor to consider.

This code is intended to be just an example. For this reason, readers should do their own research to avoid losing their funds.

## Flash Transactions Overview

Flash transactions are an approach to transferring tokens on Ethereum that transfer token balances *before* the necessary conditions are met for those balances to be transferred. In the context of a swap, this would mean the output is sent from the swap before the input is received.

Uniswap V3 introduces a new function, `flash`, within the Pool contract. `Flash` withdraws a specified amount of both `token0` and `token1` to the `recipient` address. The withdrawn amount, plus the swap fees, will be due to the pool at the end of the transaction. `flash` includes a fourth parameter, `data`, which allows the caller to abi.encode any necessary data to be passed through the function and decoded later.

```solidity
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external override lock noDelegateCall {
```



## The Flash Callback

`flash` will withdraw the tokens, but how are they paid back? To understand this, we must look inside the flash function code. midway through the [**flash**](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L791) function, we see this:

```solidity
IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
```



This step calls the `FlashCallback` function on `msg.sender` - which passes the fee data needed to calculate the balances due to the pool, as well as any data encoded into the `data` parameter.

In V3 there are three separate callback functions, `uniswapV3SwapCallback`, `uniswapV3MintCallback`, and `uniswapV3FlashCallback`, each available to be overridden with custom logic. To write our arbitrage contract, we'll be calling `flash` and overriding the `uniswapV3FlashCallback` with the steps needed to finish executing our transaction.

## Inheriting The V3 Contracts

Inherit `IUniswapV3FlashCallback` and `PeripheryPayments`, as we will use each in our program. Note these two inherited contracts already extend many other contracts that we will be using, such as [LowGasSafeMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/LowGasSafeMath) which we [attach](https://docs.soliditylang.org/en/v0.7.6/contracts.html?highlight=using#using-for), to types `uint256` and `int256`.

```solidity
contract PairFlash is IUniswapV3FlashCallback, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;
```



Declare an immutable public variable `swapRouter` of type `ISwapRouter`:

```solidity
    ISwapRouter public immutable swapRouter;
```



Declare the constructor here, which is executed once when the contract is deployed. Our constructor hardcodes the address of the V3 router, factory, and the address of weth9, the [ERC-20 wrapper](https://weth.io/) for ether.

```solidity
    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }
```



The full import section and contract declaration:

```solidity
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol';
import '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';

import '@uniswap/v3-periphery/contracts/base/PeripheryPayments.sol';
import '@uniswap/v3-periphery/contracts/base/PeripheryImmutableState.sol';
import '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';
import '@uniswap/v3-periphery/contracts/libraries/CallbackValidation.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';



contract PairFlash is IUniswapV3FlashCallback, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;

    ISwapRouter public immutable swapRouter;

    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement Flash Swaps[Calling Flash](https://docs.uniswap.org/contracts/v3/guides/flash-integrations/calling-flash)

# Calling Flash

## Parameter Structs

In order to call `flash`, we will need the flash parameters for the initial call, as well as any parameters we want to pass through to the callback.

The `FlashParams` struct will contain the token addresses and amounts we wish to pull out of the pool, as well as the three fee tiers used to determine which pool we are withdrawing from, and which we will be swapping with.

```solidity
  struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }
```



The `FlashCallbackData` struct will contain the data we want to send to the callback. This includes `poolKey`, which expresses the sorted tokens with the matched fee tier, returned by the [**PoolAddress**](https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/PoolAddress.sol) library.

```solidity
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }
```



## Pool Key

Now we'll start our function by assigning the relevant parameters from the `Flashparams` (which we have declared in memory as `params`) to our variable `poolKey`

```solidity
    function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
    }
```



Next we will declare `pool` as type [**IUniswapV3Pool**], which allows us to call `flash` on our desired pool contract.

```solidity
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
```



## Calling Flash

Finally, we call `flash` on our previously declared `pool`. In the last parameter, we abi.encode the `FlashCallbackData`, which will be decoded in the callback and used to inform the next steps of the transaction.

```solidity
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
```



The full function:

```solidity
    //fee1 is the fee of the pool from the initial borrow
    //fee2 is the fee of the first pool to arb from
    //fee3 is the fee of the second pool to arb from
    struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }

    // fee2 and fee3 are the two other fees associated with the two other pools of token0 and token1
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }

function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement Flash Swaps[The Flash Callback](https://docs.uniswap.org/contracts/v3/guides/flash-integrations/flash-callback)

# The Flash Callback

## Setting Up The Callback

Here we will override the flash callback with our custom logic to execute the desired swaps and pay the profits to the original `msg.sender`.

Declare the `uniswapV3FlashCallback` function and override it.

```solidity
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
```



Declare a variable `decoded` in memory and assign it to the [**decoded data**](https://docs.soliditylang.org/en/v0.7.6/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions) previously encoded into the calldata.

```solidity
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
```



Each callback must be validated to verify that the call originated from a genuine V3 pool. Otherwise, the PairFlash contract would be vulnerable to attack via an EOA manipulating the callback function.

```solidity
        CallbackValidation.verifyCallback(factory, decoded.poolKey);
```



Assign local variables of type `address` as `token0` and `token1` to approve the router to interact with the tokens from the flash.

```solidity
        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);
```



Code in a minimum amount out for both of the upcoming swaps, such that the following swaps will revert if we do not receive a profitable trade.

```solidity
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);
```



## Initiating A Swap

Call the first of two swaps, calling `exactInputSingle` on the [**router interface**](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter) contract. In this call, we are using the previously declared `amount0In` as the minimum amount out, and assigning the returned balance of the swap to `amountOut0`.

Most of These function arguments have already been discussed, except for two new introductions:

`sqrtPriceLimitX96`: This value limits the price that the swap can change the pool to. Remember that price is always expressed in the pool contract as `token1` in terms of `token0`. This is useful for circumstances where the user wants to swap *up until* a specific price. For this example, we will set it to 0, which makes the argument inactive.

`deadline`: this is the timestamp after which the transaction will revert, to protect the transaction from dramatic changes in price environment that can happen if the transaction is pending for too long. For this example, we will set it far in the future for the sake of simplicity.

The first swap takes the `amount1` that we withdrew from the original pool, and passes that amount as the input amount for a single swap that trades a fixed input for the maximum amount of possible output. It calls this function on the pool determined by our previous token pair, but with the next fee tier in our list of three.

```solidity
uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );
```



Populate the second of two swaps, this time with the last fee tier and with the `amount0` that we withdrew from the original pool.

```solidity
uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );
```



## Paying back the pool

To pay the original pool back for the flash transaction, first calculate the balance due to it and approve the router to transfer the tokens in our contract back to the pool.

```solidity
uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

TransferHelper.safeApprove(token0, address(this), amount0Owed);
TransferHelper.safeApprove(token1, address(this), amount1Owed);
```



If there is any balance due to the token, use simple logic to call [pay](https://docs.uniswap.org/contracts/v3/reference/periphery/base/PeripheryPayments#pay). Remember that the callback function is being called by the pool itself, which is why we can call `pay` despite the function being marked `internal`.

```solidity
if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);
```



Send the profits to the `payer`: the original `msg.sender` of the `initFlash` function, which executed the flash transaction and in turn triggered the callback.

```solidity
    if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }

    if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
```



## The full function

```solidity
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
        CallbackValidation.verifyCallback(factory, decoded.poolKey);

        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);

        // profitable check
        // exactInputSingle will fail if this amount not met
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);

        // call exactInputSingle for swapping token1 for token0 in pool w/fee2
        uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // call exactInputSingle for swapping token0 for token 1 in pool w/fee3
        uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // end up with amountOut0 of token0 from first swap and amountOut1 of token1 from second swap
        uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
        uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

        TransferHelper.safeApprove(token0, address(this), amount0Owed);
        TransferHelper.safeApprove(token1, address(this), amount1Owed);

        if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
        if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);

        // if profitable pay profits to payer
        if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }
        if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
    }
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesImplement Flash Swaps[The Final Contract](https://docs.uniswap.org/contracts/v3/guides/flash-integrations/final-contract)

# The Final Contract

## The Full Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol';
import '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';

import '@uniswap/v3-periphery/contracts/base/PeripheryPayments.sol';
import '@uniswap/v3-periphery/contracts/base/PeripheryImmutableState.sol';
import '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';
import '@uniswap/v3-periphery/contracts/libraries/CallbackValidation.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

/// @title Flash contract implementation
/// @notice An example contract using the Uniswap V3 flash function
contract PairFlash is IUniswapV3FlashCallback, PeripheryImmutableState, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;

    ISwapRouter public immutable swapRouter;

    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }

    /// @param fee0 The fee from calling flash for token0
    /// @param fee1 The fee from calling flash for token1
    /// @param data The data needed in the callback passed as FlashCallbackData from `initFlash`
    /// @notice implements the callback called from flash
    /// @dev fails if the flash is not profitable, meaning the amountOut from the flash is less than the amount borrowed
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
        CallbackValidation.verifyCallback(factory, decoded.poolKey);

        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);

        // profitable check
        // exactInputSingle will fail if this amount not met
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);

        // call exactInputSingle for swapping token1 for token0 in pool w/fee2
        uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // call exactInputSingle for swapping token0 for token 1 in pool w/fee3
        uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // end up with amountOut0 of token0 from first swap and amountOut1 of token1 from second swap
        uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
        uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

        TransferHelper.safeApprove(token0, address(this), amount0Owed);
        TransferHelper.safeApprove(token1, address(this), amount1Owed);

        if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
        if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);

        // if profitable pay profits to payer
        if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }
        if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
    }

    //fee1 is the fee of the pool from the initial borrow
    //fee2 is the fee of the first pool to arb from
    //fee3 is the fee of the second pool to arb from
    struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }
    // fee2 and fee3 are the two other fees associated with the two other pools of token0 and token1
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }

    /// @param params The parameters necessary for flash and the callback, passed in as FlashParams
    /// @notice Calls the pools flash function with data needed in `uniswapV3FlashCallback`
    function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
        // recipient of borrowed amounts
        // amount of token0 requested to borrow
        // amount of token1 requested to borrow
        // need amount 0 and amount1 in callback to pay back pool
        // recipient of flash should be THIS contract
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
    }
}
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolGuidesGovernance Proposals[License Modifications](https://docs.uniswap.org/contracts/v3/guides/governance/license-modifications)

# License Modifications

## Licensing

Please note that Uniswap V3 is under [BUSL license](https://github.com/Uniswap/v3-core#licensing) until the Change Date, currently 2023-04-01. Exceptions to the license may be specified by Uniswap Governance via Additional Use Grants, which can, for example, allow V3 to be deployed on new chains. Please follow the [Uniswap Governance process](https://gov.uniswap.org/t/community-governance-process/7732) to request a DAO vote for exceptions to the license, or to move up the Change Date.

License changes must be enacted via the [ENS domain](https://ens.domains/) uniswap.eth, which is controlled by Uniswap Governance. This means (among other things) that Governance has the power to associate arbitrary text with any subdomain of the form X.uniswap.eth. Modifications of the Change Date should be specified at v3-core-license-date.uniswap.eth, and Additional Use Grants should be specified at v3-core-license-grants.uniswap.eth. The process for associating text with a subdomain is detailed below:

<details class="details_lb9f isBrowser_bmU9 alert alert--info details_b_Ee" data-collapsed="true" style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; color: rgb(25, 60, 71); --ifm-alert-background-color: #eef9fd; --ifm-alert-background-color-highlight: #54c7ec26; --ifm-alert-foreground-color: #193c47; --ifm-alert-border-color: #4cb3d4; --ifm-code-background: #54c7ec26; --ifm-link-color: #193c47; --ifm-link-hover-color: #193c47; --ifm-link-decoration: underline; --ifm-tabs-color: #193c47; --ifm-tabs-color-active: #193c47; --ifm-tabs-color-active-border: #4cb3d4; background-color: rgb(238, 249, 253); border-color: rgb(76, 179, 212); border-style: solid; border-width: 1px; border-image: none 100% / 1 / 0 stretch; border-radius: 6.4px; box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px 0px; padding: 16px; --docusaurus-details-summary-arrow-size: 0.38rem; --docusaurus-details-transition: transform 200ms ease; --docusaurus-details-decoration-color: #4cb3d4; margin: 24px 0px 0px; --tw-space-y-reverse: 0;"><summary style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; cursor: pointer; list-style: none; padding-left: 1rem; position: relative;">ENS Subdomain Details &amp; Process</summary></details>

## Proposals

Proposals are submitted via `GovernorBravoDelegator` @ `0x408ED6354d4973f66138C91495F2f2FCbd8724C3`, a proxy contract currently pointing to the implementation at `0x53a328F4086d7C0F1Fa19e594c9b842125263026`. NPM packages for consuming the governance contract ABIs, and details on previous versions, are available [here](https://docs.uniswap.org/concepts/governance/overview)

<details class="details_lb9f isBrowser_bmU9 alert alert--info details_b_Ee" data-collapsed="true" style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; color: rgb(25, 60, 71); --ifm-alert-background-color: #eef9fd; --ifm-alert-background-color-highlight: #54c7ec26; --ifm-alert-foreground-color: #193c47; --ifm-alert-border-color: #4cb3d4; --ifm-code-background: #54c7ec26; --ifm-link-color: #193c47; --ifm-link-hover-color: #193c47; --ifm-link-decoration: underline; --ifm-tabs-color: #193c47; --ifm-tabs-color-active: #193c47; --ifm-tabs-color-active-border: #4cb3d4; background-color: rgb(238, 249, 253); border-color: rgb(76, 179, 212); border-style: solid; border-width: 1px; border-image: none 100% / 1 / 0 stretch; border-radius: 6.4px; box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px 0px; padding: 16px; --docusaurus-details-summary-arrow-size: 0.38rem; --docusaurus-details-transition: transform 200ms ease; --docusaurus-details-decoration-color: #4cb3d4; margin: 24px 0px 0px; --tw-space-y-reverse: 0;"><summary style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; cursor: pointer; list-style: none; padding-left: 1rem; position: relative;">Governor Bravo #propose Parameters</summary></details>

## Populating Proposal Calldata

Below is an example of using a scripting environment to generate a proposal. This is for educational purposes only - that example assumes access to a private key with a sufficient amount of delegated UNI to submit a proposal, which is an insecure practice. There are several ways to generate a proposal transaction and submit it to Ethereum; this example should only be used for reference and not in production.

<details class="details_lb9f isBrowser_bmU9 alert alert--info details_b_Ee" data-collapsed="true" style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; color: rgb(25, 60, 71); --ifm-alert-background-color: #eef9fd; --ifm-alert-background-color-highlight: #54c7ec26; --ifm-alert-foreground-color: #193c47; --ifm-alert-border-color: #4cb3d4; --ifm-code-background: #54c7ec26; --ifm-link-color: #193c47; --ifm-link-hover-color: #193c47; --ifm-link-decoration: underline; --ifm-tabs-color: #193c47; --ifm-tabs-color-active: #193c47; --ifm-tabs-color-active-border: #4cb3d4; background-color: rgb(238, 249, 253); border-color: rgb(76, 179, 212); border-style: solid; border-width: 1px; border-image: none 100% / 1 / 0 stretch; border-radius: 6.4px; box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px 0px; padding: 16px; --docusaurus-details-summary-arrow-size: 0.38rem; --docusaurus-details-transition: transform 200ms ease; --docusaurus-details-decoration-color: #4cb3d4; margin: 24px 0px 0px; --tw-space-y-reverse: 0;"><summary style="box-sizing: border-box; font-style: unset; font-weight: unset; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; cursor: pointer; list-style: none; padding-left: 1rem; position: relative;">Populating<span>&nbsp;</span><code style="box-sizing: border-box; font-style: normal !important; font-weight: 400 !important; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-gradient-from-position: ; --tw-gradient-via-position: ; --tw-gradient-to-position: ; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: #3b82f680; --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; --tw-contain-size: ; --tw-contain-layout: ; --tw-contain-paint: ; --tw-contain-style: ; vertical-align: middle; background-color: rgba(84, 199, 236, 0.15); border: 0.1rem solid rgba(0, 0, 0, 0.1); border-radius: 6.4px; font-family: &quot;Fragment Mono&quot;, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 0.8125rem !important; padding: 1.6px; letter-spacing: -0.00813rem !important; line-height: 1.05625rem !important; -webkit-font-smoothing: antialiased !important;">Propose</code><span>&nbsp;</span>Calldata</summary></details>

## Helpful Links

- [Governor Bravo Proxy](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#readProxyContract)
- [Governor Bravo Delegate](https://etherscan.io/address/0x53a328f4086d7c0f1fa19e594c9b842125263026#code)
- [ENS Subnode Record Update Details](https://github.com/Uniswap/deploy-v3#licensing)

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Overview](https://docs.uniswap.org/contracts/v3/reference/overview)

# Overview

Uniswap v3 is a binary smart contract system comprised of many libraries, which together make the Core and Periphery.

Core contracts provide fundamental safety guarantees for all parties interacting with Uniswap. They define the logic of pool generation, the pools themselves, and the interactions involving the respective assets therein.

Periphery contracts interact with one or more Core contracts but are not part of the core. They are designed to provide methods of interacting with the core that increase clarity and user safety.

External calls will primarily call the periphery interfaces. Externally available functions are all viewable in the reference documentation. Internal functions are viewable on the Uniswap v3 GitHub repo.

## Core

> [**Core Source Code**](https://github.com/Uniswap/uniswap-v3-core)

The core consists of a single factory, a pool deployer, and the many pools the factory will create.

A significant amount of care and attention has been given to gas optimization in the core contracts. The result is a substantial reduction in gas costs for all protocol interactions compared to V2, at the cost of a reduction in code clarity.

### Factory

> [**Factory Reference**](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Factory)

The factory defines the logic for generating pools. A pool is defined by two tokens, which make up the asset pair, and a fee. There can be multiple pools of the same asset pair, distinguished only by their swap fee.

### Pools

> [**Pool Reference**](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Pool).

Pools primarily serve as automated market makers for the paired assets. Additionally, they expose price oracle data and may be used as an asset source for flash transactions.

## Periphery

The periphery is a constellation of smart contracts designed to support domain-specific interactions with the core. As the Uniswap protocol is a permissionless system, the contracts described below have no special privileges and are only a small subset of possible periphery-like contracts.

### SwapRouter

> [**Swap Router Reference**](https://docs.uniswap.org/contracts/v3/reference/periphery/SwapRouter)

> [**Swap Router Interface**](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter)

The swap router supports all the basic requirements of a front-end offering trading. It natively supports single trades (x to y) and multihop trades (e.g. x to y to z).

### Nonfungible Position Manager

> [**Nonfungible Position Manager Reference**](https://docs.uniswap.org/contracts/v3/reference/periphery/NonfungiblePositionManager)

> [**Nonfungible Position Manager Interface**](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/INonfungiblePositionManager)

The position manager handles the logic transactions involving the creation, adjustment, or exiting of positions.

### Oracle

> [**Oracle Reference**](https://docs.uniswap.org/contracts/v3/reference/core/libraries/Oracle)

The oracle provides price and liquidity data useful for a wide variety of system designs, and is available in every deployed pool.

### Periphery Libraries

> [**Periphery Libraries**](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/Base64)

The libraries provide a variety of helper functions developers may need, like calculating pool addresses, safe transfer functions, and more.



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCore[UniswapV3Factory](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Factory)

# UniswapV3Factory

Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees

## Functions

### createPool

```solidity
  function createPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external returns (address pool)
```



Creates a pool for the given two tokens and fee

tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.

#### Parameters:

| Name     | Type    | Description                                     |
| :------- | :------ | :---------------------------------------------- |
| `tokenA` | address | One of the two tokens in the desired pool       |
| `tokenB` | address | The other of the two tokens in the desired pool |
| `fee`    | uint24  | The desired fee for the pool                    |

#### Return Values:

| Name   | Type    | Description                           |
| :----- | :------ | :------------------------------------ |
| `pool` | address | The address of the newly created pool |

### setOwner

```solidity
  function setOwner(
    address _owner
  ) external
```



Updates the owner of the factory

Must be called by the current owner

#### Parameters:

| Name     | Type    | Description                  |
| :------- | :------ | :--------------------------- |
| `_owner` | address | The new owner of the factory |

### enableFeeAmount

```solidity
  function enableFeeAmount(
    uint24 fee,
    int24 tickSpacing
  ) public
```



Enables a fee amount with the given tickSpacing

Fee amounts may never be removed once enabled

#### Parameters:

| Name          | Type   | Description                                                  |
| :------------ | :----- | :----------------------------------------------------------- |
| `fee`         | uint24 | The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) |
| `tickSpacing` | int24  | The spacing between ticks to be enforced for all pools created with the given fee amount |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCore[UniswapV3Pool](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Pool)

# UniswapV3Pool

## Functions

### _blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal view virtual returns (uint32)
```



Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.

### snapshotCumulativesInside

```solidity
  function snapshotCumulativesInside(
    int24 tickLower,
    int24 tickUpper
  ) external view override noDelegateCall returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
```



Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range

Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.

#### Parameters:

| Name        | Type  | Description                 |
| :---------- | :---- | :-------------------------- |
| `tickLower` | int24 | The lower tick of the range |
| `tickUpper` | int24 | The upper tick of the range |

#### Return Values:

| Name                            | Type    | Description                                         |
| :------------------------------ | :------ | :-------------------------------------------------- |
| `tickCumulativeInside`          | int56   | The snapshot of the tick accumulator for the range  |
| `secondsPerLiquidityInsideX128` | uint160 | The snapshot of seconds per liquidity for the range |
| `secondsInside`                 | uint32  | The snapshot of seconds per liquidity for the range |

### observe

```solidity
  function observe(
    uint32[] secondsAgos
  ) external view override noDelegateCall returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s)
```



Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp

To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.

#### Parameters:

| Name          | Type     | Description                                                  |
| :------------ | :------- | :----------------------------------------------------------- |
| `secondsAgos` | uint32[] | From how long ago each cumulative tick and liquidity value should be returned |

#### Return Values:

| Name                                 | Type      | Description                                                  |
| :----------------------------------- | :-------- | :----------------------------------------------------------- |
| `tickCumulatives`                    | int56[]   | Cumulative tick values as of each `secondsAgos` from the current block timestamp |
| `secondsPerLiquidityCumulativeX128s` | uint160[] | Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block |

timestamp

### increaseObservationCardinalityNext

```solidity
  function increaseObservationCardinalityNext(
    uint16 observationCardinalityNext
  ) external override lock noDelegateCall
```



Increase the maximum number of price and liquidity observations that this pool will store

This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.

#### Parameters:

| Name                         | Type   | Description                                                  |
| :--------------------------- | :----- | :----------------------------------------------------------- |
| `observationCardinalityNext` | uint16 | The desired minimum number of observations for the pool to store |

### initialize

```solidity
  function initialize(
    uint160 sqrtPriceX96
  ) external override
```



Sets the initial price for the pool

not locked because it initializes unlocked

#### Parameters:

| Name           | Type    | Description                                    |
| :------------- | :------ | :--------------------------------------------- |
| `sqrtPriceX96` | uint160 | the initial sqrt price of the pool as a Q64.96 |

### mint

```solidity
  function mint(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    bytes data
  ) external override lock returns (uint256 amount0, uint256 amount1)
```



Adds liquidity for the given recipient/tickLower/tickUpper position

noDelegateCall is applied indirectly via _modifyPosition

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `recipient` | address | The address for which the liquidity will be created      |
| `tickLower` | int24   | The lower tick of the position in which to add liquidity |
| `tickUpper` | int24   | The upper tick of the position in which to add liquidity |
| `amount`    | uint128 | The amount of liquidity to mint                          |
| `data`      | bytes   | Any data that should be passed through to the callback   |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback |
| `amount1` | uint256 | The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback |

### collect

```solidity
  function collect(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external override lock returns (uint128 amount0, uint128 amount1)
```



Collects tokens owed to a position

Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.

#### Parameters:

| Name               | Type    | Description                                              |
| :----------------- | :------ | :------------------------------------------------------- |
| `recipient`        | address | The address which should receive the fees collected      |
| `tickLower`        | int24   | The lower tick of the position for which to collect fees |
| `tickUpper`        | int24   | The upper tick of the position for which to collect fees |
| `amount0Requested` | uint128 | How much token0 should be withdrawn from the fees owed   |
| `amount1Requested` | uint128 | How much token1 should be withdrawn from the fees owed   |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint128 | The amount of fees collected in token0 |
| `amount1` | uint128 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    int24 tickLower,
    int24 tickUpper,
    uint128 amount
  ) external override lock returns (uint256 amount0, uint256 amount1)
```



Burn liquidity from the sender and account tokens owed for the liquidity to the position

noDelegateCall is applied indirectly via _modifyPosition

#### Parameters:

| Name        | Type    | Description                                                |
| :---------- | :------ | :--------------------------------------------------------- |
| `tickLower` | int24   | The lower tick of the position for which to burn liquidity |
| `tickUpper` | int24   | The upper tick of the position for which to burn liquidity |
| `amount`    | uint128 | How much liquidity to burn                                 |

#### Return Values:

| Name      | Type    | Description                                |
| :-------- | :------ | :----------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to the recipient |
| `amount1` | uint256 | The amount of token1 sent to the recipient |

### swap

```solidity
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes data
  ) external override noDelegateCall returns (int256 amount0, int256 amount1)
```



Swap token0 for token1, or token1 for token0

The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `recipient`         | address | The address to receive the output of the swap                |
| `zeroForOne`        | bool    | The direction of the swap, true for token0 to token1, false for token1 to token0 |
| `amountSpecified`   | int256  | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) |
| `sqrtPriceLimitX96` | uint160 | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |
| `data`              | bytes   | Any data to be passed through to the callback                |

#### Return Values:

| Name      | Type   | Description                                                  |
| :-------- | :----- | :----------------------------------------------------------- |
| `amount0` | int256 | The delta of the balance of token0 of the pool, exact when negative, minimum when positive |
| `amount1` | int256 | The delta of the balance of token1 of the pool, exact when negative, minimum when positive |

### flash

```solidity
  function flash(
    address recipient,
    uint256 amount0,
    uint256 amount1,
    bytes data
  ) external override lock noDelegateCall
```



Receive token0 and/or token1 and pay it back, plus a fee, in the callback

The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount1 and sending the donation amount(s) from the callback

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `recipient` | address | The address which will receive the token0 and token1 amounts |
| `amount0`   | uint256 | The amount of token0 to send                                 |
| `amount1`   | uint256 | The amount of token1 to send                                 |
| `data`      | bytes   | Any data to be passed through to the callback                |

### setFeeProtocol

```solidity
  function setFeeProtocol(
    uint8 feeProtocol0,
    uint8 feeProtocol1
  ) external override lock onlyFactoryOwner
```



Set the denominator of the protocol's % share of the fees

#### Parameters:

| Name           | Type  | Description                             |
| :------------- | :---- | :-------------------------------------- |
| `feeProtocol0` | uint8 | new protocol fee for token0 of the pool |
| `feeProtocol1` | uint8 | new protocol fee for token1 of the pool |

### collectProtocol

```solidity
  function collectProtocol(
    address recipient,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1)
```



Collect the protocol fee accrued to the pool

#### Parameters:

| Name               | Type    | Description                                                  |
| :----------------- | :------ | :----------------------------------------------------------- |
| `recipient`        | address | The address to which collected protocol fees should be sent  |
| `amount0Requested` | uint128 | The maximum amount of token0 to send, can be 0 to collect fees in only token1 |
| `amount1Requested` | uint128 | The maximum amount of token1 to send, can be 0 to collect fees in only token0 |

#### Return Values:

| Name      | Type    | Description                          |
| :-------- | :------ | :----------------------------------- |
| `amount0` | uint128 | The protocol fee collected in token0 |
| `amount1` | uint128 | The protocol fee collected in token1 |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCore[UniswapV3PoolDeployer](https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3PoolDeployer)

# UniswapV3PoolDeployer

## Functions

### deploy

```solidity
  function deploy(
    address factory,
    address token0,
    address token1,
    uint24 fee,
    int24 tickSpacing
  ) internal returns (address pool)
```



Deploys a pool with the given parameters by transiently setting the parameters storage slot and then clearing it after deploying the pool.

#### Parameters:

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `factory`     | address | The contract address of the Uniswap V3 factory               |
| `token0`      | address | The first token of the pool by address sort order            |
| `token1`      | address | The second token of the pool by address sort order           |
| `fee`         | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The spacing between usable ticks                             |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfaces[IERC20Minimal](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IERC20Minimal)

# IERC20Minimal

Contains a subset of the full ERC20 interface that is used in Uniswap V3

## Functions

### balanceOf

```solidity
  function balanceOf(
    address account
  ) external view returns (uint256)
```



Returns the balance of a token

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `account` | address | The account for which to look up the number of tokens it has, i.e. its balance |

#### Return Values:

| Type    | Description                          |
| :------ | :----------------------------------- |
| uint256 | number of tokens held by the account |

### transfer

```solidity
  function transfer(
    address recipient,
    uint256 amount
  ) external returns (bool)
```



Transfers the amount of token from the `msg.sender` to the recipient

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `recipient` | address | The account that will receive the amount transferred         |
| `amount`    | uint256 | The number of tokens to send from the sender to the recipient |

#### Return Values:

| Type | Description                                                  |
| :--- | :----------------------------------------------------------- |
| bool | true for a successful transfer, false for an unsuccessful transfer |

### allowance

```solidity
  function allowance(
    address owner,
    address spender
  ) external view returns (uint256)
```



Returns the current allowance given to a spender by an owner

#### Parameters:

| Name      | Type    | Description                      |
| :-------- | :------ | :------------------------------- |
| `owner`   | address | The account of the token owner   |
| `spender` | address | The account of the token spender |

#### Return Values:

| Type    | Description                                       |
| :------ | :------------------------------------------------ |
| uint256 | current allowance granted by `owner` to `spender` |

### approve

```solidity
  function approve(
    address spender,
    uint256 amount
  ) external returns (bool)
```



Sets the allowance of a spender from the `msg.sender` to the value `amount`

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `spender` | address | The account which will be allowed to spend a given amount of the owners tokens |
| `amount`  | uint256 | The amount of tokens allowed to be used by `spender`         |

#### Return Values:

| Type | Description                                            |
| :--- | :----------------------------------------------------- |
| bool | true for a successful approval, false for unsuccessful |

### transferFrom

```solidity
  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool)
```



Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`

#### Parameters:

| Name        | Type    | Description                                           |
| :---------- | :------ | :---------------------------------------------------- |
| `sender`    | address | The account from which the transfer will be initiated |
| `recipient` | address | The recipient of the transfer                         |
| `amount`    | uint256 | The amount of the transfer                            |

#### Return Values:

| Type | Description                                            |
| :--- | :----------------------------------------------------- |
| bool | true for a successful transfer, false for unsuccessful |

## Events

### Transfer

```solidity
  event Transfer(
    address from,
    address to,
    uint256 value
  )
```



Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.

#### Parameters:

| Name    | Type    | Description                                                  |
| :------ | :------ | :----------------------------------------------------------- |
| `from`  | address | The account from which the tokens were sent, i.e. the balance decreased |
| `to`    | address | The account to which the tokens were sent, i.e. the balance increased |
| `value` | uint256 | The amount of tokens that were transferred                   |

### Approval

```solidity
  event Approval(
    address owner,
    address spender,
    uint256 value
  )
```



Event emitted when the approval amount for the spender of a given owner's tokens changes.

#### Parameters:

| Name      | Type    | Description                                               |
| :-------- | :------ | :-------------------------------------------------------- |
| `owner`   | address | The account that approved spending of its tokens          |
| `spender` | address | The account for which the spending allowance was modified |
| `value`   | uint256 | The new allowance from the owner to the spender           |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfaces[IUniswapV3Factory](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory)

# IUniswapV3Factory

The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees

## Functions

### owner

```solidity
  function owner(
  ) external view returns (address)
```



Returns the current owner of the factory

Can be changed by the current owner via setOwner

#### Return Values:

| Type    | Description                  |
| :------ | :--------------------------- |
| address | address of the factory owner |

### feeAmountTickSpacing

```solidity
  function feeAmountTickSpacing(
    uint24 fee
  ) external view returns (int24)
```



Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled

A fee amount can never be removed, so this value should be hard coded or cached in the calling context

#### Parameters:

| Name  | Type   | Description                                                  |
| :---- | :----- | :----------------------------------------------------------- |
| `fee` | uint24 | The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee |

#### Return Values:

| Type  | Description  |
| :---- | :----------- |
| int24 | tick spacing |

### getPool

```solidity
  function getPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external view returns (address pool)
```



Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist

tokenA and tokenB may be passed in either token0/token1 or token1/token0 order

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `tokenA` | address | The contract address of either token0 or token1              |
| `tokenB` | address | The contract address of the other token                      |
| `fee`    | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |

#### Return Values:

| Name   | Type    | Description      |
| :----- | :------ | :--------------- |
| `pool` | address | The pool address |

### createPool

```solidity
  function createPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external returns (address pool)
```



Creates a pool for the given two tokens and fee

tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.

#### Parameters:

| Name     | Type    | Description                                     |
| :------- | :------ | :---------------------------------------------- |
| `tokenA` | address | One of the two tokens in the desired pool       |
| `tokenB` | address | The other of the two tokens in the desired pool |
| `fee`    | uint24  | The desired fee for the pool                    |

#### Return Values:

| Name   | Type    | Description                           |
| :----- | :------ | :------------------------------------ |
| `pool` | address | The address of the newly created pool |

### setOwner

```solidity
  function setOwner(
    address _owner
  ) external
```



Updates the owner of the factory

Must be called by the current owner

#### Parameters:

| Name     | Type    | Description                  |
| :------- | :------ | :--------------------------- |
| `_owner` | address | The new owner of the factory |

### enableFeeAmount

```solidity
  function enableFeeAmount(
    uint24 fee,
    int24 tickSpacing
  ) external
```



Enables a fee amount with the given tickSpacing

Fee amounts may never be removed once enabled

#### Parameters:

| Name          | Type   | Description                                                  |
| :------------ | :----- | :----------------------------------------------------------- |
| `fee`         | uint24 | The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) |
| `tickSpacing` | int24  | The spacing between ticks to be enforced for all pools created with the given fee amount |

## Events

### OwnerChanged

```solidity
  event OwnerChanged(
    address oldOwner,
    address newOwner
  )
```



Emitted when the owner of the factory is changed

#### Parameters:

| Name       | Type    | Description                            |
| :--------- | :------ | :------------------------------------- |
| `oldOwner` | address | The owner before the owner was changed |
| `newOwner` | address | The owner after the owner was changed  |

### PoolCreated

```solidity
  event PoolCreated(
    address token0,
    address token1,
    uint24 fee,
    int24 tickSpacing,
    address pool
  )
```



Emitted when a pool is created

#### Parameters:

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `token0`      | address | The first token of the pool by address sort order            |
| `token1`      | address | The second token of the pool by address sort order           |
| `fee`         | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The minimum number of ticks between initialized ticks        |
| `pool`        | address | The address of the created pool                              |

### FeeAmountEnabled

```solidity
  event FeeAmountEnabled(
    uint24 fee,
    int24 tickSpacing
  )
```



Emitted when a new fee amount is enabled for pool creation via the factory

#### Parameters:

| Name          | Type   | Description                                                  |
| :------------ | :----- | :----------------------------------------------------------- |
| `fee`         | uint24 | The enabled fee, denominated in hundredths of a bip          |
| `tickSpacing` | int24  | The minimum number of ticks between initialized ticks for pools created with the given fee |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfaces[IUniswapV3Pool](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Pool)

# IUniswapV3Pool

A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification

The pool interface is broken up into many smaller pieces



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfaces[IUniswapV3PoolDeployer](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3PoolDeployer)

# IUniswapV3PoolDeployer

A contract that constructs a pool must implement this to pass arguments to the pool

This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain

## Functions

### parameters

```solidity
  function parameters(
  ) external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing)
```



Get the parameters to be used in constructing the pool, set transiently during pool creation.

#### Return Values :

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `factory`     | address | The factory address                                          |
| `token0`      | address | The first token of the pool by address sort order            |
| `token1`      | address | The second token of the pool by address sort order           |
| `fee`         | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The minimum number of ticks between initialized ticks        |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacescallback[IUniswapV3FlashCallback](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/callback/IUniswapV3FlashCallback)

# IUniswapV3FlashCallback

Any contract that calls IUniswapV3PoolActions#flash must implement this interface

## Functions

### uniswapV3FlashCallback

```solidity
  function uniswapV3FlashCallback(
    uint256 fee0,
    uint256 fee1,
    bytes data
  ) external
```



Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.

In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `fee0` | uint256 | The fee amount in token0 due to the pool by the end of the flash |
| `fee1` | uint256 | The fee amount in token1 due to the pool by the end of the flash |
| `data` | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#flash call |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacescallback[IUniswapV3MintCallback](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/callback/IUniswapV3MintCallback)

# IUniswapV3MintCallback

Any contract that calls IUniswapV3PoolActions#mint must implement this interface

## Functions

### uniswapV3MintCallback

```solidity
  function uniswapV3MintCallback(
    uint256 amount0Owed,
    uint256 amount1Owed,
    bytes data
  ) external
```



Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.

In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `amount0Owed` | uint256 | The amount of token0 due to the pool for the minted liquidity |
| `amount1Owed` | uint256 | The amount of token1 due to the pool for the minted liquidity |
| `data`        | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#mint call |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacescallback[IUniswapV3SwapCallback](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/callback/IUniswapV3SwapCallback)

# IUniswapV3SwapCallback

Any contract that calls IUniswapV3PoolActions#swap must implement this interface

## Functions

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```



Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                  |
| :------------- | :----- | :----------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
| `amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
| `data`         | bytes  | Any data passed through by the caller via the IUniswapV3PoolActions#swap call. |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolActions](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolActions)

# IUniswapV3PoolActions

Contains pool methods that can be called by anyone

## Functions

### initialize

```solidity
  function initialize(
    uint160 sqrtPriceX96
  ) external
```



Sets the initial price for the pool

Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value

#### Parameters:

| Name           | Type    | Description                                    |
| :------------- | :------ | :--------------------------------------------- |
| `sqrtPriceX96` | uint160 | the initial sqrt price of the pool as a Q64.96 |

### mint

```solidity
  function mint(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    bytes data
  ) external returns (uint256 amount0, uint256 amount1)
```



Adds liquidity for the given recipient/tickLower/tickUpper position

The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `recipient` | address | The address for which the liquidity will be created      |
| `tickLower` | int24   | The lower tick of the position in which to add liquidity |
| `tickUpper` | int24   | The upper tick of the position in which to add liquidity |
| `amount`    | uint128 | The amount of liquidity to mint                          |
| `data`      | bytes   | Any data that should be passed through to the callback   |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback |
| `amount1` | uint256 | The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback |

### collect

```solidity
  function collect(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external returns (uint128 amount0, uint128 amount1)
```



Collects tokens owed to a position

Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.

#### Parameters:

| Name               | Type    | Description                                              |
| :----------------- | :------ | :------------------------------------------------------- |
| `recipient`        | address | The address which should receive the fees collected      |
| `tickLower`        | int24   | The lower tick of the position for which to collect fees |
| `tickUpper`        | int24   | The upper tick of the position for which to collect fees |
| `amount0Requested` | uint128 | How much token0 should be withdrawn from the fees owed   |
| `amount1Requested` | uint128 | How much token1 should be withdrawn from the fees owed   |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint128 | The amount of fees collected in token0 |
| `amount1` | uint128 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    int24 tickLower,
    int24 tickUpper,
    uint128 amount
  ) external returns (uint256 amount0, uint256 amount1)
```



Burn liquidity from the sender and account tokens owed for the liquidity to the position

Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0 Fees must be collected separately via a call to #collect

#### Parameters:

| Name        | Type    | Description                                                |
| :---------- | :------ | :--------------------------------------------------------- |
| `tickLower` | int24   | The lower tick of the position for which to burn liquidity |
| `tickUpper` | int24   | The upper tick of the position for which to burn liquidity |
| `amount`    | uint128 | How much liquidity to burn                                 |

#### Return Values:

| Name      | Type    | Description                                |
| :-------- | :------ | :----------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to the recipient |
| `amount1` | uint256 | The amount of token1 sent to the recipient |

### swap

```solidity
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes data
  ) external returns (int256 amount0, int256 amount1)
```



Swap token0 for token1, or token1 for token0

The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `recipient`         | address | The address to receive the output of the swap                |
| `zeroForOne`        | bool    | The direction of the swap, true for token0 to token1, false for token1 to token0 |
| `amountSpecified`   | int256  | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) |
| `sqrtPriceLimitX96` | uint160 | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |
| `data`              | bytes   | Any data passed through to the callback                      |

#### Return Values:

| Name      | Type   | Description                                                  |
| :-------- | :----- | :----------------------------------------------------------- |
| `amount0` | int256 | The delta of the balance of token0 of the pool, exact when negative, minimum when positive |
| `amount1` | int256 | The delta of the balance of token1 of the pool, exact when negative, minimum when positive |

### flash

```solidity
  function flash(
    address recipient,
    uint256 amount0,
    uint256 amount1,
    bytes data
  ) external
```



Receive token0 and/or token1 and pay it back, plus a fee, in the callback

The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount1 and sending the donation amount(s) from the callback

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `recipient` | address | The address which will receive the token0 and token1 amounts |
| `amount0`   | uint256 | The amount of token0 to send                                 |
| `amount1`   | uint256 | The amount of token1 to send                                 |
| `data`      | bytes   | Any data to be passed through to the callback                |

### increaseObservationCardinalityNext

```solidity
  function increaseObservationCardinalityNext(
    uint16 observationCardinalityNext
  ) external
```



Increase the maximum number of price and liquidity observations that this pool will store

This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.

#### Parameters:

| Name                         | Type   | Description                                                  |
| :--------------------------- | :----- | :----------------------------------------------------------- |
| `observationCardinalityNext` | uint16 | The desired minimum number of observations for the pool to store |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolDerivedState](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolDerivedState)

# IUniswapV3PoolDerivedState

Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs.

## Functions

### observe

```solidity
  function observe(
    uint32[] secondsAgos
  ) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s)
```



Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp

To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.

#### Parameters:

| Name          | Type     | Description                                                  |
| :------------ | :------- | :----------------------------------------------------------- |
| `secondsAgos` | uint32[] | From how long ago each cumulative tick and liquidity value should be returned |

#### Return Values:

| Name                                 | Type      | Description                                                  |
| :----------------------------------- | :-------- | :----------------------------------------------------------- |
| `tickCumulatives`                    | int56[]   | Cumulative tick values as of each `secondsAgos` from the current block timestamp |
| `secondsPerLiquidityCumulativeX128s` | uint160[] | Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block |

timestamp

### snapshotCumulativesInside

```solidity
  function snapshotCumulativesInside(
    int24 tickLower,
    int24 tickUpper
  ) external returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
```



Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range

Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.

#### Parameters:

| Name        | Type  | Description                 |
| :---------- | :---- | :-------------------------- |
| `tickLower` | int24 | The lower tick of the range |
| `tickUpper` | int24 | The upper tick of the range |

#### Return Values:

| Name                            | Type    | Description                                         |
| :------------------------------ | :------ | :-------------------------------------------------- |
| `tickCumulativeInside`          | int56   | The snapshot of the tick accumulator for the range  |
| `secondsPerLiquidityInsideX128` | uint160 | The snapshot of seconds per liquidity for the range |
| `secondsInside`                 | uint32  | The snapshot of seconds per liquidity for the range |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolEvents](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolEvents)

# IUniswapV3PoolEvents

Contains all events emitted by the pool

## Events

### Initialize

```solidity
  event Initialize(
    uint160 sqrtPriceX96,
    int24 tick
  )
```



Emitted exactly once by a pool when #initialize is first called on the pool

Mint/Burn/Swap cannot be emitted by the pool before Initialize

#### Parameters:

| Name           | Type    | Description                                                  |
| :------------- | :------ | :----------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | The initial sqrt price of the pool, as a Q64.96              |
| `tick`         | int24   | The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool |

### Mint

```solidity
  event Mint(
    address sender,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    uint256 amount0,
    uint256 amount1
  )
```



Emitted when liquidity is minted for a given position

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `sender`    | address | The address that minted the liquidity                        |
| `owner`     | address | The owner of the position and recipient of any minted liquidity |
| `tickLower` | int24   | The lower tick of the position                               |
| `tickUpper` | int24   | The upper tick of the position                               |
| `amount`    | uint128 | The amount of liquidity minted to the position range         |
| `amount0`   | uint256 | How much token0 was required for the minted liquidity        |
| `amount1`   | uint256 | How much token1 was required for the minted liquidity        |

### Collect

```solidity
  event Collect(
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0,
    uint128 amount1
  )
```



Emitted when fees are collected by the owner of a position

Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees

#### Parameters:

| Name        | Type    | Description                                            |
| :---------- | :------ | :----------------------------------------------------- |
| `owner`     | address | The owner of the position for which fees are collected |
| `tickLower` | int24   | The lower tick of the position                         |
| `tickUpper` | int24   | The upper tick of the position                         |
| `amount0`   | uint128 | The amount of token0 fees collected                    |
| `amount1`   | uint128 | The amount of token1 fees collected                    |

### Burn

```solidity
  event Burn(
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    uint256 amount0,
    uint256 amount1
  )
```



Emitted when a position's liquidity is removed

Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `owner`     | address | The owner of the position for which liquidity is removed |
| `tickLower` | int24   | The lower tick of the position                           |
| `tickUpper` | int24   | The upper tick of the position                           |
| `amount`    | uint128 | The amount of liquidity to remove                        |
| `amount0`   | uint256 | The amount of token0 withdrawn                           |
| `amount1`   | uint256 | The amount of token1 withdrawn                           |

### Swap

```solidity
  event Swap(
    address sender,
    address recipient,
    int256 amount0,
    int256 amount1,
    uint160 sqrtPriceX96,
    uint128 liquidity,
    int24 tick
  )
```



Emitted by the pool for any swaps between token0 and token1

#### Parameters:

| Name           | Type    | Description                                                  |
| :------------- | :------ | :----------------------------------------------------------- |
| `sender`       | address | The address that initiated the swap call, and that received the callback |
| `recipient`    | address | The address that received the output of the swap             |
| `amount0`      | int256  | The delta of the token0 balance of the pool                  |
| `amount1`      | int256  | The delta of the token1 balance of the pool                  |
| `sqrtPriceX96` | uint160 | The sqrt(price) of the pool after the swap, as a Q64.96      |
| `liquidity`    | uint128 | The liquidity of the pool after the swap                     |
| `tick`         | int24   | The log base 1.0001 of price of the pool after the swap      |

### Flash

```solidity
  event Flash(
    address sender,
    address recipient,
    uint256 amount0,
    uint256 amount1,
    uint256 paid0,
    uint256 paid1
  )
```



Emitted by the pool for any flashes of token0/token1

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `sender`    | address | The address that initiated the swap call, and that received the callback |
| `recipient` | address | The address that received the tokens from flash              |
| `amount0`   | uint256 | The amount of token0 that was flashed                        |
| `amount1`   | uint256 | The amount of token1 that was flashed                        |
| `paid0`     | uint256 | The amount of token0 paid for the flash, which can exceed the amount0 plus the fee |
| `paid1`     | uint256 | The amount of token1 paid for the flash, which can exceed the amount1 plus the fee |

### IncreaseObservationCardinalityNext

```solidity
  event IncreaseObservationCardinalityNext(
    uint16 observationCardinalityNextOld,
    uint16 observationCardinalityNextNew
  )
```



Emitted by the pool for increases to the number of observations that can be stored

observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn.

#### Parameters:

| Name                            | Type   | Description                                            |
| :------------------------------ | :----- | :----------------------------------------------------- |
| `observationCardinalityNextOld` | uint16 | The previous value of the next observation cardinality |
| `observationCardinalityNextNew` | uint16 | The updated value of the next observation cardinality  |

### SetFeeProtocol

```solidity
  event SetFeeProtocol(
    uint8 feeProtocol0Old,
    uint8 feeProtocol1Old,
    uint8 feeProtocol0New,
    uint8 feeProtocol1New
  )
```



Emitted when the protocol fee is changed by the pool

#### Parameters:

| Name              | Type  | Description                                   |
| :---------------- | :---- | :-------------------------------------------- |
| `feeProtocol0Old` | uint8 | The previous value of the token0 protocol fee |
| `feeProtocol1Old` | uint8 | The previous value of the token1 protocol fee |
| `feeProtocol0New` | uint8 | The updated value of the token0 protocol fee  |
| `feeProtocol1New` | uint8 | The updated value of the token1 protocol fee  |

### CollectProtocol

```solidity
  event CollectProtocol(
    address sender,
    address recipient,
    uint128 amount0,
    uint128 amount1
  )
```



Emitted when the collected protocol fees are withdrawn by the factory owner

#### Parameters:

| Name        | Type    | Description                                           |
| :---------- | :------ | :---------------------------------------------------- |
| `sender`    | address | The address that collects the protocol fees           |
| `recipient` | address | The address that receives the collected protocol fees |
| `amount0`   | uint128 | The amount of token0 protocol fees that is withdrawn  |
| `amount1`   | uint128 | The amount of token1 protocol fees that is withdrawn  |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolImmutables](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolImmutables)

# IUniswapV3PoolImmutables

These parameters are fixed for a pool forever, i.e., the methods will always return the same values

## Functions

### factory

```solidity
  function factory(
  ) external view returns (address)
```



The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface

#### Return Values:

| Type    | Description      |
| :------ | :--------------- |
| address | contract address |

### token0

```solidity
  function token0(
  ) external view returns (address)
```



The first of the two tokens of the pool, sorted by address

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| address | token contract address |

### token1

```solidity
  function token1(
  ) external view returns (address)
```



The second of the two tokens of the pool, sorted by address

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| address | token contract address |

### fee

```solidity
  function fee(
  ) external view returns (uint24)
```



The pool's fee in hundredths of a bip, i.e. 1e-6

#### Return Values:

| Type   | Description |
| :----- | :---------- |
| uint24 | fee         |

### tickSpacing

```solidity
  function tickSpacing(
  ) external view returns (int24)
```



The pool tick spacing

Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.

#### Return Values:

| Type  | Description  |
| :---- | :----------- |
| int24 | tick spacing |

### maxLiquidityPerTick

```solidity
  function maxLiquidityPerTick(
  ) external view returns (uint128)
```



The maximum amount of position liquidity that can use any tick in the range

This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool

#### Return Values:

| Type    | Description                      |
| :------ | :------------------------------- |
| uint128 | max amount of liquidity per tick |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolOwnerActions](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolOwnerActions)

# IUniswapV3PoolOwnerActions

Contains pool methods that may only be called by the factory owner

## Functions

### setFeeProtocol

```solidity
  function setFeeProtocol(
    uint8 feeProtocol0,
    uint8 feeProtocol1
  ) external
```



Set the denominator of the protocol's % share of the fees

#### Parameters:

| Name           | Type  | Description                             |
| :------------- | :---- | :-------------------------------------- |
| `feeProtocol0` | uint8 | new protocol fee for token0 of the pool |
| `feeProtocol1` | uint8 | new protocol fee for token1 of the pool |

### collectProtocol

```solidity
  function collectProtocol(
    address recipient,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external returns (uint128 amount0, uint128 amount1)
```



Collect the protocol fee accrued to the pool

#### Parameters:

| Name               | Type    | Description                                                  |
| :----------------- | :------ | :----------------------------------------------------------- |
| `recipient`        | address | The address to which collected protocol fees should be sent  |
| `amount0Requested` | uint128 | The maximum amount of token0 to send, can be 0 to collect fees in only token1 |
| `amount1Requested` | uint128 | The maximum amount of token1 to send, can be 0 to collect fees in only token0 |

#### Return Values:

| Name      | Type    | Description                          |
| :-------- | :------ | :----------------------------------- |
| `amount0` | uint128 | The protocol fee collected in token0 |
| `amount1` | uint128 | The protocol fee collected in token1 |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreInterfacesPool[IUniswapV3PoolState](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState)

# IUniswapV3PoolState

These methods compose the pool's state, and can change with any frequency including multiple times per transaction

## Functions

### slot0

```solidity
  function slot0(
  ) external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)
```



The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.

#### Return Values:

| Name                         | Type    | Description                                                  |
| :--------------------------- | :------ | :----------------------------------------------------------- |
| `sqrtPriceX96`               | uint160 | The current price of the pool as a sqrt(token1/token0) Q64.96 value |
| `tick`                       | int24   | The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. |
| `observationIndex`           | uint16  | The index of the last oracle observation that was written,   |
| `observationCardinality`     | uint16  | The current maximum number of observations stored in the pool, |
| `observationCardinalityNext` | uint16  | The next maximum number of observations, to be updated when the observation. |
| `feeProtocol`                | uint8   | The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0is the lower 4 bits.Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. |
| `unlocked`                   | bool    | Whether the pool is currently locked to reentrancy           |

### feeGrowthGlobal0X128

```solidity
  function feeGrowthGlobal0X128(
  ) external view returns (uint256)
```



The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool

This value can overflow the uint256

### feeGrowthGlobal1X128

```solidity
  function feeGrowthGlobal1X128(
  ) external view returns (uint256)
```



The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool

This value can overflow the uint256

### protocolFees

```solidity
  function protocolFees(
  ) external view returns (uint128 token0, uint128 token1)
```



The amounts of token0 and token1 that are owed to the protocol

Protocol fees will never exceed uint128 max in either token

### liquidity

```solidity
  function liquidity(
  ) external view returns (uint128)
```



The currently in range liquidity available to the pool

This value has no relationship to the total liquidity across all ticks

### ticks

```solidity
  function ticks(
    int24 tick
  ) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized)
```



Look up information about a specific tick in the pool

#### Parameters:

| Name   | Type  | Description         |
| :----- | :---- | :------------------ |
| `tick` | int24 | The tick to look up |

#### Return Values:

| Name                             | Type    | Description                                                  |
| :------------------------------- | :------ | :----------------------------------------------------------- |
| `liquidityGross`                 | uint128 | the total amount of position liquidity that uses the pool either as tick lower or tick upper, |
| `liquidityNet`                   | int128  | how much liquidity changes when the pool price crosses the tick, |
| `feeGrowthOutside0X128`          | uint256 | the fee growth on the other side of the tick from the current tick in token0, |
| `feeGrowthOutside1X128`          | uint256 | the fee growth on the other side of the tick from the current tick in token1, feeGrowthOutsideX128 values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and are used to compute snapshots. |
| `tickCumulativeOutside`          | int56   |                                                              |
| `secondsPerLiquidityOutsideX128` | uint160 |                                                              |
| `secondsOutside`                 | uint32  |                                                              |
| `initialized`                    | bool    |                                                              |

a specific position.

### tickBitmap

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```



Returns 256 packed tick initialized boolean values. See TickBitmap for more information

### positions

```solidity
  function positions(
    bytes32 key
  ) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```



Returns the information about a position by the position's key

#### Parameters:

| Name  | Type    | Description                                                  |
| :---- | :------ | :----------------------------------------------------------- |
| `key` | bytes32 | The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper |

#### Return Values:

| Name                       | Type    | Description                                                  |
| :------------------------- | :------ | :----------------------------------------------------------- |
| `_liquidity`               | bytes32 | The amount of liquidity in the position,                     |
| `feeGrowthInside0LastX128` | uint256 | fee growth of token0 inside the tick range as of the last mint/burn/poke, |
| `feeGrowthInside1LastX128` | uint256 | fee growth of token1 inside the tick range as of the last mint/burn/poke, |
| `tokensOwed0`              | uint128 | the computed amount of token0 owed to the position as of the last mint/burn/poke, |
| `tokensOwed1`              | uint128 | the computed amount of token1 owed to the position as of the last mint/burn/poke |

### observations

```solidity
  function observations(
    uint256 index
  ) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized)
```



Returns data about a specific observation index

You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.

#### Parameters:

| Name    | Type    | Description                                    |
| :------ | :------ | :--------------------------------------------- |
| `index` | uint256 | The element of the observations array to fetch |

#### Return Values:

| Name                                | Type    | Description                                                  |
| :---------------------------------- | :------ | :----------------------------------------------------------- |
| `blockTimestamp`                    | uint256 | The timestamp of the observation,                            |
| `tickCumulative`                    | int56   | the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, |
| `secondsPerLiquidityCumulativeX128` | uint160 | the seconds per in range liquidity for the life of the pool as of the observation timestamp |
| `initialized`                       | bool    | whether the observation has been initialized and the values are safe to use |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[BitMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/BitMath)

# BitMath

This library provides functionality for computing bit properties of an unsigned integer

## Functions

### mostSignificantBit

```solidity
  function mostSignificantBit(
    uint256 x
  ) internal pure returns (uint8 r)
```



Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255

The function satisfies the property: x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)

#### Parameters:

| Name | Type    | Description                                                  |
| :--- | :------ | :----------------------------------------------------------- |
| `x`  | uint256 | the value for which to compute the most significant bit, must be greater than 0 |

#### Return Values:

| Name | Type  | Description                           |
| :--- | :---- | :------------------------------------ |
| `r`  | unit8 | the index of the most significant bit |

### leastSignificantBit

```solidity
  function leastSignificantBit(
    uint256 x
  ) internal pure returns (uint8 r)
```



Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255

The function satisfies the property: (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)

#### Parameters:

| Name | Type    | Description                                                  |
| :--- | :------ | :----------------------------------------------------------- |
| `x`  | uint256 | the value for which to compute the least significant bit, must be greater than 0 |

#### Return Values:

| Name | Type  | Description                            |
| :--- | :---- | :------------------------------------- |
| `r`  | unit8 | the index of the least significant bit |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[FixedPoint128](https://docs.uniswap.org/contracts/v3/reference/core/libraries/FixedPoint128)

# FixedPoint128

A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[FixedPoint96](https://docs.uniswap.org/contracts/v3/reference/core/libraries/FixedPoint96)

# FixedPoint96

A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)

Used in SqrtPriceMath.sol

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[FullMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/FullMath)

# FullMath

Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision

Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits

## Functions

### mulDiv

```solidity
  function mulDiv(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result)
```



Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv

#### Parameters:

| Name          | Type    | Description      |
| :------------ | :------ | :--------------- |
| `a`           | uint256 | The multiplicand |
| `b`           | uint256 | The multiplier   |
| `denominator` | uint256 | The divisor      |

#### Return Values:

| Name     | Type    | Description        |
| :------- | :------ | :----------------- |
| `result` | uint256 | The 256-bit result |

### mulDivRoundingUp

```solidity
  function mulDivRoundingUp(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result)
```



Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

#### Parameters:

| Name          | Type    | Description      |
| :------------ | :------ | :--------------- |
| `a`           | uint256 | The multiplicand |
| `b`           | uint256 | The multiplier   |
| `denominator` | uint256 | The divisor      |

#### Return Values:

| Name     | Type    | Description        |
| :------- | :------ | :----------------- |
| `result` | uint256 | The 256-bit result |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[LiquidityMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/LiquidityMath)

# LiquidityMath

## Functions

### addDelta

```solidity
  function addDelta(
    uint128 x,
    int128 y
  ) internal pure returns (uint128 z)
```



Add a signed liquidity delta to liquidity and revert if it overflows or underflows

#### Parameters:

| Name | Type    | Description                                    |
| :--- | :------ | :--------------------------------------------- |
| `x`  | uint128 | The liquidity before change                    |
| `y`  | int128  | The delta by which liquidity should be changed |

#### Return Values:

| Name | Type    | Description         |
| :--- | :------ | :------------------ |
| `z`  | uint128 | The liquidity delta |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[LowGasSafeMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/LowGasSafeMath)

# LowGasSafeMath

Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost

## Functions

### add

```solidity
  function add(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```



Returns x + y, reverts if sum overflows uint256

#### Parameters:

| Name | Type    | Description |
| :--- | :------ | :---------- |
| `x`  | uint256 | The augend  |
| `y`  | uint256 | The addend  |

#### Return Values:

| Name | Type    | Description        |
| :--- | :------ | :----------------- |
| `z`  | uint256 | The sum of x and y |

### sub

```solidity
  function sub(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```



Returns x - y, reverts if underflows

#### Parameters:

| Name | Type    | Description    |
| :--- | :------ | :------------- |
| `x`  | uint256 | The minuend    |
| `y`  | uint256 | The subtrahend |

#### Return Values:

| Name | Type    | Description               |
| :--- | :------ | :------------------------ |
| `z`  | uint256 | The difference of x and y |

### mul

```solidity
  function mul(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```



Returns x * y, reverts if overflows

#### Parameters:

| Name | Type    | Description      |
| :--- | :------ | :--------------- |
| `x`  | uint256 | The multiplicand |
| `y`  | uint256 | The multiplier   |

#### Return Values:

| Name | Type    | Description            |
| :--- | :------ | :--------------------- |
| `z`  | uint256 | The product of x and y |

### add

```solidity
  function add(
    int256 x,
    int256 y
  ) internal pure returns (int256 z)
```



Returns x + y, reverts if overflows or underflows

#### Parameters:

| Name | Type   | Description |
| :--- | :----- | :---------- |
| `x`  | int256 | The augend  |
| `y`  | int256 | The addend  |

#### Return Values:

| Name | Type   | Description        |
| :--- | :----- | :----------------- |
| `z`  | int256 | The sum of x and y |

### sub

```solidity
  function sub(
    int256 x,
    int256 y
  ) internal pure returns (int256 z)
```



Returns x - y, reverts if overflows or underflows

#### Parameters:

| Name | Type   | Description    |
| :--- | :----- | :------------- |
| `x`  | int256 | The minuend    |
| `y`  | int256 | The subtrahend |

#### Return Values:

| Name | Type   | Description               |
| :--- | :----- | :------------------------ |
| `z`  | int256 | The difference of x and y |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[Oracle](https://docs.uniswap.org/contracts/v3/reference/core/libraries/Oracle)

# Oracle

Provides price and liquidity data useful for a wide variety of system designs

Instances of stored oracle data, "observations", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()

## Functions

### initialize

```solidity
  function initialize(
    struct Oracle.Observation[65535] self,
    uint32 time
  ) internal returns (uint16 cardinality, uint16 cardinalityNext)
```



Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array

#### Parameters:

| Name   | Type                             | Description                                                  |
| :----- | :------------------------------- | :----------------------------------------------------------- |
| `self` | struct Oracle.Observation[65535] | The stored oracle array                                      |
| `time` | uint32                           | The time of the oracle initialization, via block.timestamp truncated to uint32 |

#### Return Values:

| Name              | Type   | Description                                                  |
| :---------------- | :----- | :----------------------------------------------------------- |
| `cardinality`     | uint16 | The number of populated elements in the oracle array         |
| `cardinalityNext` | uint16 | The new length of the oracle array, independent of population |

### write

```solidity
  function write(
    struct Oracle.Observation[65535] self,
    uint16 index,
    uint32 blockTimestamp,
    int24 tick,
    uint128 liquidity,
    uint16 cardinality,
    uint16 cardinalityNext
  ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated)
```



Writes an oracle observation to the array

Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally. If the index is at the end of the allowable array length (according to cardinality), and the next cardinality is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.

#### Parameters:

| Name              | Type                             | Description                                                  |
| :---------------- | :------------------------------- | :----------------------------------------------------------- |
| `self`            | struct Oracle.Observation[65535] | The stored oracle array                                      |
| `index`           | uint16                           | The location of the most recently updated observation        |
| `blockTimestamp`  | uint32                           | The timestamp of the new observation                         |
| `tick`            | int24                            | The active tick at the time of the new observation           |
| `liquidity`       | uint128                          | The total in-range liquidity at the time of the new observation |
| `cardinality`     | uint16                           | The number of populated elements in the oracle array         |
| `cardinalityNext` | uint16                           | The new length of the oracle array, independent of population |

#### Return Values:

| Name                 | Type   | Description                                                  |
| :------------------- | :----- | :----------------------------------------------------------- |
| `indexUpdated`       | uint16 | The new index of the most recently written element in the oracle array |
| `cardinalityUpdated` | uint16 | The new cardinality of the oracle array                      |

### grow

```solidity
  function grow(
    struct Oracle.Observation[65535] self,
    uint16 current,
    uint16 next
  ) internal returns (uint16)
```



Prepares the oracle array to store up to `next` observations

#### Parameters:

| Name      | Type                             | Description                                                  |
| :-------- | :------------------------------- | :----------------------------------------------------------- |
| `self`    | struct Oracle.Observation[65535] | The stored oracle array                                      |
| `current` | uint16                           | The current next cardinality of the oracle array             |
| `next`    | uint16                           | The proposed next cardinality which will be populated in the oracle array |

#### Return Values:

| Name   | Type   | Description                                                  |
| :----- | :----- | :----------------------------------------------------------- |
| `next` | uint16 | The next cardinality which will be populated in the oracle array |

### observe

```solidity
  function observe(
    struct Oracle.Observation[65535] self,
    uint32 time,
    uint32[] secondsAgos,
    int24 tick,
    uint16 index,
    uint128 liquidity,
    uint16 cardinality
  ) internal view returns (int56[] tickCumulatives, uint160[] liquidityCumulatives)
```



Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`

Reverts if `secondsAgos` > oldest observation

#### Parameters:

| Name          | Type                             | Description                                                  |
| :------------ | :------------------------------- | :----------------------------------------------------------- |
| `self`        | struct Oracle.Observation[65535] | The stored oracle array                                      |
| `time`        | uint32                           | The current block.timestamp                                  |
| `secondsAgos` | uint32[]                         | Each amount of time to look back, in seconds, at which point to return an observation |
| `tick`        | int24                            | The current tick                                             |
| `index`       | uint16                           | The location of a given observation within the oracle array  |
| `liquidity`   | uint128                          | The current in-range pool liquidity                          |
| `cardinality` | uint16                           | The number of populated elements in the oracle array         |

#### Return Values:

| Name                   | Type      | Description                                                  |
| :--------------------- | :-------- | :----------------------------------------------------------- |
| `tickCumulatives`      | int56[]   | The tick * time elapsed since the pool was first initialized, as of each `secondsAgo` |
| `liquidityCumulatives` | uint160[] | The liquidity * time elapsed since the pool was first initialized, as of each `secondsAgo` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[Position](https://docs.uniswap.org/contracts/v3/reference/core/libraries/Position)

# Position

Positions represent an owner address' liquidity between a lower and upper tick boundary

Positions store additional state for tracking fees owed to the position

## Functions

### get

```solidity
  function get(
    mapping(bytes32 => struct Position.Info) self,
    address owner,
    int24 tickLower,
    int24 tickUpper
  ) internal view returns (struct Position.Info position)
```



Returns the Info struct of a position, given an owner and position boundaries

#### Parameters:

| Name        | Type                                     | Description                               |
| :---------- | :--------------------------------------- | :---------------------------------------- |
| `self`      | mapping(bytes32 => struct Position.Info) | The mapping containing all user positions |
| `owner`     | address                                  | The address of the position owner         |
| `tickLower` | int24                                    | The lower tick boundary of the position   |
| `tickUpper` | int24                                    | The upper tick boundary of the position   |

#### Return Values:

| Name       | Type                 | Description                                            |
| :--------- | :------------------- | :----------------------------------------------------- |
| `position` | struct Position.Info | The position info struct of the given owners' position |

### update

```solidity
  function update(
    struct Position.Info self,
    int128 liquidityDelta,
    uint256 feeGrowthInside0X128,
    uint256 feeGrowthInside1X128
  ) internal
```



Credits accumulated fees to a user's position

#### Parameters:

| Name                   | Type                 | Description                                                  |
| :--------------------- | :------------------- | :----------------------------------------------------------- |
| `self`                 | struct Position.Info | The mapping containing all user positions                    |
| `liquidityDelta`       | int128               | The change in pool liquidity as a result of the position update |
| `feeGrowthInside0X128` | uint256              | The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | uint256              | The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[SafeCast](https://docs.uniswap.org/contracts/v3/reference/core/libraries/SafeCast)

# SafeCast

Contains methods for safely casting between types

## Functions

### toUint160

```solidity
  function toUint160(
    uint256 y
  ) internal pure returns (uint160 z)
```



Cast a uint256 to a uint160, revert on overflow

#### Parameters:

| Name | Type    | Description                  |
| :--- | :------ | :--------------------------- |
| `y`  | uint256 | The uint256 to be downcasted |

#### Return Values:

| Name | Type    | Description                              |
| :--- | :------ | :--------------------------------------- |
| `z`  | uint160 | The downcasted integer, now type uint160 |

### toInt128

```solidity
  function toInt128(
    int256 y
  ) internal pure returns (int128 z)
```



Cast a int256 to a int128, revert on overflow or underflow

#### Parameters:

| Name | Type   | Description                 |
| :--- | :----- | :-------------------------- |
| `y`  | int256 | The int256 to be downcasted |

#### Return Values:

| Name | Type   | Description                             |
| :--- | :----- | :-------------------------------------- |
| `z`  | int128 | The downcasted integer, now type int128 |

### toInt256

```solidity
  function toInt256(
    uint256 y
  ) internal pure returns (int256 z)
```



Cast a uint256 to a int256, revert on overflow

#### Parameters:

| Name | Type    | Description              |
| :--- | :------ | :----------------------- |
| `y`  | uint256 | The uint256 to be casted |

#### Return Values:

| Name | Type   | Description                         |
| :--- | :----- | :---------------------------------- |
| `z`  | int256 | The casted integer, now type int256 |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[SecondsOutside](https://docs.uniswap.org/contracts/v3/reference/core/libraries/SecondsOutside)

# SecondsOutside

Contains methods for working with a mapping from tick to 32 bit timestamp values, specifically seconds spent outside the tick.

The mapping uses int24 for keys since ticks are represented as int24 and there are 8 (2^3) values per word. Note "seconds outside" is always a relative measurement, only consistent for as long as a the lower tick and upper tick have gross liquidity greater than 0.

## Functions

### initialize

```solidity
  function initialize(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickCurrent,
    int24 tickSpacing,
    uint32 time
  ) internal
```



Called the first time a tick is used to set the seconds outside value. Assumes the tick is not initialized.

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to be initialized                    |
| `tickCurrent` | int24                     | the current tick                              |
| `tickSpacing` | int24                     | the spacing between usable ticks              |
| `time`        | uint32                    | the current timestamp                         |

### clear

```solidity
  function clear(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal
```



Called when a tick is no longer used, to clear the seconds outside value of the tick

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to be cleared                        |
| `tickSpacing` | int24                     | the spacing between usable ticks              |

### cross

```solidity
  function cross(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing,
    uint32 time
  ) internal
```



Called when an initialized tick is crossed to update the seconds outside for that tick. Must be called every time an initialized tick is crossed

#### Parameters:

| Name          | Type                      | Description                                      |
| :------------ | :------------------------ | :----------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside    |
| `tick`        | int24                     | the tick to be crossed                           |
| `tickSpacing` | int24                     | the spacing between usable ticks                 |
| `time`        | uint32                    | the current block timestamp truncated to 32 bits |

### get

```solidity
  function get(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal view returns (uint32)
```



Get the seconds outside for an initialized tick. Should be called only on initialized ticks.

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to get the seconds outside value for |
| `tickSpacing` | int24                     | the spacing between usable ticks              |

#### Return Values:

| Type   | Description                         |
| :----- | :---------------------------------- |
| uint32 | seconds outside value for that tick |

### secondsInside

```solidity
  function secondsInside(
    mapping(int24 => uint256) self,
    int24 tickLower,
    int24 tickUpper,
    int24 tickCurrent,
    int24 tickSpacing
  ) internal view returns (uint32)
```



Get the seconds inside a tick range, assuming both tickLower and tickUpper are initialized

#### Parameters:

| Name          | Type                      | Description                                    |
| :------------ | :------------------------ | :--------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside  |
| `tickLower`   | int24                     | the lower tick for which to get seconds inside |
| `tickUpper`   | int24                     | the upper tick for which to get seconds inside |
| `tickCurrent` | int24                     | the current tick                               |
| `tickSpacing` | int24                     | the spacing between usable ticks               |

#### Return Values:

| Name | Type   | Description                                                  |
| :--- | :----- | :----------------------------------------------------------- |
| `a`  | uint32 | relative seconds inside value that can be snapshotted and compared to a later snapshot to compute |

time spent between tickLower and tickUpper, i.e. time that a position's liquidity was in use.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[SqrtPriceMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/SqrtPriceMath)

# SqrtPriceMath

Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas

## Functions

### getNextSqrtPriceFromAmount0RoundingUp

```solidity
  function getNextSqrtPriceFromAmount0RoundingUp(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
  ) internal pure returns (uint160)
```



Gets the next sqrt price given a delta of token0

Always rounds up, because in the exact output case (increasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the price less in order to not send too much output. The most precise formula for this is *liquidity \* sqrtPX96 / (liquidity +- amount \* sqrtPX96)*, if this is impossible because of overflow, we calculate *liquidity / (liquidity / sqrtPX96 +- amount)*.

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `sqrtPX96`  | uint160 | The starting price, i.e. before accounting for the token0 delta |
| `liquidity` | uint128 | The amount of usable liquidity                               |
| `amount`    | uint256 | How much of token0 to add or remove from virtual reserves    |
| `add`       | bool    | Whether to add or remove the amount of token0                |

#### Return Values:

| Type    | Description                                             |
| :------ | :------------------------------------------------------ |
| uint160 | price after adding or removing amount, depending on add |

### getNextSqrtPriceFromAmount1RoundingDown

```solidity
  function getNextSqrtPriceFromAmount1RoundingDown(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
  ) internal pure returns (uint160)
```



Gets the next sqrt price given a delta of token1

Always rounds down, because in the exact output case (decreasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the price less in order to not send too much output. The formula we compute is within <1 wei of the lossless version: *sqrtPX96 +- amount / liquidity*

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `sqrtPX96`  | uint160 | The starting price, i.e., before accounting for the token1 delta |
| `liquidity` | uint128 | The amount of usable liquidity                               |
| `amount`    | uint256 | How much of token1 to add, or remove, from virtual reserves  |
| `add`       | bool    | Whether to add, or remove, the amount of token1              |

#### Return Values:

| Type    | Description                             |
| :------ | :-------------------------------------- |
| uint160 | price after adding or removing `amount` |

### getNextSqrtPriceFromInput

```solidity
  function getNextSqrtPriceFromInput(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amountIn,
    bool zeroForOne
  ) internal pure returns (uint160 sqrtQX96)
```



Gets the next sqrt price given an input amount of token0 or token1

Throws if price or liquidity are 0, or if the next price is out of bounds

#### Parameters:

| Name         | Type    | Description                                                  |
| :----------- | :------ | :----------------------------------------------------------- |
| `sqrtPX96`   | uint160 | The starting price, i.e., before accounting for the input amount |
| `liquidity`  | uint128 | The amount of usable liquidity                               |
| `amountIn`   | uint256 | How much of token0, or token1, is being swapped in           |
| `zeroForOne` | bool    | Whether the amount in is token0 or token1                    |

#### Return Values:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `sqrtQX96` | uint160 | The price after adding the input amount to token0 or token1 |

### getNextSqrtPriceFromOutput

```solidity
  function getNextSqrtPriceFromOutput(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amountOut,
    bool zeroForOne
  ) internal pure returns (uint160 sqrtQX96)
```



Gets the next sqrt price given an output amount of token0 or token1

Throws if price or liquidity are 0 or the next price is out of bounds

#### Parameters:

| Name         | Type    | Description                                                |
| :----------- | :------ | :--------------------------------------------------------- |
| `sqrtPX96`   | uint160 | The starting price before accounting for the output amount |
| `liquidity`  | uint128 | The amount of usable liquidity                             |
| `amountOut`  | uint256 | How much of token0, or token1, is being swapped out        |
| `zeroForOne` | bool    | Whether the amount out is token0 or token1                 |

#### Return Values:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `sqrtQX96` | uint160 | The price after removing the output amount of token0 or token1 |

### getAmount0Delta

```solidity
  function getAmount0Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity,
    bool roundUp
  ) internal pure returns (uint256 amount0)
```



Gets the amount0 delta between two prices

Calculates *liquidity / sqrt(lower) - liquidity / sqrt(upper)*, i.e. *liquidity \* (sqrt(upper) - sqrt(lower)) / (sqrt(upper) \* sqrt(lower))*

#### Parameters:

| Name            | Type    | Description                            |
| :-------------- | :------ | :------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                           |
| `sqrtRatioBX96` | uint160 | Another sqrt price                     |
| `liquidity`     | uint128 | The amount of usable liquidity         |
| `roundUp`       | bool    | Whether to round the amount up or down |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount0` | uint256 | Amount of token0 required to cover a position of size liquidity between the two passed prices |

### getAmount1Delta

```solidity
  function getAmount1Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity,
    bool roundUp
  ) internal pure returns (uint256 amount1)
```



Gets the amount1 delta between two prices

Calculates *liquidity \* (sqrt(upper) - sqrt(lower))*

#### Parameters:

| Name            | Type    | Description                             |
| :-------------- | :------ | :-------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                            |
| `sqrtRatioBX96` | uint160 | Another sqrt price                      |
| `liquidity`     | uint128 | The amount of usable liquidity          |
| `roundUp`       | bool    | Whether to round the amount up, or down |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount1` | uint256 | Amount of token1 required to cover a position of size liquidity between the two passed prices |

### getAmount0Delta

```solidity
  function getAmount0Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    int128 liquidity
  ) internal pure returns (int256 amount0)
```



Helper that gets signed token0 delta

#### Parameters:

| Name            | Type    | Description                                                  |
| :-------------- | :------ | :----------------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                                                 |
| `sqrtRatioBX96` | uint160 | Another sqrt price                                           |
| `liquidity`     | int128  | The change in liquidity for which to compute the amount0 delta |

#### Return Values:

| Name      | Type   | Description                                                  |
| :-------- | :----- | :----------------------------------------------------------- |
| `amount0` | int256 | Amount of token0 corresponding to the passed liquidityDelta between the two prices |

### getAmount1Delta

```solidity
  function getAmount1Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    int128 liquidity
  ) internal pure returns (int256 amount1)
```



Helper that gets signed token1 delta

#### Parameters:

| Name            | Type    | Description                                                  |
| :-------------- | :------ | :----------------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                                                 |
| `sqrtRatioBX96` | uint160 | Another sqrt price                                           |
| `liquidity`     | int128  | The change in liquidity for which to compute the amount1 delta |

#### Return Values:

| Name      | Type   | Description                                                  |
| :-------- | :----- | :----------------------------------------------------------- |
| `amount1` | int256 | Amount of token1 corresponding to the passed liquidityDelta between the two prices |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[SwapMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/SwapMath)

# SwapMath

Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.

## Functions

### computeSwapStep

```solidity
  function computeSwapStep(
    uint160 sqrtRatioCurrentX96,
    uint160 sqrtRatioTargetX96,
    uint128 liquidity,
    int256 amountRemaining,
    uint24 feePips
  ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount)
```



Computes the result of swapping some amount in, or amount out, given the parameters of the swap

The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive

#### Parameters:

| Name                  | Type    | Description                                                  |
| :-------------------- | :------ | :----------------------------------------------------------- |
| `sqrtRatioCurrentX96` | uint160 | The current sqrt price of the pool                           |
| `sqrtRatioTargetX96`  | uint160 | The price that cannot be exceeded, from which the direction of the swap is inferred |
| `liquidity`           | uint128 | The usable liquidity                                         |
| `amountRemaining`     | int256  | How much input or output amount is remaining to be swapped in/out |
| `feePips`             | uint24  | The fee taken from the input amount, expressed in hundredths of a bip |

#### Return Values:

| Name               | Type    | Description                                                  |
| :----------------- | :------ | :----------------------------------------------------------- |
| `sqrtRatioNextX96` | uint160 | The price after swapping the amount in/out, not to exceed the price target |
| `amountIn`         | uint256 | The amount to be swapped in, of either token0 or token1, based on the direction of the swap |
| `amountOut`        | uint256 | The amount to be received, of either token0 or token1, based on the direction of the swap |
| `feeAmount`        | uint256 | The amount of input that will be taken as a fee              |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[Tick](https://docs.uniswap.org/contracts/v3/reference/core/libraries/Tick)

# Tick

Contains functions for managing tick processes and relevant calculations

## Functions

### tickSpacingToMaxLiquidityPerTick

```solidity
  function tickSpacingToMaxLiquidityPerTick(
    int24 tickSpacing
  ) internal pure returns (uint128)
```



Derives max liquidity per tick from given tick spacing

Executed within the pool constructor

#### Parameters:

| Name          | Type  | Description                                                  |
| :------------ | :---- | :----------------------------------------------------------- |
| `tickSpacing` | int24 | The amount of required tick separation, realized in multiples of `tickSpacing` e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ... |

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| uint128 | max liquidity per tick |

### getFeeGrowthInside

```solidity
  function getFeeGrowthInside(
    mapping(int24 => struct Tick.Info) self,
    int24 tickLower,
    int24 tickUpper,
    int24 tickCurrent,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
  ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)
```



Retrieves fee growth data

#### Parameters:

| Name                   | Type                               | Description                                                  |
| :--------------------- | :--------------------------------- | :----------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks |
| `tickLower`            | int24                              | The lower tick boundary of the position                      |
| `tickUpper`            | int24                              | The upper tick boundary of the position                      |
| `tickCurrent`          | int24                              | The current tick                                             |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0 |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1 |

#### Return Values:

| Name                   | Type    | Description                                                  |
| :--------------------- | :------ | :----------------------------------------------------------- |
| `feeGrowthInside0X128` | uint256 | The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | uint256 | The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries |

### update

```solidity
  function update(
    mapping(int24 => struct Tick.Info) self,
    int24 tick,
    int24 tickCurrent,
    int128 liquidityDelta,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128,
    bool upper,
    uint128 maxLiquidity
  ) internal returns (bool flipped)
```



Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa

#### Parameters:

| Name                   | Type                               | Description                                                  |
| :--------------------- | :--------------------------------- | :----------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks |
| `tick`                 | int24                              | The tick that will be updated                                |
| `tickCurrent`          | int24                              | The current tick                                             |
| `liquidityDelta`       | int128                             | A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0 |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1 |
| `upper`                | bool                               | true for updating a position's upper tick, or false for updating a position's lower tick |
| `maxLiquidity`         | uint128                            | The maximum liquidity allocation for a single tick           |

#### Return Values:

| Name      | Type | Description                                                  |
| :-------- | :--- | :----------------------------------------------------------- |
| `flipped` | bool | Whether the tick was flipped from initialized to uninitialized, or vice versa |

### clear

```solidity
  function clear(
    mapping(int24 => struct Tick.Info) self,
    int24 tick
  ) internal
```



Clears tick data

#### Parameters:

| Name   | Type                               | Description                                                  |
| :----- | :--------------------------------- | :----------------------------------------------------------- |
| `self` | mapping(int24 => struct Tick.Info) | The mapping containing all initialized tick information for initialized ticks |
| `tick` | int24                              | The tick that will be cleared                                |

### cross

```solidity
  function cross(
    mapping(int24 => struct Tick.Info) self,
    int24 tick,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
  ) internal returns (int128 liquidityNet)
```



Transitions to next tick as needed by price movement

#### Parameters:

| Name                   | Type                               | Description                                                  |
| :--------------------- | :--------------------------------- | :----------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks |
| `tick`                 | int24                              | The destination tick of the transition                       |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0 |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1 |

#### Return Values:

| Name           | Type   | Description                                                  |
| :------------- | :----- | :----------------------------------------------------------- |
| `liquidityNet` | int128 | The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left) |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[TickBitmap](https://docs.uniswap.org/contracts/v3/reference/core/libraries/TickBitmap)

# TickBitmap

Stores a packed mapping of tick index to its initialized state

The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.

## Functions

### flipTick

```solidity
  function flipTick(
    mapping(int16 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal
```



Flips the initialized state for a given tick from false to true, or vice versa

#### Parameters:

| Name          | Type                      | Description                           |
| :------------ | :------------------------ | :------------------------------------ |
| `self`        | mapping(int16 => uint256) | The mapping in which to flip the tick |
| `tick`        | int24                     | The tick to flip                      |
| `tickSpacing` | int24                     | The spacing between usable ticks      |

### nextInitializedTickWithinOneWord

```solidity
  function nextInitializedTickWithinOneWord(
    mapping(int16 => uint256) self,
    int24 tick,
    int24 tickSpacing,
    bool lte
  ) internal view returns (int24 next, bool initialized)
```



Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick

#### Parameters:

| Name          | Type                      | Description                                                  |
| :------------ | :------------------------ | :----------------------------------------------------------- |
| `self`        | mapping(int16 => uint256) | The mapping in which to compute the next initialized tick    |
| `tick`        | int24                     | The starting tick                                            |
| `tickSpacing` | int24                     | The spacing between usable ticks                             |
| `lte`         | bool                      | Whether to search for the next initialized tick to the left (less than or equal to the starting tick) |

#### Return Values:

| Name          | Type  | Description                                                  |
| :------------ | :---- | :----------------------------------------------------------- |
| `next`        | int24 | The next initialized or uninitialized tick up to 256 ticks away from the current tick |
| `initialized` | bool  | Whether the next tick is initialized, as the function only searches within up to 256 ticks |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[TickMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/TickMath)

# TickMath

Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128

## Functions

### getSqrtRatioAtTick

```solidity
  function getSqrtRatioAtTick(
    int24 tick
  ) internal pure returns (uint160 sqrtPriceX96)
```



Calculates sqrt(1.0001^tick) * 2^96

Throws if |tick| > max tick

#### Parameters:

| Name   | Type  | Description                          |
| :----- | :---- | :----------------------------------- |
| `tick` | int24 | The input tick for the above formula |

#### Return Values:

| Name           | Type    | Description                                                  |
| :------------- | :------ | :----------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) |

at the given tick

### getTickAtSqrtRatio

```solidity
  function getTickAtSqrtRatio(
    uint160 sqrtPriceX96
  ) internal pure returns (int24 tick)
```



Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio

Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return.

#### Parameters:

| Name           | Type    | Description                                              |
| :------------- | :------ | :------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | The sqrt ratio for which to compute the tick as a Q64.96 |

#### Return Values:

| Name   | Type  | Description                                                  |
| :----- | :---- | :----------------------------------------------------------- |
| `tick` | int24 | The greatest tick for which the ratio is less than or equal to the input ratio |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[TransferHelper](https://docs.uniswap.org/contracts/v3/reference/core/libraries/TransferHelper)

# TransferHelper

Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false

## Functions

### safeTransfer

```solidity
  function safeTransfer(
    address token,
    address to,
    uint256 value
  ) internal
```



Transfers tokens from msg.sender to a recipient

Calls transfer on token contract, errors with TF if transfer fails

#### Parameters:

| Name    | Type    | Description                                                 |
| :------ | :------ | :---------------------------------------------------------- |
| `token` | address | The contract address of the token which will be transferred |
| `to`    | address | The recipient of the transfer                               |
| `value` | uint256 | The value of the transfer                                   |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceCoreLibraries[UnsafeMath](https://docs.uniswap.org/contracts/v3/reference/core/libraries/UnsafeMath)

# UnsafeMath

Contains methods that perform common math functions but do not do any overflow or underflow checks

## Functions

### divRoundingUp

```solidity
  function divRoundingUp(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```



Returns ceil(x / y)

panics if y == 0

#### Parameters:

| Name | Type    | Description  |
| :--- | :------ | :----------- |
| `x`  | uint256 | The dividend |
| `y`  | uint256 | The divisor  |

#### Return Values:

| Name | Type    | Description               |
| :--- | :------ | :------------------------ |
| `z`  | uint256 | The quotient, ceil(x / y) |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferenceGovernance[Overview](https://docs.uniswap.org/contracts/v3/reference/governance/overview)

# Overview

> The updated reference for the newly deployed Governor Bravo is available via [Etherscan](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3), some of the reference material below may be out of date.

The Uniswap protocol is governed and upgraded by UNI token holders, using three distinct components; the UNI token, governance module, and Timelock. Together, these contracts allow the community to propose, vote, and implement changes to the uniswap protocol.

Any addresses with more than 2.5M UNI (0.25% of total supply) delegated to it may propose governance actions, which contain finished, executable code. When a proposal is created, the community can cast their votes during a 7 day voting period. If there are more 'For' votes than 'Against' (i.e. a simple majority), and the number of 'For' votes >40M (meeting the quorum), it is queued in the Timelock, and may be executed in a minimum of 2 days.

## Timelock

The Timelock contract can modify system parameters, logic, and contracts in a 'time-delayed, opt-out' upgrade pattern. Timelock has a hard-coded minimum delay of 2 days, which is the least amount of notice possible for a governance action. Each proposed action will be published at a minimum of 2 days in the future from the time of announcement. Major upgrades, such as changing the risk system, may have up to a 30 day delay. Timelock is controlled by the governance module; pending and completed governance actions can be monitored on the Timelock Dashboard.

![img](https://docs.uniswap.org/assets/images/gov_diagram-1-9bc9f7797121de9e8c8210d39b1c0dc3.png)

## Key Events

### DelegateChanged

```solidity
DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
```



Emitted when an account changes its delegate.

### DelegateVotesChanged

```solidity
DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance)
```



Emitted when a delegate account's vote balance changes.

### ProposalCreated

```solidity
ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description)
```



Emitted when a new proposal is created.

### VoteCast

```solidity
VoteCast(address voter, uint proposalId, bool support, uint votes)
```



Emitted when a vote has been cast on a proposal.

### ProposalCanceled

```solidity
ProposalCanceled(uint id)
```



Emitted when a proposal has been canceled.

### ProposalQueued

```solidity
ProposalQueued(uint id, uint eta)
```



Emitted when a proposal has been queued in the Timelock.

### ProposalExecuted

```solidity
ProposalExecuted(uint id)
```



Emitted when a proposal has been executed in the Timelock.

## Read-Only Functions: UNI

### Get Current Votes

```solidity
function getCurrentVotes(address account) returns (uint96)
```



Returns the balance of votes for an account as of the current block.

| Name    | Type      |                                                              |
| :------ | :-------- | :----------------------------------------------------------- |
| account | `address` | Address of the account of which to retrieve the number of votes. |

### Get Prior Votes

```solidity
function getPriorVotes(address account, uint blockNumber) returns (uint96)
```



Returns the prior number of votes for an account at a specific block number. The block number passed must be a finalized block or the function will revert.

| Name        | Type      |                                                              |
| :---------- | :-------- | :----------------------------------------------------------- |
| account     | `address` | Address of the account of which to retrieve the prior number of votes. |
| blocknumber | `uint`    | The block number at which to retrieve the prior number of votes. |
|             |           |                                                              |
| unnamed     | `uint96`  | The number of prior votes                                    |

## State-Changing Functions: UNI

### Delegate

```solidity
function delegate(address delegatee)
```



Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                              |
| :-------- | :-------- | :----------------------------------------------------------- |
| delegatee | `address` | The address to which msg.sender wishes to delegate their votes to. |

### Delegate By Signature

```solidity
function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s)
```



Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                              |
| :-------- | :-------- | :----------------------------------------------------------- |
| delegatee | `address` | The address to which msg.sender wishes to delegate their vote to |
| nonce     | `uint`    | The contract state required to match the signature. This can be retrieved from the contract’s public nonces mapping |
| expiry    | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch. |
| v         | `uint`    | The recovery byte of the signature.                          |
| r         | `bytes32` | Half of the ECDSA signature pair.                            |
| s         | `bytes32` | Half of the ECDSA signature pair.                            |

## Read-Only Functions: Governor Alpha

### Quorum Votes

```solidity
function quorumVotes() public pure returns (uint)
```



Returns the minimum number of votes required for a proposal to succeed.

### Proposal Threshold

```solidity
function proposalThreshold() returns (uint)
```



Returns the minimum number of votes required for an account to create a proposal.

### Proposal Max Operations

```solidity
function proposalMaxOperations() returns (uint)
```



Returns the maximum number of actions that can be included in a proposal. Actions are functions calls that will be made when a proposal succeeds and executes.

### Voting Delay

```solidity
function votingDelay() returns (uint)
```



Returns the number of blocks to wait before voting on a proposal may begin. This value is added to the current block number when a proposal is created.

### Voting Period

```solidity
function votingPeriod() returns (uint)
```



Returns the duration of voting on a proposal, in blocks.

### Get Actions

```solidity
function getActions(uint proposalId) returns (uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)
```



Gets the actions of a selected proposal. Pass a proposal ID and get the targets, values, signatures and calldatas of that proposal.

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

Returns:

- Array of addresses of contracts the proposal calls.
- Array of unsigned integers the proposal uses as values.
- Array of strings of the proposal’s signatures.
- Array of calldata bytes of the proposal.

### Get Receipt

```solidity
function getReceipt(uint proposalId, address voter) returns (Receipt memory)
```



Returns a proposal ballot receipt of a given voter.

| Name       | Type      |                                                              |
| :--------- | :-------- | :----------------------------------------------------------- |
| proposalId | `uint`    | ID of the proposal in which to get a voter’s ballot receipt. |
| voter      | `address` | Address of the account of a proposal voter.                  |
|            |           |                                                              |
| Receipt    | `struct`  | A Receipt struct for the ballot of the voter address.        |

### State

```solidity
function state(uint proposalId) returns (ProposalState)
```



Returns enum of type ProposalState, possible types are:

- Pending
- Active
- Canceled
- Defeated
- Succeeded
- Queued
- Expired
- Executed

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

## State-Changing Functions: Governor Alpha

### Propose

```solidity
function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) returns (uint)
```



Creates a Proposal to change the protocol.

Proposals will be voted on by delegated voters. If there is sufficient support before the voting period ends, the proposal shall be automatically enacted. Enacted proposals are queued and executed in the Timelock contract.

The sender must hold more UNI than the current proposal threshold (proposalThreshold()) as of the immediately previous block. The proposal can have up to 10 actions (based on proposalMaxOperations()).

The proposer cannot create another proposal if they currently have a pending or active proposal. It is not possible to queue two identical actions in the same block (due to a restriction in the Timelock), therefore actions in a single proposal must be unique, and unique proposals that share an identical action must be queued in different blocks.

| Name        | Type      |                                                              |
| :---------- | :-------- | :----------------------------------------------------------- |
| targets     | `address` | The ordered list of target addresses for calls to be made during proposal execution. This array must be the same length as all other array parameters in this function. |
| values      | `uint`    | The ordered list of values (i.e. msg.value) to be passed to the calls made during proposal execution. This array must be the same length as all other array parameters in this function |
| signatures  | `string`  | The ordered list of function signatures to be passed during execution. This array must be the same length as all other array parameters in this function. |
| calldatas   | `bytes`   | The ordered list of data to be passed to each individual function call during proposal execution. This array must be the same length as all other array parameters in this function. |
| description | `string`  | A human readable description of the proposal and the changes it will enact. |
|             |           |                                                              |
| Unnamed     | `uint`    | Returns ID of the new proposal                               |

### Queue

```solidity
function queue(uint proposalId)
```



After a proposal has succeeded, any address can call the queue method to move the proposal into the Timelock queue. A proposal can only be queued if it has succeeded.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Execute

```solidity
function execute(uint proposalId) payable
```



After the Timelock delay period, any account may invoke the execute method to apply the changes from the proposal to the target contracts. This will invoke each of the actions described in the proposal. This function is payable so the Timelock contract can invoke payable functions that were selected in the proposal.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Cancel

```solidity
function cancel(uint proposalId)
```



Cancel a proposal that has not yet been executed. The Guardian is the only one who may execute this unless the proposer does not maintain the delegates required to create a proposal. If the proposer does not have more delegates than the proposal threshold, anyone can cancel the proposal.

| Name       | Type   |                            |
| :--------- | :----- | :------------------------- |
| proposalId | `uint` | ID of a proposal to cancel |

### Cast Vote

```solidity
function castVote(uint proposalId, bool support)
```



Cast a vote on a proposal. The account's voting weight is determined by it's number of delegated votes at the time the proposal becomes active.

| Name       | Type   |                                                              |
| :--------- | :----- | :----------------------------------------------------------- |
| proposalId | `uint` | ID of a given successful proposal                            |
| support    | `bool` | A boolean of true for 'yes' or false for 'no' on the proposal vote. |

### Cast Vote By Signature

```solidity
function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s)
```



Cast a vote on a proposal. The account's voting weight is determined by its number of delegated votes at the time the proposal became active. This method has the same purpose as Cast Vote, but instead enables offline signatures to participate in governance voting. For more details on how to create an offline signature, review EIP-712.

| Name       | Type      |                                                              |
| :--------- | :-------- | :----------------------------------------------------------- |
| proposalId | `uint`    | ID of a given successful proposal                            |
| support    | `bool`    | A boolean of true for 'yes' or false for 'no' on the proposal vote. |
| expiry     | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch. |
| v          | `uint`    | The recovery byte of the signature.                          |
| r          | `bytes32` | Half of the ECDSA signature pair.                            |
| s          | `bytes32` | Half of the ECDSA signature pair.                            |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[BlockTimestamp](https://docs.uniswap.org/contracts/v3/reference/periphery/base/BlockTimestamp)

# BlockTimestamp

Base contract that is overridden for tests

## Functions

### _blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal view returns (uint256)
```



Method that exists purely to be overridden for tests

#### Return Values:

| Type    | Description             |
| :------ | :---------------------- |
| uint256 | current block timestamp |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[ERC721Permit](https://docs.uniswap.org/contracts/v3/reference/periphery/base/ERC721Permit)

# ERC721Permit

Nonfungible tokens that support an approve via signature, i.e. permit

## Functions

### _getAndIncrementNonce

```solidity
  function _getAndIncrementNonce(
    uint256 tokenId
  ) internal virtual returns (uint256)
```



Gets the current nonce for a token ID and then increments it, returning the original value

### constructor

```solidity
  function constructor(
    string memory name_,
    string memory symbol_,
    string memory version_
  ) internal
```



Computes the nameHash and versionHash

### DOMAIN_SEPARATOR

```solidity
  function DOMAIN_SEPARATOR(
  ) public view override returns (bytes32)
```



The domain separator used in the permit signature

#### Return Values:

| Type    | Description                                           |
| :------ | :---------------------------------------------------- |
| bytes32 | domain seperator used in encoding of permit signature |

### permit

```solidity
  function permit(
    address spender,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Approve of a specific token ID for spending by spender via signature

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `spender`  | address | The account that is being approved                           |
| `tokenId`  | uint256 | The ID of the token that is being approved for spending      |
| `deadline` | uint256 | The deadline timestamp by which the call must be mined for the approve to work |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[LiquidityManagement](https://docs.uniswap.org/contracts/v3/reference/periphery/base/LiquidityManagement)

# LiquidityManagement

Internal functions for safely managing liquidity in Uniswap V3

## Parameter Structs

### AddLiquidityParams

```solidity
    struct AddLiquidityParams {
        address token0;
        address token1;
        uint24 fee;
        address recipient;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
    }
```



## Functions

### uniswapV3MintCallback

```solidity
  function uniswapV3MintCallback(
    uint256 amount0Owed,
    uint256 amount1Owed,
    bytes data
  ) external
```



Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.

In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `amount0Owed` | uint256 | The amount of token0 due to the pool for the minted liquidity |
| `amount1Owed` | uint256 | The amount of token1 due to the pool for the minted liquidity |
| `data`        | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#mint call |

### addLiquidity

```solidity
  function addLiquidity(
    AddLiquidityParams memory params
  ) internal returns (uint128 liquidity, uint256 amount0, uint256 amount1, contract IUniswapV3Pool pool)
```



Add liquidity to an initialized pool

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[Multicall](https://docs.uniswap.org/contracts/v3/reference/periphery/base/Multicall)

# Multicall

Enables calling multiple methods in a single call to the contract

## Functions

### multicall

```solidity
  function multicall(
    bytes[] data
  ) external payable override returns (bytes[] results)
```



Call multiple functions in the current contract and return the data from all of them if they all succeed

The `msg.value` should not be trusted for any method callable from multicall.

#### Parameters:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `data` | bytes[] | The encoded function data for each of the calls to make to this contract |

#### Return Values:

| Name      | Type    | Description                                           |
| :-------- | :------ | :---------------------------------------------------- |
| `results` | bytes[] | The results from each of the calls passed in via data |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[PeripheryImmutableState](https://docs.uniswap.org/contracts/v3/reference/periphery/base/PeripheryImmutableState)

# PeripheryImmutableState

Immutable state used by periphery contracts

## Functions

### constructor

```solidity
  function constructor(
    address _factory, address _WETH9
  ) internal
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[PeripheryPayments](https://docs.uniswap.org/contracts/v3/reference/periphery/base/PeripheryPayments)

# PeripheryPayments

## Functions

### receive

```solidity
  function receive(
  ) external
```



### unwrapWETH9

```solidity
  function unwrapWETH9(
    uint256 amountMinimum,
    address recipient
  ) external
```



Unwraps the contract's WETH9 balance and sends it to recipient as ETH.

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

#### Parameters:

| Name            | Type    | Description                           |
| :-------------- | :------ | :------------------------------------ |
| `amountMinimum` | uint256 | The minimum amount of WETH9 to unwrap |
| `recipient`     | address | The address receiving ETH             |

### sweepToken

```solidity
  function sweepToken(
    address token,
    uint256 amountMinimum,
    address recipient
  ) external
```



Transfers the full amount of a token held by this contract to recipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

#### Parameters:

| Name            | Type    | Description                                                  |
| :-------------- | :------ | :----------------------------------------------------------- |
| `token`         | address | The contract address of the token which will be transferred to `recipient` |
| `amountMinimum` | uint256 | The minimum amount of token required for a transfer          |
| `recipient`     | address | The destination address of the token                         |

### refundETH

```solidity
  function refundETH(
  ) external
```



Refunds any ETH balance held by this contract to the `msg.sender`

Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount

### pay

```solidity
  function pay(
    address token,
    address payer,
    address recipient,
    uint256 value
  ) internal
```



#### Parameters:

| Name        | Type    | Description                          |
| :---------- | :------ | :----------------------------------- |
| `token`     | address | The token to pay                     |
| `payer`     | address | The entity that must pay             |
| `recipient` | address | The entity that will receive payment |
| `value`     | uint256 | The amount to pay                    |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[PeripheryPaymentsWithFee](https://docs.uniswap.org/contracts/v3/reference/periphery/base/PeripheryPaymentsWithFee)

# PeripheryPaymentsWithFee

## Functions

### unwrapWETH9WithFee

```solidity
  function unwrapWETH9WithFee(
        uint256 amountMinimum,
        address recipient,
        uint256 feeBips,
        address feeRecipient
  ) public
```



Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

### sweepTokenWithFee

```solidity
  function sweepTokenWithFee(
        address token,
        uint256 amountMinimum,
        address recipient,
        uint256 feeBips,
        address feeRecipient
  ) public
```



Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[PoolInitializer](https://docs.uniswap.org/contracts/v3/reference/periphery/base/PoolInitializer)

# PoolInitializer

## Functions

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address token0,
    address token1,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```



Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `token0`       | address | The contract address of token0 of the pool                  |
| `token1`       | address | The contract address of token1 of the pool                  |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

#### Return Values:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryBase[SelfPermit](https://docs.uniswap.org/contracts/v3/reference/periphery/base/SelfPermit)

# SelfPermit

Functionality to call permit on any EIP-2612-compliant token for use in the route

These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function that requires an approval in a single transaction.

## Functions

### selfPermit

```solidity
  function selfPermit(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public
```



Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `token`    | address | The address of the token spent                               |
| `value`    | uint256 | The amount that can be spent of token                        |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitIfNecessary

```solidity
  function selfPermitIfNecessary(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `token`    | address | The address of the token spent                               |
| `value`    | uint256 | The amount that can be spent of token                        |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowed

```solidity
  function selfPermitAllowed(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public
```



Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `token`  | address | The address of the token spent                               |
| `nonce`  | uint256 | The current nonce of the owner                               |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid         |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowedIfNecessary

```solidity
  function selfPermitAllowedIfNecessary(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `token`  | address | The address of the token spent                               |
| `nonce`  | uint256 | The current nonce of the owner                               |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid         |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IERC20Metadata](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IERC20Metadata)

# IERC20Metadata

Extension to IERC20 that includes token metadata

## Functions

### name

```solidity
  function name(
  ) external returns (string)
```



#### Return Values:

| Type   | Description       |
| :----- | :---------------- |
| string | name of the token |

### symbol

```solidity
  function symbol(
  ) external returns (string)
```



#### Return Values:

| Type   | Description         |
| :----- | :------------------ |
| string | symbol of the token |

### decimals

```solidity
  function decimals(
  ) external returns (uint8)
```



#### Return Values:

| Type  | Description                            |
| :---- | :------------------------------------- |
| uint8 | number of decimal places the token has |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IERC721Permit](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IERC721Permit)

# IERC721Permit

Extension to ERC721 that includes a permit function for signature based approvals

## Functions

### PERMIT_TYPEHASH

```solidity
  function PERMIT_TYPEHASH(
  ) external returns (bytes32)
```



The permit typehash used in the permit signature

#### Return Values:

| Type    | Description             |
| :------ | :---------------------- |
| bytes32 | typehash for the permit |

### DOMAIN_SEPARATOR

```solidity
  function DOMAIN_SEPARATOR(
  ) external returns (bytes32)
```



The domain separator used in the permit signature

#### Return Values:

| Name  | Type | Description                                           |
| :---- | :--- | :---------------------------------------------------- |
| `The` |      | domain seperator used in encoding of permit signature |

### permit

```solidity
  function permit(
    address spender,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Approve of a specific token ID for spending by spender via signature

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `spender`  | address | The account that is being approved                           |
| `tokenId`  | uint256 | The ID of the token that is being approved for spending      |
| `deadline` | uint256 | The deadline timestamp by which the call must be mined for the approve to work |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IMulticall](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IMulticall)

# IMulticall

Enables calling multiple methods in a single call to the contract

## Functions

### multicall

```solidity
  function multicall(
    bytes[] data
  ) external returns (bytes[] results)
```



Call multiple functions in the current contract and return the data from all of them if they all succeed

The `msg.value` should not be trusted for any method callable from multicall.

#### Parameters:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `data` | bytes[] | The encoded function data for each of the calls to make to this contract |

#### Return Values:

| Name      | Type    | Description                                           |
| :-------- | :------ | :---------------------------------------------------- |
| `results` | bytes[] | The results from each of the calls passed in via data |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[INonfungiblePositionManager](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/INonfungiblePositionManager)

# INonfungiblePositionManager

Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred and authorized.

## Parameter Structs

### MintParams

```solidity
  struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }
```



### IncreaseLiquidityParams

```solidity
   struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }
```



### DecreaseLiquidityParams

```solidity
    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }
```



### CollectParams

```solidity
    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }
```



## Functions

### positions

```solidity
  function positions(
    uint256 tokenId
  ) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```



Returns the position information associated with a given token ID.

Throws if the token ID is not valid.

#### Parameters:

| Name      | Type    | Description                                      |
| :-------- | :------ | :----------------------------------------------- |
| `tokenId` | uint256 | The ID of the token that represents the position |

#### Return Values:

| Name                       | Type    | Description                                                  |
| :------------------------- | :------ | :----------------------------------------------------------- |
| `nonce`                    | uint96  | The nonce for permits                                        |
| `operator`                 | address | The address that is approved for spending                    |
| `token0`                   | address | The address of the token0 for a specific pool                |
| `token1`                   | address | The address of the token1 for a specific pool                |
| `fee`                      | uint24  | The fee associated with the pool                             |
| `tickLower`                | int24   | The lower end of the tick range for the position             |
| `tickUpper`                | int24   | The higher end of the tick range for the position            |
| `liquidity`                | uint128 | The liquidity of the position                                |
| `feeGrowthInside0LastX128` | uint256 | The fee growth of token0 as of the last action on the individual position |
| `feeGrowthInside1LastX128` | uint256 | The fee growth of token1 as of the last action on the individual position |
| `tokensOwed0`              | uint128 | The uncollected amount of token0 owed to the position as of the last computation |
| `tokensOwed1`              | uint128 | The uncollected amount of token1 owed to the position as of the last computation |

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address tokenA,
    address tokenB,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```



Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with mint for the first mint of a pool to create, initialize a pool and mint at the same time

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `tokenA`       | address | The contract address of either token0 or token1             |
| `tokenB`       | address | The contract address of the other token                     |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

We use tokenA and tokenB when we are referring to unsorted, or unordered tokens

#### Return Values:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |

### mint

```solidity
  function mint(
    struct INonfungiblePositionManager.MintParams params
  ) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
```



Creates a new position wrapped in a NFT

Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.

#### Parameters:

| Name     | Type                                          | Description                                                  |
| :------- | :-------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.MintParams | The params necessary to mint a position, encoded as `MintParams` in calldata |

#### Return Values:

| Name        | Type    | Description                                             |
| :---------- | :------ | :------------------------------------------------------ |
| `tokenId`   | uint256 | The ID of the token that represents the minted position |
| `liquidity` | uint128 | The amount of liquidity for this position               |
| `amount0`   | uint256 | The amount of token0                                    |
| `amount1`   | uint256 | The amount of token1                                    |

### increaseLiquidity

```solidity
  function increaseLiquidity(
    struct INonfungiblePositionManager.IncreaseLiquidityParams params
  ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1)
```



Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`

#### Parameters:

| Name     | Type                                                       | Description                                                  |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.IncreaseLiquidityParams | tokenId The ID of the token for which liquidity is being increased, |

#### Return Values:

| Name        | Type    | Description                                          |
| :---------- | :------ | :--------------------------------------------------- |
| `liquidity` | uint128 | The new liquidity amount as a result of the increase |
| `amount0`   | uint256 | The amount of token0 to acheive resulting liquidity  |
| `amount1`   | uint256 | The amount of token1 to acheive resulting liquidity  |

### decreaseLiquidity

```solidity
  function decreaseLiquidity(
    struct INonfungiblePositionManager.DecreaseLiquidityParams params
  ) external returns (uint256 amount0, uint256 amount1)
```



Decreases the amount of liquidity in a position and accounts it to the position

#### Parameters:

| Name     | Type                                                       | Description                                                  |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.DecreaseLiquidityParams | tokenId The ID of the token for which liquidity is being decreased |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to recipient |
| `amount1` | uint256 | The amount of token1 sent to recipient |

### collect

```solidity
  function collect(
    struct INonfungiblePositionManager.CollectParams params
  ) external returns (uint256 amount0, uint256 amount1)
```



Collects up to a maximum amount of fees owed to a specific position to the recipient

#### Parameters:

| Name     | Type                                             | Description                                                  |
| :------- | :----------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.CollectParams | tokenId The ID of the NFT for which tokens are being collected, |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of fees collected in token0 |
| `amount1` | uint256 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    uint256 tokenId
  ) external
```



Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first.

#### Parameters:

| Name      | Type    | Description                              |
| :-------- | :------ | :--------------------------------------- |
| `tokenId` | uint256 | The ID of the token that is being burned |

## Events

### IncreaseLiquidity

```solidity
  event IncreaseLiquidity(
    uint256 tokenId,
    uint128 liquidity,
    uint256 amount0,
    uint256 amount1
  )
```



Emitted when liquidity is increased for a position NFT

Also emitted when a token is minted

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which liquidity was increased        |
| `liquidity` | uint128 | The amount by which liquidity for the NFT position was increased |
| `amount0`   | uint256 | The amount of token0 that was paid for the increase in liquidity |
| `amount1`   | uint256 | The amount of token1 that was paid for the increase in liquidity |

### DecreaseLiquidity

```solidity
  event DecreaseLiquidity(
    uint256 tokenId,
    uint128 liquidity,
    uint256 amount0,
    uint256 amount1
  )
```



Emitted when liquidity is decreased for a position NFT

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which liquidity was decreased        |
| `liquidity` | uint128 | The amount by which liquidity for the NFT position was decreased |
| `amount0`   | uint256 | The amount of token0 that was accounted for the decrease in liquidity |
| `amount1`   | uint256 | The amount of token1 that was accounted for the decrease in liquidity |

### Collect

```solidity
  event Collect(
    uint256 tokenId,
    address recipient,
    uint256 amount0,
    uint256 amount1
  )
```



Emitted when tokens are collected for a position NFT

The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which underlying tokens were collected |
| `recipient` | address | The address of the account that received the collected tokens |
| `amount0`   | uint256 | The amount of token0 owed to the position that was collected |
| `amount1`   | uint256 | The amount of token1 owed to the position that was collected |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[INonfungibleTokenPositionDescriptor](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/INonfungibleTokenPositionDescriptor)

# INonfungibleTokenPositionDescriptor

## Functions

### tokenURI

```solidity
  function tokenURI(
    contract INonfungiblePositionManager positionManager,
    uint256 tokenId
  ) external returns (string)
```



Produces the URI describing a particular token ID for a position manager

Note this URI may be a data: URI with the JSON contents directly inlined

#### Parameters:

| Name              | Type                                 | Description                                                  |
| :---------------- | :----------------------------------- | :----------------------------------------------------------- |
| `positionManager` | contract INonfungiblePositionManager | The position manager for which to describe the token         |
| `tokenId`         | uint256                              | The ID of the token for which to produce a description, which may not be valid |

#### Return Values:

| Type   | Description                          |
| :----- | :----------------------------------- |
| string | URI of the ERC721-compliant metadata |

## Events

### UpdateTokenRatioPriority

```solidity
  event UpdateTokenRatioPriority(
    address token,
    int256 priority
  )
```



Emitted when a token is given a new priority order in the displayed price ratio

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `token`    | address | The token being given priority order                         |
| `priority` | int256  | Represents priority in ratio - higher integers get numerator priority |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IPeripheryImmutableState](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IPeripheryImmutableState)

# IPeripheryImmutableState

Functions that return immutable state of the router

## Functions

### factory

```solidity
  function factory(
  ) external returns (address)
```



#### Return Values:

| Type    | Description                           |
| :------ | :------------------------------------ |
| address | the address of the Uniswap V3 factory |

### WETH9

```solidity
  function WETH9(
  ) external returns (address)
```



#### Return Values:

| Type    | Description          |
| :------ | :------------------- |
| address | the address of WETH9 |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IPeripheryPayments](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IPeripheryPayments)

# IPeripheryPayments

Functions to ease deposits and withdrawals of ETH

## Functions

### unwrapWETH9

```solidity
  function unwrapWETH9(
    uint256 amountMinimum,
    address recipient
  ) external
```



Unwraps the contract's WETH9 balance and sends it to recipient as ETH.

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

#### Parameters:

| Name            | Type    | Description                           |
| :-------------- | :------ | :------------------------------------ |
| `amountMinimum` | uint256 | The minimum amount of WETH9 to unwrap |
| `recipient`     | address | The address receiving ETH             |

### refundETH

```solidity
  function refundETH(
  ) external
```



Refunds any ETH balance held by this contract to the `msg.sender`

Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount

### sweepToken

```solidity
  function sweepToken(
    address token,
    uint256 amountMinimum,
    address recipient
  ) external
```



Transfers the full amount of a token held by this contract to recipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

#### Parameters:

| Name            | Type    | Description                                                  |
| :-------------- | :------ | :----------------------------------------------------------- |
| `token`         | address | The contract address of the token which will be transferred to `recipient` |
| `amountMinimum` | uint256 | The minimum amount of token required for a transfer          |
| `recipient`     | address | The destination address of the token                         |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IPeripheryPaymentsWithFee](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IPeripheryPaymentsWithFee)

# IPeripheryPaymentsWithFee

Functions to ease deposits and withdrawals of ETH

## Functions

### unwrapWETH9WithFee

```solidity
  function unwrapWETH9WithFee(
  ) external
```



Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

### sweepTokenWithFee

```solidity
  function sweepTokenWithFee(
  ) external
```



Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IPoolInitializer](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IPoolInitializer)

# IPoolInitializer

Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that require the pool to exist.

## Functions

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address token0,
    address token1,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```



Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `token0`       | address | The contract address of token0 of the pool                  |
| `token1`       | address | The contract address of token1 of the pool                  |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

#### Return Values:

| Name   | Type    | Description                                                  |
| :----- | :------ | :----------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IQuoter](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IQuoter)

# IQuoter

Supports quoting the calculated amounts from exact input or exact output swaps

These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.

## Functions

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut)
```



Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name        | Type    | Description                                         |
| :---------- | :------ | :-------------------------------------------------- |
| `amountOut` | uint256 | The amount of the last token that would be received |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountIn,
    uint160 sqrtPriceLimitX96
  ) external returns (uint256 amountOut)
```



Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                   |
| `tokenOut`          | address | The token being swapped out                                  |
| `fee`               | uint24  | The fee of the token pool to consider for the pair           |
| `amountIn`          | uint256 | The desired input amount                                     |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name        | Type    | Description                                     |
| :---------- | :------ | :---------------------------------------------- |
| `amountOut` | uint256 | The amount of `tokenOut` that would be received |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn)
```



Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                 |
| :---------- | :------ | :---------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountOut` | uint256 | The amount of the last token to receive                     |

#### Return Values:

| Name       | Type    | Description                                   |
| :--------- | :------ | :-------------------------------------------- |
| `amountIn` | uint256 | The amount of first token required to be paid |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountOut,
    uint160 sqrtPriceLimitX96
  ) external returns (uint256 amountIn)
```



Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                   |
| `tokenOut`          | address | The token being swapped out                                  |
| `fee`               | uint24  | The fee of the token pool to consider for the pair           |
| `amountOut`         | uint256 | The desired output amount                                    |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `amountIn` | uint256 | The amount required as the input for the swap in order to receive `amountOut` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IQuoterV2](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IQuoterV2)

# IQuoterV2

Supports quoting the calculated amounts from exact input or exact output swaps. For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.

These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.

## Functions

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```



Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name                          | Type    | Description                                                  |
| :---------------------------- | :------ | :----------------------------------------------------------- |
| `amountOut`                   | bytes   | The amount of the last token that would be received          |
| `sqrtPriceX96AfterList`       | uint256 | List of the sqrt price after the swap for each pool in the path |
| `initializedTicksCrossedList` |         | List of the initialized ticks that the swap crossed for each pool in the path |
| `gasEstimate`                 |         | The estimate of the gas that the swap consumes               |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    struct IQuoterV2.QuoteExactInputSingleParams params
  ) external returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```



Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name     | Type                                         | Description                                                  |
| :------- | :------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct IQuoterV2.QuoteExactInputSingleParams | The params for the quote, encoded as `QuoteExactInputSingleParams` |

tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountIn The desired input amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap

#### Return Values:

| Name                      | Type                                         | Description                                           |
| :------------------------ | :------------------------------------------- | :---------------------------------------------------- |
| `amountOut`               | struct IQuoterV2.QuoteExactInputSingleParams | The amount of `tokenOut` that would be received       |
| `sqrtPriceX96After`       |                                              | The sqrt price of the pool after the swap             |
| `initializedTicksCrossed` |                                              | The number of initialized ticks that the swap crossed |
| `gasEstimate`             |                                              | The estimate of the gas that the swap consumes        |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```



Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order |
| `amountOut` | uint256 | The amount of the last token to receive                      |

#### Return Values:

| Name                          | Type    | Description                                                  |
| :---------------------------- | :------ | :----------------------------------------------------------- |
| `amountIn`                    | bytes   | The amount of first token required to be paid                |
| `sqrtPriceX96AfterList`       | uint256 | List of the sqrt price after the swap for each pool in the path |
| `initializedTicksCrossedList` |         | List of the initialized ticks that the swap crossed for each pool in the path |
| `gasEstimate`                 |         | The estimate of the gas that the swap consumes               |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    struct IQuoterV2.QuoteExactOutputSingleParams params
  ) external returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```



Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name     | Type                                          | Description                                                  |
| :------- | :-------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct IQuoterV2.QuoteExactOutputSingleParams | The params for the quote, encoded as `QuoteExactOutputSingleParams` |

tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountOut The desired output amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap

#### Return Values:

| Name                      | Type                                          | Description                                                  |
| :------------------------ | :-------------------------------------------- | :----------------------------------------------------------- |
| `amountIn`                | struct IQuoterV2.QuoteExactOutputSingleParams | The amount required as the input for the swap in order to receive `amountOut` |
| `sqrtPriceX96After`       |                                               | The sqrt price of the pool after the swap                    |
| `initializedTicksCrossed` |                                               | The number of initialized ticks that the swap crossed        |
| `gasEstimate`             |                                               | The estimate of the gas that the swap consumes               |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[ISelfPermit](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISelfPermit)

# ISelfPermit

Functionality to call permit on any EIP-2612-compliant token for use in the route

## Functions

### selfPermit

```solidity
  function selfPermit(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `token`    | address | The address of the token spent                               |
| `value`    | uint256 | The amount that can be spent of token                        |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitIfNecessary

```solidity
  function selfPermitIfNecessary(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit

#### Parameters:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `token`    | address | The address of the token spent                               |
| `value`    | uint256 | The amount that can be spent of token                        |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowed

```solidity
  function selfPermitAllowed(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `token`  | address | The address of the token spent                               |
| `nonce`  | uint256 | The current nonce of the owner                               |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid         |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowedIfNecessary

```solidity
  function selfPermitAllowedIfNecessary(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `token`  | address | The address of the token spent                               |
| `nonce`  | uint256 | The current nonce of the owner                               |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid         |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[ISwapRouter](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter)

# ISwapRouter

Functions for swapping tokens via Uniswap V3

## Parameter Structs

Note that `fee` is in hundredths of basis points (e.g. the `fee` for a pool at the 0.3% tier is 3000; the `fee` for a pool at the 0.01% tier is 100).

### ExactInputSingleParams

```solidity
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
```



### ExactInputParams

```solidity
   struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }
```



### ExactOutputSingleParams

```solidity
    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }
```



### ExactOutputParams

```solidity
    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }
```



## Functions

### exactInputSingle

```solidity
  function exactInputSingle(
    struct ISwapRouter.ExactInputSingleParams params
  ) external returns (uint256 amountOut)
```



Swaps `amountIn` of one token for as much as possible of another token

#### Parameters:

| Name     | Type                                      | Description                                                  |
| :------- | :---------------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputSingleParams | The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata |

#### Return Values:

| Name        | Type                                      | Description                      |
| :---------- | :---------------------------------------- | :------------------------------- |
| `amountOut` | struct ISwapRouter.ExactInputSingleParams | The amount of the received token |

### exactInput

```solidity
  function exactInput(
    struct ISwapRouter.ExactInputParams params
  ) external returns (uint256 amountOut)
```



Swaps `amountIn` of one token for as much as possible of another along the specified path

#### Parameters:

| Name     | Type                                | Description                                                  |
| :------- | :---------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputParams | The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata |

#### Return Values:

| Name        | Type                                | Description                      |
| :---------- | :---------------------------------- | :------------------------------- |
| `amountOut` | struct ISwapRouter.ExactInputParams | The amount of the received token |

### exactOutputSingle

```solidity
  function exactOutputSingle(
    struct ISwapRouter.ExactOutputSingleParams params
  ) external returns (uint256 amountIn)
```



Swaps as little as possible of one token for `amountOut` of another token

#### Parameters:

| Name     | Type                                       | Description                                                  |
| :------- | :----------------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputSingleParams | The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata |

#### Return Values:

| Name       | Type                                       | Description                   |
| :--------- | :----------------------------------------- | :---------------------------- |
| `amountIn` | struct ISwapRouter.ExactOutputSingleParams | The amount of the input token |

### exactOutput

```solidity
  function exactOutput(
    struct ISwapRouter.ExactOutputParams params
  ) external returns (uint256 amountIn)
```



Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)

#### Parameters:

| Name     | Type                                 | Description                                                  |
| :------- | :----------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputParams | The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata |

#### Return Values:

| Name       | Type                                 | Description                   |
| :--------- | :----------------------------------- | :---------------------------- |
| `amountIn` | struct ISwapRouter.ExactOutputParams | The amount of the input token |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[ITickLens](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ITickLens)

# ITickLens

Provides functions for fetching chunks of tick data for a pool

This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and then sending additional multicalls to fetch the tick data

## Functions

### getPopulatedTicksInWord

```solidity
  function getPopulatedTicksInWord(
    address pool,
    int16 tickBitmapIndex
  ) external returns (struct ITickLens.PopulatedTick[] populatedTicks)
```



Get all the tick data for the populated ticks from a word of the tick bitmap of a pool

#### Parameters:

| Name              | Type    | Description                                                  |
| :---------------- | :------ | :----------------------------------------------------------- |
| `pool`            | address | The address of the pool for which to fetch populated tick data |
| `tickBitmapIndex` | int16   | The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks |

#### Return Values:

| Name             | Type                      | Description                                                 |
| :--------------- | :------------------------ | :---------------------------------------------------------- |
| `populatedTicks` | ITickLens.PopulatedTick[] | An array of tick data for the given word in the tick bitmap |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfaces[IV3Migrator](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IV3Migrator)

# IV3Migrator

Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools

## Functions

### migrate

```solidity
  function migrate(
    struct IV3Migrator.MigrateParams params
  ) external
```



Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3

Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range

#### Parameters:

| Name     | Type                             | Description                                                  |
| :------- | :------------------------------- | :----------------------------------------------------------- |
| `params` | struct IV3Migrator.MigrateParams | The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfacesexternal[IERC1271](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/external/IERC1271)

# IERC1271

Interface that verifies provided signature for the data

Interface defined by EIP-1271

## Functions

### isValidSignature

```solidity
  function isValidSignature(
    bytes32 hash,
    bytes signature
  ) external returns (bytes4 magicValue)
```



Returns whether the provided signature is valid for the provided data

MUST return the bytes4 magic value 0x1626ba7e when function passes. MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5). MUST allow external calls.

#### Parameters:

| Name        | Type    | Description                                |
| :---------- | :------ | :----------------------------------------- |
| `hash`      | bytes32 | Hash of the data to be signed              |
| `signature` | bytes   | Signature byte array associated with _data |

#### Return Values:

| Name         | Type    | Description                       |
| :----------- | :------ | :-------------------------------- |
| `magicValue` | bytes32 | The bytes4 magic value 0x1626ba7e |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfacesexternal[IERC20PermitAllowed](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/external/IERC20PermitAllowed)

# IERC20PermitAllowed

Interface used by DAI/CHAI for permit

## Functions

### permit

```solidity
  function permit(
    address holder,
    address spender,
    uint256 nonce,
    uint256 expiry,
    bool allowed,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```



Approve the spender to spend some tokens via the holder signature

This is the permit interface used by DAI and CHAI

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `holder`  | address | The address of the token holder, the token owner             |
| `spender` | address | The address of the token spender                             |
| `nonce`   | uint256 | The holder's nonce, increases at each call to permit         |
| `expiry`  | uint256 | The timestamp at which the permit is no longer valid         |
| `allowed` | bool    | Boolean that sets approval amount, true for type(uint256).max and false for 0 |
| `v`       | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`       | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`       | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryInterfacesexternal[IWETH9](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/external/IWETH9)

# IWETH9

## Functions

### deposit

```solidity
  function deposit(
  ) external
```



Deposit ether to get wrapped ether

### withdraw

```solidity
  function withdraw(
  ) external
```



Withdraw wrapped ether to get ether

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLens[Quoter](https://docs.uniswap.org/contracts/v3/reference/periphery/lens/Quoter)

# Quoter

Allows getting the expected amount out or amount in for a given swap without executing the swap

These functions are not gas efficient and should *not* be called on chain. Instead, optimistically execute the swap and check the amounts in the callback.

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```



Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                  |
| :------------- | :----- | :----------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by |

the end of the swap. If positive, the callback must send that amount of token0 to the pool. |`amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |`data` | bytes | Any data passed through by the caller via the IUniswapV3PoolActions#swap call

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountIn,
    uint160 sqrtPriceLimitX96
  ) public returns (uint256 amountOut)
```



Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                   |
| `tokenOut`          | address | The token being swapped out                                  |
| `fee`               | uint24  | The fee of the token pool to consider for the pair           |
| `amountIn`          | uint256 | The desired input amount                                     |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name        | Type    | Description                                     |
| :---------- | :------ | :---------------------------------------------- |
| `amountOut` | uint256 | The amount of `tokenOut` that would be received |

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut)
```



Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name        | Type    | Description                                         |
| :---------- | :------ | :-------------------------------------------------- |
| `amountOut` | uint256 | The amount of the last token that would be received |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountOut,
    uint160 sqrtPriceLimitX96
  ) public returns (uint256 amountIn)
```



Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                   |
| `tokenOut`          | address | The token being swapped out                                  |
| `fee`               | uint24  | The fee of the token pool to consider for the pair           |
| `amountOut`         | uint256 | The desired output amount                                    |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name       | Type    | Description                                                  |
| :--------- | :------ | :----------------------------------------------------------- |
| `amountIn` | uint256 | The amount required as the input for the swap in order to receive `amountOut` |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn)
```



Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                 |
| :---------- | :------ | :---------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountOut` | uint256 | The amount of the last token to receive                     |

#### Return Values:

| Name       | Type    | Description                                   |
| :--------- | :------ | :-------------------------------------------- |
| `amountIn` | uint256 | The amount of first token required to be paid |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLens[QuoterV2](https://docs.uniswap.org/contracts/v3/reference/periphery/lens/QuoterV2)

# QuoterV2

Allows getting the expected amount out or amount in for a given swap without executing the swap

These functions are not gas efficient and should *not* be called on chain. Instead, optimistically execute the swap and check the amounts in the callback.

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external view override
```



Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                  |
| :------------- | :----- | :----------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
| `amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
| `data`         | bytes  | Any data passed through by the caller via the IUniswapV3PoolActions#swap call. |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
  ) public override returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```



### quoteExactInput

```solidity
  function quoteExactInput(
  ) public override returns (uint256 amountOut, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```



### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
  ) public override returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```



### quoteExactOutput

```solidity
  function quoteExactOutput(
  ) public override returns (uint256 amountIn, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLens[TickLens](https://docs.uniswap.org/contracts/v3/reference/periphery/lens/TickLens)

# TickLens

## Functions

### getPopulatedTicksInWord

```solidity
  function getPopulatedTicksInWord(
    address pool,
    int16 tickBitmapIndex
  ) public returns (struct ITickLens.PopulatedTick[] populatedTicks)
```



Get all the tick data for the populated ticks from a word of the tick bitmap of a pool

#### Parameters:

| Name              | Type    | Description                                                  |
| :---------------- | :------ | :----------------------------------------------------------- |
| `pool`            | address | The address of the pool for which to fetch populated tick data |
| `tickBitmapIndex` | int16   | The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks |

#### Return Values:

| Name             | Type                      | Description                                                 |
| :--------------- | :------------------------ | :---------------------------------------------------------- |
| `populatedTicks` | ITickLens.PopulatedTick[] | An array of tick data for the given word in the tick bitmap |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[Base64](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/Base64)

# Base64

Provides a function for encoding some bytes in base64

## Functions

### encode

```solidity
  function encode(
  ) internal returns (string)
```



Encodes some bytes to the base64 representation

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[BytesLib](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/BytesLib)

# BytesLib

## Functions

### slice

```solidity
  function slice(
  ) internal returns (bytes)
```



### toAddress

```solidity
  function toAddress(
  ) internal returns (address)
```



### toUint24

```solidity
  function toUint24(
  ) internal returns (uint24)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[CallbackValidation](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/CallbackValidation)

# CallbackValidation

Provides validation for callbacks from Uniswap V3 Pools

## Functions

### verifyCallback

```solidity
  function verifyCallback(
    address factory,
    address tokenA,
    address tokenB,
    uint24 fee
  ) internal returns (contract IUniswapV3Pool pool)
```



Returns the address of a valid Uniswap V3 Pool

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `factory` | address | The contract address of the Uniswap V3 factory               |
| `tokenA`  | address | The contract address of either token0 or token1              |
| `tokenB`  | address | The contract address of the other token                      |
| `fee`     | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |

#### Return Values:

| Name   | Type           | Description                  |
| :----- | :------------- | :--------------------------- |
| `pool` | IUniswapV3Pool | The V3 pool contract address |

### verifyCallback

```solidity
  function verifyCallback(
    address factory,
    struct PoolAddress.PoolKey poolKey
  ) internal returns (contract IUniswapV3Pool pool)
```



Returns the address of a valid Uniswap V3 Pool

#### Parameters:

| Name      | Type                       | Description                                    |
| :-------- | :------------------------- | :--------------------------------------------- |
| `factory` | address                    | The contract address of the Uniswap V3 factory |
| `poolKey` | struct PoolAddress.PoolKey | The identifying key of the V3 pool             |

#### Return Values:

| Name   | Type           | Description                  |
| :----- | :------------- | :--------------------------- |
| `pool` | IUniswapV3Pool | The V3 pool contract address |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[ChainId](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/ChainId)

# ChainId

## Functions

### get

```solidity
  function get(
  ) internal returns (uint256 chainId)
```



Gets the current chain ID

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `chainId` | uint256 | The current chain ID |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[HexStrings](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/HexStrings)

# HexStrings

## Functions

### toHexString

```solidity
  function toHexString(
  ) internal returns (string)
```



Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55

### toHexStringNoPrefix

```solidity
  function toHexStringNoPrefix(
  ) internal returns (string)
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[LiquidityAmounts](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/LiquidityAmounts)

# LiquidityAmounts

Provides functions for computing liquidity amounts from token amounts and prices

## Functions

### getLiquidityForAmount0

```solidity
  function getLiquidityForAmount0(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount0
  ) internal returns (uint128 liquidity)
```



Computes the amount of liquidity received for a given amount of token0 and price range

Calculates amount0 _ (sqrt(upper) _ sqrt(lower)) / (sqrt(upper) - sqrt(lower))

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount0`       | uint256 | The amount0 being sent in                          |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `liquidity` | uint128 | The amount of returned liquidity |

### getLiquidityForAmount1

```solidity
  function getLiquidityForAmount1(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount1
  ) internal returns (uint128 liquidity)
```



Computes the amount of liquidity received for a given amount of token1 and price range

Calculates amount1 / (sqrt(upper) - sqrt(lower)).

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount1`       | uint256 | The amount1 being sent in                          |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `liquidity` | uint128 | The amount of returned liquidity |

### getLiquidityForAmounts

```solidity
  function getLiquidityForAmounts(
    uint160 sqrtRatioX96,
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount0,
    uint256 amount1
  ) internal returns (uint128 liquidity)
```



Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioX96`  | uint160 | A sqrt price representing the current pool prices  |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount0`       | uint256 | The amount of token0 being sent in                 |
| `amount1`       | uint256 | The amount of token1 being sent in                 |

#### Return Values:

| Name        | Type    | Description                              |
| :---------- | :------ | :--------------------------------------- |
| `liquidity` | uint128 | The maximum amount of liquidity received |

### getAmount0ForLiquidity

```solidity
  function getAmount0ForLiquidity(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount0)
```



Computes the amount of token0 for a given amount of liquidity and a price range

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount0` | uint256 | The amount of token0 |

### getAmount1ForLiquidity

```solidity
  function getAmount1ForLiquidity(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount1)
```



Computes the amount of token1 for a given amount of liquidity and a price range

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount1` | uint256 | The amount of token1 |

### getAmountsForLiquidity

```solidity
  function getAmountsForLiquidity(
    uint160 sqrtRatioX96,
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount0, uint256 amount1)
```



Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioX96`  | uint160 | A sqrt price representing the current pool prices  |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount0` | uint256 | The amount of token0 |
| `amount1` | uint256 | The amount of token1 |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[NFTDescriptor](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/NFTDescriptor)

# NFTDescriptor

## Functions

### constructTokenURI

```solidity
  function constructTokenURI(
  ) public returns (string)
```



### escapeQuotes

```solidity
  function escapeQuotes(
  ) internal returns (string)
```



### tickToDecimalString

```solidity
  function tickToDecimalString(
  ) internal returns (string)
```



### fixedPointToDecimalString

```solidity
  function fixedPointToDecimalString(
  ) internal returns (string)
```



### feeToPercentString

```solidity
  function feeToPercentString(
  ) internal returns (string)
```



### addressToString

```solidity
  function addressToString(
  ) internal returns (string)
```



### generateSVGImage

```solidity
  function generateSVGImage(
  ) internal returns (string svg)
```



### tokenToColorHex

```solidity
  function tokenToColorHex(
  ) internal returns (string str)
```



### getCircleCoord

```solidity
  function getCircleCoord(
  ) internal returns (uint256)
```



### sliceTokenHex

```solidity
  function sliceTokenHex(
  ) internal returns (uint256)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[NFTSVG](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/NFTSVG)

# NFTSVG

Provides a function for generating an SVG associated with a Uniswap NFT

## Functions

### generateSVG

```solidity
  function generateSVG(
  ) internal returns (string svg)
```



### getCurve

```solidity
  function getCurve(
  ) internal returns (string curve)
```



### generateSVGCurveCircle

```solidity
  function generateSVGCurveCircle(
  ) internal returns (string svg)
```



### rangeLocation

```solidity
  function rangeLocation(
  ) internal returns (string, string)
```



### isRare

```solidity
  function isRare(
  ) internal returns (bool)
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[OracleLibrary](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/OracleLibrary)

# OracleLibrary

Provides functions to integrate with V3 pool oracle

## Functions

### consult

```solidity
  function consult(
    address pool,
    uint32 period
  ) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)
```



Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `pool`   | address | Address of Uniswap V3 pool that we want to observe           |
| `period` | uint32  | Number of seconds in the past to start calculating time-weighted average |

#### Return Values:

| Name                    | Type    | Description                                                  |
| :---------------------- | :------ | :----------------------------------------------------------- |
| `arithmeticMeanTick`    | int24   | The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp |
| `harmonicMeanLiquidity` | uint128 | The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp |

### getQuoteAtTick

```solidity
  function getQuoteAtTick(
    int24 tick,
    uint128 baseAmount,
    address baseToken,
    address quoteToken
  ) internal pure returns (uint256 quoteAmount)
```



Given a tick and a token amount, calculates the amount of token received in exchange

#### Parameters:

| Name         | Type    | Description                                                  |
| :----------- | :------ | :----------------------------------------------------------- |
| `tick`       | int24   | Tick value used to calculate the quote                       |
| `baseAmount` | uint128 | Amount of token to be converted                              |
| `baseToken`  | address | Address of an ERC20 token contract used as the baseAmount denomination |
| `quoteToken` | address | Address of an ERC20 token contract used as the quoteAmount denomination |

#### Return Values:

| Name          | Type    | Description                                               |
| :------------ | :------ | :-------------------------------------------------------- |
| `quoteAmount` | uint256 | Amount of quoteToken received for baseAmount of baseToken |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[Path](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/Path)

# Path

## Functions

### hasMultiplePools

```solidity
  function hasMultiplePools(
    bytes path
  ) internal returns (bool)
```



Returns true iff the path contains two or more pools

#### Parameters:

| Name   | Type  | Description           |
| :----- | :---- | :-------------------- |
| `path` | bytes | The encoded swap path |

#### Return Values:

| Type | Description                                         |
| :--- | :-------------------------------------------------- |
| bool | if path contains two or more pools, otherwise false |

### decodeFirstPool

```solidity
  function decodeFirstPool(
    bytes path
  ) internal returns (address tokenA, address tokenB, uint24 fee)
```



Decodes the first pool in path

#### Parameters:

| Name   | Type  | Description                 |
| :----- | :---- | :-------------------------- |
| `path` | bytes | The bytes encoded swap path |

#### Return Values:

| Name     | Type    | Description                        |
| :------- | :------ | :--------------------------------- |
| `tokenA` | address | The first token of the given pool  |
| `tokenB` | address | The second token of the given pool |
| `fee`    | uint24  | The fee level of the pool          |

### getFirstPool

```solidity
  function getFirstPool(
    bytes path
  ) internal returns (bytes)
```



Gets the segment corresponding to the first pool in the path

#### Parameters:

| Name   | Type  | Description                 |
| :----- | :---- | :-------------------------- |
| `path` | bytes | The bytes encoded swap path |

#### Return Values:

| Type  | Description                                                  |
| :---- | :----------------------------------------------------------- |
| bytes | segment containing all data necessary to target the first pool in the path |

### skipToken

```solidity
  function skipToken(
    bytes path
  ) internal returns (bytes)
```



Skips a token + fee element from the buffer and returns the remainder

#### Parameters:

| Name   | Type  | Description   |
| :----- | :---- | :------------ |
| `path` | bytes | The swap path |

#### Return Values:

| Type  | Description                                |
| :---- | :----------------------------------------- |
| bytes | remaining token + fee elements in the path |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[PoolAddress](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/PoolAddress)

# PoolAddress

## Functions

### getPoolKey

```solidity
  function getPoolKey(
    address tokenA,
    address tokenB,
    uint24 fee
  ) internal returns (struct PoolAddress.PoolKey)
```



Returns PoolKey: the ordered tokens with the matched fee levels

#### Parameters:

| Name     | Type    | Description                          |
| :------- | :------ | :----------------------------------- |
| `tokenA` | address | The first token of a pool, unsorted  |
| `tokenB` | address | The second token of a pool, unsorted |
| `fee`    | uint24  | The fee level of the pool            |

#### Return Values:

| Name      | Type                | Description                                                 |
| :-------- | :------------------ | :---------------------------------------------------------- |
| `Poolkey` | PoolAddress.PoolKey | The pool details with ordered token0 and token1 assignments |

### computeAddress

```solidity
  function computeAddress(
    address factory,
    struct PoolAddress.PoolKey key
  ) internal returns (address pool)
```



Deterministically computes the pool address given the factory and PoolKey

#### Parameters:

| Name      | Type                       | Description                             |
| :-------- | :------------------------- | :-------------------------------------- |
| `factory` | address                    | The Uniswap V3 factory contract address |
| `key`     | struct PoolAddress.PoolKey | The PoolKey                             |

#### Return Values:

| Name   | Type    | Description                         |
| :----- | :------ | :---------------------------------- |
| `pool` | address | The contract address of the V3 pool |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[PoolTicksCounter](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/PoolTicksCounter)

# PoolTicksCounter

## Functions

### countInitializedTicksCrossed

```solidity
  function countInitializedTicksCrossed(
  ) internal view returns (uint32 initializedTicksCrossed)
```



This function counts the number of initialized ticks that would incur a gas cost between tickBefore and tickAfter. When tickBefore and/or tickAfter themselves are initialized, the logic over whether we should count them depends on the direction of the swap. If we are swapping upwards (tickAfter > tickBefore) we don't want to count tickBefore but we do want to count tickAfter. The opposite is true if we are swapping downwards.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[PositionKey](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/PositionKey)

# PositionKey

## Functions

### compute

```solidity
  function compute(
  ) internal returns (bytes32)
```



Returns the key of the position in the core library

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[TokenRatioSortOrder](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/TokenRatioSortOrder)

# TokenRatioSortOrder

```solidity
library TokenRatioSortOrder {
    int256 constant NUMERATOR_MOST = 300;
    int256 constant NUMERATOR_MORE = 200;
    int256 constant NUMERATOR = 100;
    int256 constant DENOMINATOR_MOST = -300;
    int256 constant DENOMINATOR_MORE = -200;
    int256 constant DENOMINATOR = -100;
}
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[TransferHelper](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/TransferHelper)

# TransferHelper

## Functions

### safeTransferFrom

```solidity
  function safeTransferFrom(
    address token,
    address from,
    address to,
    uint256 value
  ) internal
```



Transfers tokens from the targeted address to the given destination Errors with 'STF' if transfer fails

#### Parameters:

| Name    | Type    | Description                                                  |
| :------ | :------ | :----------------------------------------------------------- |
| `token` | address | The contract address of the token to be transferred          |
| `from`  | address | The originating address from which the tokens will be transferred |
| `to`    | address | The destination address of the transfer                      |
| `value` | uint256 | The amount to be transferred                                 |

### safeTransfer

```solidity
  function safeTransfer(
    address token,
    address to,
    uint256 value
  ) internal
```



Transfers tokens from msg.sender to a recipient

Errors with ST if transfer fails

#### Parameters:

| Name    | Type    | Description                                                 |
| :------ | :------ | :---------------------------------------------------------- |
| `token` | address | The contract address of the token which will be transferred |
| `to`    | address | The recipient of the transfer                               |
| `value` | uint256 | The value of the transfer                                   |

### safeApprove

```solidity
  function safeApprove(
    address token,
    address to,
    uint256 value
  ) internal
```



Approves the stipulated contract to spend the given allowance in the given token

Errors with 'SA' if transfer fails

#### Parameters:

| Name    | Type    | Description                                                  |
| :------ | :------ | :----------------------------------------------------------- |
| `token` | address | The contract address of the token to be approved             |
| `to`    | address | The target of the approval                                   |
| `value` | uint256 | The amount of the given token the target will be allowed to spend |

### safeTransferETH

```solidity
  function safeTransferETH(
    address to,
    uint256 value
  ) internal
```



Transfers ETH to the recipient address

Fails with `STE`

#### Parameters:

| Name    | Type    | Description                     |
| :------ | :------ | :------------------------------ |
| `to`    | address | The destination of the transfer |
| `value` | uint256 | The value to be transferred     |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryLibraries[WeightedOracleLibrary](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/WeightedOracleLibrary)

# WeightedOracleLibrary

Provides functions to integrate with different tier oracles of the same V3 pair

## Functions

### consult

```solidity
  function consult(
    address pool,
    uint32 period
  ) internal view returns (struct WeightedOracleLibrary.PeriodObservation observation)
```



Fetches a time-weighted observation for a given Uniswap V3 pool

#### Parameters:

| Name     | Type    | Description                                                  |
| :------- | :------ | :----------------------------------------------------------- |
| `pool`   | address | Address of the pool that we want to observe                  |
| `period` | uint32  | Number of seconds in the past to start calculating the time-weighted observation |

#### Return Values:

| Name          | Type    | Description                                                  |
| :------------ | :------ | :----------------------------------------------------------- |
| `observation` | address | An observation that has been time-weighted from (block.timestamp - period) to block.timestamp |

### getArithmeticMeanTickWeightedByLiquidity

```solidity
  function getArithmeticMeanTickWeightedByLiquidity(
    struct WeightedOracleLibrary.PeriodObservation[] observations
  ) internal pure returns (int24 arithmeticMeanWeightedTick)
```



Given some time-weighted observations, calculates the arithmetic mean tick, weighted by liquidity

In most scenarios, each entry of `observations` should share the same `period` and underlying `pool` tokens. If `period` differs across observations, the result becomes difficult to interpret and is likely biased/manipulable. If the underlying `pool` tokens differ across observations, extreme care must be taken to ensure that both prices and liquidity values are comparable. Even if prices are commensurate (e.g. two different USD-stable assets against ETH), liquidity values may not be, as decimals can differ between tokens.

#### Parameters:

| Name           | Type                                             | Description                          |
| :------------- | :----------------------------------------------- | :----------------------------------- |
| `observations` | struct WeightedOracleLibrary.PeriodObservation[] | A list of time-weighted observations |

#### Return Values:

| Name                         | Type                                             | Description                                                  |
| :--------------------------- | :----------------------------------------------- | :----------------------------------------------------------- |
| `arithmeticMeanWeightedTick` | struct WeightedOracleLibrary.PeriodObservation[] | The arithmetic mean tick, weighted by the observations' time-weighted harmonic average liquidity |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStaker[Uniswap V3 Staker Design](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/Design)

# Design

The liquidity mining staker design is comprised of one canonical position staking contract, Staker. The technical reference for this contract is [here](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/UniswapV3Staker) and the source code is [here](https://github.com/Uniswap/uniswap-v3-staker).

## Data Structures

```solidity
struct Incentive {
  uint128 totalRewardUnclaimed;
  uint128 numberOfStakes;
  uint160 totalSecondsClaimedX128;
}

struct Deposit {
  address owner;
  uint96 numberOfStakes;
}

struct Stake {
  uint160 secondsPerLiquidityInsideInitialX128;
  uint128 liquidity;
}

struct IncentiveKey {
        IERC20Minimal rewardToken;
        IUniswapV3Pool pool;
        uint256 startTime;
        uint256 endTime;
        address refundee;
}
```



State:

```solidity
IUniswapV3Factory public immutable factory;
INonfungiblePositionManager public immutable nonfungiblePositionManager;

/// @dev bytes32 refers to the return value of IncentiveId.compute
mapping(bytes32 => Incentive) public incentives;

/// @dev deposits[tokenId] => Deposit
mapping(uint256 => Deposit) public deposits;

/// @dev stakes[tokenId][incentiveHash] => Stake
mapping(uint256 => mapping(bytes32 => Stake)) public stakes;

/// @dev rewards[rewardToken][msg.sender] => uint256
mapping(address => mapping(address => uint256)) public rewards;
```



Params:

```solidity
struct CreateIncentiveParams {
  address rewardToken;
  address pool;
  uint256 startTime;
  uint256 endTime;
  uint128 totalReward;
}

struct EndIncentiveParams {
  address creator;
  address rewardToken;
  address pool;
  uint256 startTime;
  uint256 endTime;
}
```



## Incentives

### `createIncentive(CreateIncentiveParams memory params)`

`createIncentive` creates a liquidity mining incentive program. The key used to look up an Incentive is the hash of its immutable properties.

**Check:**

- Incentive with these params does not already exist
- Timestamps: `params.endTime >= params.startTime`, `params.startTime >= block.timestamp`
- Incentive with this ID does not already exist.

**Effects:**

- Sets `incentives[key] = Incentive(totalRewardUnclaimed=totalReward, totalSecondsClaimedX128=0, rewardToken=rewardToken)`

**Interaction:**

- Transfers

   

  ```
  params.totalReward
  ```

   

  from

   

  ```
  msg.sender
  ```

   

  to self.

  - Make sure there is a check here and it fails if the transfer fails

- Emits `IncentiveCreated`

### `endIncentive(EndIncentiveParams memory params)`

`endIncentive` can be called by anyone to end an Incentive after the `endTime` has passed, transferring `totalRewardUnclaimed` of `rewardToken` back to `refundee`.

**Check:**

- `block.timestamp > params.endTime`
- Incentive exists (`incentive.totalRewardUnclaimed != 0`)

**Effects:**

- deletes `incentives[key]` (This is a new change)

**Interactions:**

- safeTransfers `totalRewardUnclaimed` of `rewardToken` to the incentive creator `msg.sender`
- emits `IncentiveEnded`

## Deposit/Withdraw Token

**Interactions**

- ```
  nonfungiblePositionManager.safeTransferFrom(sender, this, tokenId)
  ```

  - This transfer triggers the onERC721Received hook

### `onERC721Received(address, address from, uint256 tokenId, bytes calldata data)`

**Check:**

- Make sure sender is univ3 nft

**Effects:**

- Creates a deposit for the token setting deposit

   

  ```
  owner
  ```

   

  to

   

  ```
  from
  ```

  .

  - Setting `owner` to `from` ensures that the owner of the token also owns the deposit. Approved addresses and operators may first transfer the token to themselves before depositing for deposit ownership.

- If `data.length>0`, stakes the token in one or more incentives

### `withdrawToken(uint256 tokenId, address to, bytes memory data)`

**Checks**

- Check that a Deposit exists for the token and that `msg.sender` is the `owner` on that Deposit.
- Check that `numberOfStakes` on that Deposit is 0.

**Effects**

- Delete the Deposit `delete deposits[tokenId]`.

**Interactions**

- `safeTransferFrom` the token to `to` with `data`.
- emit `DepositTransferred(token, deposit.owner, address(0))`

## Stake/Unstake/Rewards

### `stakeToken`

**Check:**

- `deposits[params.tokenId].owner == msg.sender`
- Make sure incentive actually exists and has reward that could be claimed (incentive.rewardToken != address(0))
  - Check if this check can check totalRewardUnclaimed instead
- Make sure token not already staked

### `claimReward`

**Interactions**

- `msg.sender` to withdraw all of their reward balance in a specific token to a specified `to` address.
- emit RewardClaimed(to, reward)

### `unstakeToken`

To unstake an NFT, you call `unstakeToken`, which takes all the same arguments as `stake`.

**Checks**

- It checks that you are the owner of the Deposit
- It checks that there exists a `Stake` for the provided key (with exists=true).

**Effects**

- Deletes the Stake.
- Decrements `numberOfStakes` for the Deposit by 1.
- `totalRewardsUnclaimed` is decremented by `reward`.
- `totalSecondsClaimed` is incremented by `seconds`.
- Increments `rewards[rewardToken][msg.sender]` by the amount given by `getRewardInfo`.

### `getRewardInfo`

- It computes `secondsInsideX128` (the total liquidity seconds for which rewards are owed) for a given Stake, by:
  - using`snapshotCumulativesInside` from the Uniswap v3 core contract to get `secondsPerLiquidityInRangeX128`, and subtracting `secondsPerLiquidityInRangeInitialX128`.
  - Multiplying that by `stake.liquidity` to get the total seconds accrued by the liquidity in that period
- Note that X128 means it's a `UQ32X128`.
- It computes `totalSecondsUnclaimed` by taking `max(endTime, block.timestamp) - startTime`, casting it as a Q128, and subtracting `totalSecondsClaimedX128`.
- It computes `rewardRate` for the Incentive casting `incentive.totalRewardUnclaimed` as a Q128, then dividing it by `totalSecondsUnclaimedX128`.
- `reward` is then calculated as `secondsInsideX128` times the `rewardRate`, scaled down to a regular uint128.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStaker[Uniswap V3 Staker Contract](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/UniswapV3Staker)

# UniswapV3Staker

Below is the technical reference for the staker contract, [`UniswapV3Staker.sol`](https://github.com/Uniswap/uniswap-v3-staker/blob/main/contracts/UniswapV3Staker.sol). A technical guide for interacting with this staking contract will be released soon.

## Functions

### stakes

```solidity
  function stakes(
    uint256 tokenId,
    bytes32 incentiveId
  ) public view override returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)
```



Returns information about a staked liquidity NFT

#### Parameters:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `tokenId`     | uint256 | The ID of the staked token                            |
| `incentiveId` | bytes32 | The ID of the incentive for which the token is staked |

#### Return Values:

| Name                                   | Type    | Description                                                  |
| :------------------------------------- | :------ | :----------------------------------------------------------- |
| `secondsPerLiquidityInsideInitialX128` | uint160 | secondsPerLiquidity represented as a UQ32.128                |
| `liquidity`                            | bytes32 | The amount of liquidity in the NFT as of the last time the rewards were computed |

### constructor

```solidity
  function constructor(
    contract IUniswapV3Factory _factory,
    contract INonfungiblePositionManager _nonfungiblePositionManager,
    uint256 _maxIncentiveStartLeadTime,
    uint256 _maxIncentiveDuration
  ) public
```



#### Parameters:

| Name                          | Type                                 | Description                                                  |
| :---------------------------- | :----------------------------------- | :----------------------------------------------------------- |
| `_factory`                    | contract IUniswapV3Factory           | the Uniswap V3 factory                                       |
| `_nonfungiblePositionManager` | contract INonfungiblePositionManager | the NFT position manager contract address                    |
| `_maxIncentiveStartLeadTime`  | uint256                              | the max duration of an incentive in seconds                  |
| `_maxIncentiveDuration`       | uint256                              | the max amount of seconds into the future the incentive startTime can be set |

### createIncentive

```solidity
  function createIncentive(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 reward
  ) external
```



Creates a new liquidity mining incentive program

#### Parameters:

| Name     | Type                                 | Description                                   |
| :------- | :----------------------------------- | :-------------------------------------------- |
| `key`    | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to create            |
| `reward` | uint256                              | The amount of reward tokens to be distributed |

### endIncentive

```solidity
  function endIncentive(
    struct IUniswapV3Staker.IncentiveKey key
  ) external returns (uint256 refund)
```



Ends an incentive after the incentive end time has passed and all stakes have been withdrawn

#### Parameters:

| Name  | Type                                 | Description                     |
| :---- | :----------------------------------- | :------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to end |

#### Return Values:

| Name     | Type    | Description                                             |
| :------- | :------ | :------------------------------------------------------ |
| `refund` | uint256 | The remaining reward tokens when the incentive is ended |

### onERC721Received

```solidity
  function onERC721Received(
  ) external returns (bytes4)
```



Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`. Also stakes token in one or more incentives if properly formatted `data` has a length > 0.

Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

### transferDeposit

```solidity
  function transferDeposit(
    uint256 tokenId,
    address to
  ) external
```



Transfers ownership of a deposit from the sender to the given recipient

#### Parameters:

| Name      | Type    | Description                                       |
| :-------- | :------ | :------------------------------------------------ |
| `tokenId` | uint256 | The ID of the token (and the deposit) to transfer |
| `to`      | address | The new owner of the deposit                      |

### withdrawToken

```solidity
  function withdrawToken(
    uint256 tokenId,
    address to,
    bytes data
  ) external
```



Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `tokenId` | uint256 | The unique identifier of an Uniswap V3 LP token              |
| `to`      | address | The address where the LP token will be sent                  |
| `data`    | bytes   | An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom |

### stakeToken

```solidity
  function stakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```



Stakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                         |
| :-------- | :----------------------------------- | :-------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to stake the NFT |
| `tokenId` | uint256                              | The ID of the token to stake                        |

### unstakeToken

```solidity
  function unstakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```



Unstakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                           |
| :-------- | :----------------------------------- | :---------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to unstake the NFT |
| `tokenId` | uint256                              | The ID of the token to unstake                        |

### claimReward

```solidity
  function claimReward(
    contract IERC20Minimal rewardToken,
    address to,
    uint256 amountRequested
  ) external override returns (uint256 reward)
```



Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`

#### Parameters:

| Name              | Type                   | Description                                                  |
| :---------------- | :--------------------- | :----------------------------------------------------------- |
| `rewardToken`     | contract IERC20Minimal | The token being distributed as a reward                      |
| `to`              | address                | The address where claimed rewards will be sent to            |
| `amountRequested` | uint256                | The amount of reward tokens to claim. Claims entire reward amount if set to 0. |

#### Return Values:

| Name     | Type    | Description                         |
| :------- | :------ | :---------------------------------- |
| `reward` | uint256 | The amount of reward tokens claimed |

### getRewardInfo

```solidity
  function getRewardInfo(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external view override returns (uint256 reward, uint160 secondsInsideX128)
```



Calculates the reward amount that will be received for the given stake

#### Parameters:

| Name      | Type                                 | Description              |
| :-------- | :----------------------------------- | :----------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive |
| `tokenId` | uint256                              | The ID of the token      |

#### Return Values:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `reward`            | uint256 | The reward accrued to the NFT for the given incentive thus far |
| `secondsInsideX128` | uint160 | The seconds inside the tick range                            |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStakerInterfaces[IUniswapV3Staker](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/interfaces/IUniswapV3Staker)

# IUniswapV3Staker

Allows staking nonfungible liquidity tokens in exchange for reward tokens

## Functions

### factory

```solidity
  function factory(
  ) external view returns (contract IUniswapV3Factory)
```



The Uniswap V3 Factory

### nonfungiblePositionManager

```solidity
  function nonfungiblePositionManager(
  ) external view returns (contract INonfungiblePositionManager)
```



The nonfungible position manager with which this staking contract is compatible

### maxIncentiveDuration

```solidity
  function maxIncentiveDuration(
  ) external view returns (uint256)
```



The max duration of an incentive in seconds

### maxIncentiveStartLeadTime

```solidity
  function maxIncentiveStartLeadTime(
  ) external view returns (uint256)
```



The max amount of seconds into the future the incentive startTime can be set

### incentives

```solidity
  function incentives(
    bytes32 incentiveId
  ) external view returns (uint256 totalRewardUnclaimed, uint160 totalSecondsClaimedX128, uint96 numberOfStakes)
```



Represents a staking incentive

#### Parameters:

| Name          | Type    | Description                                          |
| :------------ | :------ | :--------------------------------------------------- |
| `incentiveId` | bytes32 | The ID of the incentive computed from its parameters |

#### Return Values:

| Name                      | Type    | Description                                                  |
| :------------------------ | :------ | :----------------------------------------------------------- |
| `totalRewardUnclaimed`    | uint256 | The amount of reward token not yet claimed by users          |
| `totalSecondsClaimedX128` | uint160 | Total liquidity-seconds claimed, represented as a UQ32.128   |
| `numberOfStakes`          | uint96  | The count of deposits that are currently staked for the incentive |

### deposits

```solidity
  function deposits(
  ) external view returns (address owner, uint48 numberOfStakes, int24 tickLower, int24 tickUpper)
```



Returns information about a deposited NFT

#### Return Values:

| Name             | Type    | Description                                                  |
| :--------------- | :------ | :----------------------------------------------------------- |
| `owner`          | address | The owner of the deposited NFT                               |
| `numberOfStakes` | uint48  | Counter of how many incentives for which the liquidity is staked |
| `tickLower`      | int24   | The lower tick of the range                                  |
| `tickUpper`      | int24   | The upper tick of the range                                  |

### stakes

```solidity
  function stakes(
    uint256 tokenId,
    bytes32 incentiveId
  ) external view returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)
```



Returns information about a staked liquidity NFT

#### Parameters:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `tokenId`     | uint256 | The ID of the staked token                            |
| `incentiveId` | bytes32 | The ID of the incentive for which the token is staked |

#### Return Values:

| Name                                   | Type    | Description                                                  |
| :------------------------------------- | :------ | :----------------------------------------------------------- |
| `secondsPerLiquidityInsideInitialX128` | uint160 | secondsPerLiquidity represented as a UQ32.128                |
| `liquidity`                            | uint128 | The amount of liquidity in the NFT as of the last time the rewards were computed |

### rewards

```solidity
  function rewards(
    contract IERC20Minimal rewardToken,
    address owner
  ) external view returns (uint256 rewardsOwed)
```



Returns amounts of reward tokens owed to a given address according to the last time all stakes were updated

#### Parameters:

| Name          | Type                   | Description                                      |
| :------------ | :--------------------- | :----------------------------------------------- |
| `rewardToken` | contract IERC20Minimal | The token for which to check rewards             |
| `owner`       | address                | The owner for which the rewards owed are checked |

#### Return Values:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `rewardsOwed` | uint256 | The amount of the reward token claimable by the owner |

### createIncentive

```solidity
  function createIncentive(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 reward
  ) external
```



Creates a new liquidity mining incentive program

#### Parameters:

| Name     | Type                                 | Description                                   |
| :------- | :----------------------------------- | :-------------------------------------------- |
| `key`    | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to create            |
| `reward` | uint256                              | The amount of reward tokens to be distributed |

### endIncentive

```solidity
  function endIncentive(
    struct IUniswapV3Staker.IncentiveKey key
  ) external returns (uint256 refund)
```



Ends an incentive after the incentive end time has passed and all stakes have been withdrawn

#### Parameters:

| Name  | Type                                 | Description                     |
| :---- | :----------------------------------- | :------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to end |

#### Return Values:

| Name     | Type    | Description                                             |
| :------- | :------ | :------------------------------------------------------ |
| `refund` | uint256 | The remaining reward tokens when the incentive is ended |

### transferDeposit

```solidity
  function transferDeposit(
    uint256 tokenId,
    address to
  ) external
```



Transfers ownership of a deposit from the sender to the given recipient

#### Parameters:

| Name      | Type    | Description                                       |
| :-------- | :------ | :------------------------------------------------ |
| `tokenId` | uint256 | The ID of the token (and the deposit) to transfer |
| `to`      | address | The new owner of the deposit                      |

### withdrawToken

```solidity
  function withdrawToken(
    uint256 tokenId,
    address to,
    bytes data
  ) external
```



Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`

#### Parameters:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `tokenId` | uint256 | The unique identifier of an Uniswap V3 LP token              |
| `to`      | address | The address where the LP token will be sent                  |
| `data`    | bytes   | An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom |

### stakeToken

```solidity
  function stakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```



Stakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                         |
| :-------- | :----------------------------------- | :-------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to stake the NFT |
| `tokenId` | uint256                              | The ID of the token to stake                        |

### unstakeToken

```solidity
  function unstakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```



Unstakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                           |
| :-------- | :----------------------------------- | :---------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to unstake the NFT |
| `tokenId` | uint256                              | The ID of the token to unstake                        |

### claimReward

```solidity
  function claimReward(
    contract IERC20Minimal rewardToken,
    address to,
    uint256 amountRequested
  ) external returns (uint256 reward)
```



Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`

#### Parameters:

| Name              | Type                   | Description                                                  |
| :---------------- | :--------------------- | :----------------------------------------------------------- |
| `rewardToken`     | contract IERC20Minimal | The token being distributed as a reward                      |
| `to`              | address                | The address where claimed rewards will be sent to            |
| `amountRequested` | uint256                | The amount of reward tokens to claim. Claims entire reward amount if set to 0. |

#### Return Values:

| Name     | Type    | Description                         |
| :------- | :------ | :---------------------------------- |
| `reward` | uint256 | The amount of reward tokens claimed |

### getRewardInfo

```solidity
  function getRewardInfo(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external returns (uint256 reward, uint160 secondsInsideX128)
```



Calculates the reward amount that will be received for the given stake

#### Parameters:

| Name      | Type                                 | Description              |
| :-------- | :----------------------------------- | :----------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive |
| `tokenId` | uint256                              | The ID of the token      |

#### Return Values:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `reward`            | uint256 | The reward accrued to the NFT for the given incentive thus far |
| `secondsInsideX128` | uint160 | The seconds inside the tick range                            |

## Events

### IncentiveCreated

```solidity
  event IncentiveCreated(
    contract IERC20Minimal rewardToken,
    contract IUniswapV3Pool pool,
    uint256 startTime,
    uint256 endTime,
    address refundee,
    uint256 reward
  )
```



Event emitted when a liquidity mining incentive has been created

#### Parameters:

| Name          | Type                    | Description                                                  |
| :------------ | :---------------------- | :----------------------------------------------------------- |
| `rewardToken` | contract IERC20Minimal  | The token being distributed as a reward                      |
| `pool`        | contract IUniswapV3Pool | The Uniswap V3 pool                                          |
| `startTime`   | uint256                 | The time when the incentive program begins                   |
| `endTime`     | uint256                 | The time when rewards stop accruing                          |
| `refundee`    | address                 | The address which receives any remaining reward tokens after the end time |
| `reward`      | uint256                 | The amount of reward tokens to be distributed                |

### IncentiveEnded

```solidity
  event IncentiveEnded(
    bytes32 incentiveId,
    uint256 refund
  )
```



Event that can be emitted when a liquidity mining incentive has ended

#### Parameters:

| Name          | Type    | Description                          |
| :------------ | :------ | :----------------------------------- |
| `incentiveId` | bytes32 | The incentive which is ending        |
| `refund`      | uint256 | The amount of reward tokens refunded |

### DepositTransferred

```solidity
  event DepositTransferred(
    uint256 tokenId,
    address oldOwner,
    address newOwner
  )
```



Emitted when ownership of a deposit changes

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `tokenId`  | uint256 | The ID of the deposit (and token) that is being transferred |
| `oldOwner` | address | The owner before the deposit was transferred                |
| `newOwner` | address | The owner after the deposit was transferred                 |

### TokenStaked

```solidity
  event TokenStaked(
    uint256 tokenId,
    bytes32 liquidity,
    uint128 incentiveId
  )
```



Event emitted when a Uniswap V3 LP token has been staked

#### Parameters:

| Name          | Type    | Description                                     |
| :------------ | :------ | :---------------------------------------------- |
| `tokenId`     | uint256 | The unique identifier of an Uniswap V3 LP token |
| `liquidity`   | bytes32 | The amount of liquidity staked                  |
| `incentiveId` | uint128 | The incentive in which the token is staking     |

### TokenUnstaked

```solidity
  event TokenUnstaked(
    uint256 tokenId,
    bytes32 incentiveId
  )
```



Event emitted when a Uniswap V3 LP token has been unstaked

#### Parameters:

| Name          | Type    | Description                                     |
| :------------ | :------ | :---------------------------------------------- |
| `tokenId`     | uint256 | The unique identifier of an Uniswap V3 LP token |
| `incentiveId` | bytes32 | The incentive in which the token is staking     |

### RewardClaimed

```solidity
  event RewardClaimed(
    address to,
    uint256 reward
  )
```



Event emitted when a reward token has been claimed

#### Parameters:

| Name     | Type    | Description                                    |
| :------- | :------ | :--------------------------------------------- |
| `to`     | address | The address where claimed rewards were sent to |
| `reward` | uint256 | The amount of reward tokens claimed            |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStakerLibraries[IncentiveId](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/libraries/IncentiveId)

# IncentiveId

## Functions

### compute

```solidity
  function compute(
    struct IUniswapV3Staker.IncentiveKey key
  ) internal pure returns (bytes32 incentiveId)
```



Calculate the key for a staking incentive

#### Parameters:

| Name  | Type                                 | Description                                             |
| :---- | :----------------------------------- | :------------------------------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | The components used to compute the incentive identifier |

#### Return Values:

| Name          | Type    | Description                      |
| :------------ | :------ | :------------------------------- |
| `incentiveId` | bytes32 | The identifier for the incentive |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStakerLibraries[NFTPositionInfo](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/libraries/NFTPositionInfo)

# NFTPositionInfo

Encapsulates the logic for getting info about a NFT token ID

## Functions

### getPositionInfo

```solidity
  function getPositionInfo(
    contract IUniswapV3Factory factory,
    contract INonfungiblePositionManager nonfungiblePositionManager,
    uint256 tokenId
  ) internal view returns (contract IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity)
```



#### Parameters:

| Name                         | Type                                 | Description                                                  |
| :--------------------------- | :----------------------------------- | :----------------------------------------------------------- |
| `factory`                    | contract IUniswapV3Factory           | The address of the Uniswap V3 Factory used in computing the pool address |
| `nonfungiblePositionManager` | contract INonfungiblePositionManager | The address of the nonfungible position manager to query     |
| `tokenId`                    | uint256                              | The unique identifier of an Uniswap V3 LP token              |

#### Return Values:

| Name        | Type           | Description                               |
| :---------- | :------------- | :---------------------------------------- |
| `pool`      | IUniswapV3Pool | The address of the Uniswap V3 pool        |
| `tickLower` | int24          | The lower tick of the Uniswap V3 position |
| `tickUpper` | int24          | The upper tick of the Uniswap V3 position |
| `liquidity` | uint128        | The amount of liquidity staked            |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryStakerLibraries[RewardMath](https://docs.uniswap.org/contracts/v3/reference/periphery/staker/libraries/RewardMath)

# RewardMath

Allows computing rewards given some parameters of stakes and incentives

## Functions

### computeRewardAmount

```solidity
  function computeRewardAmount(
    uint256 totalRewardUnclaimed,
    uint160 totalSecondsClaimedX128,
    uint256 startTime,
    uint256 endTime,
    uint128 liquidity,
    uint160 secondsPerLiquidityInsideInitialX128,
    uint160 secondsPerLiquidityInsideX128,
    uint256 currentTime
  ) internal pure returns (uint256 reward, uint160 secondsInsideX128)
```



Compute the amount of rewards owed given parameters of the incentive and stake

#### Parameters:

| Name                                   | Type    | Description                                                  |
| :------------------------------------- | :------ | :----------------------------------------------------------- |
| `totalRewardUnclaimed`                 | uint256 | The total amount of unclaimed rewards left for an incentive  |
| `totalSecondsClaimedX128`              | uint160 | How many full liquidity-seconds have been already claimed for the incentive |
| `startTime`                            | uint256 | When the incentive rewards began in epoch seconds            |
| `endTime`                              | uint256 | When rewards are no longer being dripped out in epoch seconds |
| `liquidity`                            | uint128 | The amount of liquidity, assumed to be constant over the period over which the snapshots are measured |
| `secondsPerLiquidityInsideInitialX128` | uint160 | The seconds per liquidity of the liquidity tick range as of the beginning of the period |
| `secondsPerLiquidityInsideX128`        | uint160 | The seconds per liquidity of the liquidity tick range as of the current block timestamp |
| `currentTime`                          | uint256 | The current block timestamp, which must be greater than or equal to the start time |

#### Return Values:

| Name                | Type    | Description                                                  |
| :------------------ | :------ | :----------------------------------------------------------- |
| `reward`            | uint256 | The amount of rewards owed                                   |
| `secondsInsideX128` | uint160 | The total liquidity seconds inside the position's range for the duration of the stake |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[Base64Test](https://docs.uniswap.org/contracts/v3/reference/periphery/test/Base64Test)

# Base64Test

## Functions

### encode

```solidity
  function encode(
  ) external returns (string)
```



### getGasCostOfEncode

```solidity
  function getGasCostOfEncode(
  ) external returns (uint256)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[LiquidityAmountsTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/LiquidityAmountsTest)

# LiquidityAmountsTest

## Functions

### getLiquidityForAmount0

```solidity
  function getLiquidityForAmount0(
  ) external returns (uint128 liquidity)
```



### getGasCostOfGetLiquidityForAmount0

```solidity
  function getGasCostOfGetLiquidityForAmount0(
  ) external returns (uint256)
```



### getLiquidityForAmount1

```solidity
  function getLiquidityForAmount1(
  ) external returns (uint128 liquidity)
```



### getGasCostOfGetLiquidityForAmount1

```solidity
  function getGasCostOfGetLiquidityForAmount1(
  ) external returns (uint256)
```



### getLiquidityForAmounts

```solidity
  function getLiquidityForAmounts(
  ) external returns (uint128 liquidity)
```



### getGasCostOfGetLiquidityForAmounts

```solidity
  function getGasCostOfGetLiquidityForAmounts(
  ) external returns (uint256)
```



### getAmount0ForLiquidity

```solidity
  function getAmount0ForLiquidity(
  ) external returns (uint256 amount0)
```



### getGasCostOfGetAmount0ForLiquidity

```solidity
  function getGasCostOfGetAmount0ForLiquidity(
  ) external returns (uint256)
```



### getAmount1ForLiquidity

```solidity
  function getAmount1ForLiquidity(
  ) external returns (uint256 amount1)
```



### getGasCostOfGetAmount1ForLiquidity

```solidity
  function getGasCostOfGetAmount1ForLiquidity(
  ) external returns (uint256)
```



### getAmountsForLiquidity

```solidity
  function getAmountsForLiquidity(
  ) external returns (uint256 amount0, uint256 amount1)
```



### getGasCostOfGetAmountsForLiquidity

```solidity
  function getGasCostOfGetAmountsForLiquidity(
  ) external returns (uint256)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[MockTimeNonfungiblePositionManager](https://docs.uniswap.org/contracts/v3/reference/periphery/test/MockTimeNonfungiblePositionManager)

# MockTimeNonfungiblePositionManager

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### _blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal returns (uint256)
```



### setTime

```solidity
  function setTime(
  ) external
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[MockTimeSwapRouter](https://docs.uniswap.org/contracts/v3/reference/periphery/test/MockTimeSwapRouter)

# MockTimeSwapRouter

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### _blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal returns (uint256)
```



### setTime

```solidity
  function setTime(
  ) external
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[NFTDescriptorTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/NFTDescriptorTest)

# NFTDescriptorTest

## Functions

### constructTokenURI

```solidity
  function constructTokenURI(
  ) public returns (string)
```



### getGasCostOfConstructTokenURI

```solidity
  function getGasCostOfConstructTokenURI(
  ) public returns (uint256)
```



### tickToDecimalString

```solidity
  function tickToDecimalString(
  ) public returns (string)
```



### fixedPointToDecimalString

```solidity
  function fixedPointToDecimalString(
  ) public returns (string)
```



### feeToPercentString

```solidity
  function feeToPercentString(
  ) public returns (string)
```



### addressToString

```solidity
  function addressToString(
  ) public returns (string)
```



### generateSVGImage

```solidity
  function generateSVGImage(
  ) public returns (string)
```



### tokenToColorHex

```solidity
  function tokenToColorHex(
  ) public returns (string)
```



### sliceTokenHex

```solidity
  function sliceTokenHex(
  ) public returns (uint256)
```



### rangeLocation

```solidity
  function rangeLocation(
  ) public returns (string, string)
```



### isRare

```solidity
  function isRare(
  ) public returns (bool)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[PathTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/PathTest)

# PathTest

## Functions

### hasMultiplePools

```solidity
  function hasMultiplePools(
  ) public returns (bool)
```



### decodeFirstPool

```solidity
  function decodeFirstPool(
  ) public returns (address tokenA, address tokenB, uint24 fee)
```



### getFirstPool

```solidity
  function getFirstPool(
  ) public returns (bytes)
```



### skipToken

```solidity
  function skipToken(
  ) public returns (bytes)
```



### getGasCostOfDecodeFirstPool

```solidity
  function getGasCostOfDecodeFirstPool(
  ) public returns (uint256)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[PeripheryImmutableStateTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/PeripheryImmutableStateTest)

# PeripheryImmutableStateTest

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[PoolAddressTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/PoolAddressTest)

# PoolAddressTest

## Functions

### POOL_INIT_CODE_HASH

```solidity
  function POOL_INIT_CODE_HASH(
  ) external returns (bytes32)
```



### computeAddress

```solidity
  function computeAddress(
  ) external returns (address)
```



### getGasCostOfComputeAddress

```solidity
  function getGasCostOfComputeAddress(
  ) external returns (uint256)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[SelfPermitTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/SelfPermitTest)

# SelfPermitTest

Same as SelfPermit but not abstract

# TestCallbackValidation

## Functions

### verifyCallback

```solidity
  function verifyCallback(
  ) external returns (contract IUniswapV3Pool pool)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestERC20](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestERC20)

# TestERC20

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestERC20Metadata](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestERC20Metadata)

# TestERC20Metadata

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestERC20PermitAllowed](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestERC20PermitAllowed)

# TestERC20PermitAllowed

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### permit

```solidity
  function permit(
  ) external
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestMulticall](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestMulticall)

# TestMulticall

## Functions

### functionThatRevertsWithError

```solidity
  function functionThatRevertsWithError(
  ) external
```



### functionThatReturnsTuple

```solidity
  function functionThatReturnsTuple(
  ) external returns (struct TestMulticall.Tuple tuple)
```



### pays

```solidity
  function pays(
  ) external
```



### returnSender

```solidity
  function returnSender(
  ) external returns (address)
```


[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestPositionNFTOwner](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestPositionNFTOwner)

# TestPositionNFTOwner

## Functions

### setOwner

```solidity
  function setOwner(
  ) external
```



### isValidSignature

```solidity
  function isValidSignature(
  ) external returns (bytes4 magicValue)
```

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TestUniswapV3Callee](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TestUniswapV3Callee)

# TestUniswapV3Callee

## Functions

### swapExact0For1

```solidity
  function swapExact0For1(
  ) external
```



### swap0ForExact1

```solidity
  function swap0ForExact1(
  ) external
```



### swapExact1For0

```solidity
  function swapExact1For0(
  ) external
```



### swap1ForExact0

```solidity
  function swap1ForExact0(
  ) external
```



### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
  ) external
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeripheryTest[TickLensTest](https://docs.uniswap.org/contracts/v3/reference/periphery/test/TickLensTest)

# TickLensTest

## Functions

### getGasCostOfGetPopulatedTicksInWord

```solidity
  function getGasCostOfGetPopulatedTicksInWord(
  ) external returns (uint256)
```





[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeriphery[NonfungiblePositionManager](https://docs.uniswap.org/contracts/v3/reference/periphery/NonfungiblePositionManager)

# NonfungiblePositionManager

Wraps Uniswap V3 positions in the ERC721 non-fungible token interface

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### positions

```solidity
  function positions(
    uint256 tokenId
  ) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```



Returns the position information associated with a given token ID.

Throws if the token ID is not valid.

#### Parameters:

| Name      | Type    | Description                                      |
| :-------- | :------ | :----------------------------------------------- |
| `tokenId` | uint256 | The ID of the token that represents the position |

#### Return Values:

| Name                       | Type    | Description                                                  |
| :------------------------- | :------ | :----------------------------------------------------------- |
| `nonce`                    | uint96  | The nonce for permits                                        |
| `operator`                 | address | The address that is approved for spending                    |
| `token0`                   | address | The address of the token0 for a specific pool                |
| `token1`                   | address | The address of the token1 for a specific pool                |
| `fee`                      | uint24  | The fee associated with the pool                             |
| `tickLower`                | int24   | The lower end of the tick range for the position             |
| `tickUpper`                | int24   | The higher end of the tick range for the position            |
| `liquidity`                | uint128 | The liquidity of the position                                |
| `feeGrowthInside0LastX128` | uint256 | The fee growth of token0 as of the last action on the individual position |
| `feeGrowthInside1LastX128` | uint256 | The fee growth of token1 as of the last action on the individual position |
| `tokensOwed0`              | uint128 | The uncollected amount of token0 owed to the position as of the last computation |
| `tokensOwed1`              | uint128 | The uncollected amount of token1 owed to the position as of the last computation |

### mint

```solidity
  function mint(
    struct INonfungiblePositionManager.MintParams params
  ) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
```



Creates a new position wrapped in a NFT

Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.

#### Parameters:

| Name     | Type                                          | Description                                                  |
| :------- | :-------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.MintParams | The params necessary to mint a position, encoded as `MintParams` in calldata |

#### Return Values:

| Name        | Type    | Description                                             |
| :---------- | :------ | :------------------------------------------------------ |
| `tokenId`   | uint256 | The ID of the token that represents the minted position |
| `liquidity` | uint128 | The amount of liquidity for this position               |
| `amount0`   | uint256 | The amount of token0                                    |
| `amount1`   | uint256 | The amount of token1                                    |

### tokenURI

```solidity
  function tokenURI(
    uint256 tokenId
  ) public view returns (string)
```



Returns a URI describing a particular token ID

#### Parameters:

| Name      | Type    | Description                                             |
| :-------- | :------ | :------------------------------------------------------ |
| `tokenId` | uint256 | The ID of the token that represents the minted position |

#### Return Values:

A base64 string with the URI data.

### baseURI

```solidity
  function baseURI(
  ) public returns (string)
```



### increaseLiquidity

```solidity
  function increaseLiquidity(
    struct INonfungiblePositionManager.IncreaseLiquidityParams params
  ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1)
```



Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`

#### Parameters:

| Name     | Type                                                       | Description                                                  |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.IncreaseLiquidityParams | tokenId The ID of the token for which liquidity is being increased, |

#### Return Values:

| Name        | Type    | Description                                          |
| :---------- | :------ | :--------------------------------------------------- |
| `liquidity` | uint128 | The new liquidity amount as a result of the increase |
| `amount0`   | uint256 | The amount of token0 to achieve resulting liquidity  |
| `amount1`   | uint256 | The amount of token1 to achieve resulting liquidity  |

### decreaseLiquidity

```solidity
  function decreaseLiquidity(
    struct INonfungiblePositionManager.DecreaseLiquidityParams params
  ) external returns (uint256 amount0, uint256 amount1)
```



Decreases the amount of liquidity in a position and accounts it to the position

#### Parameters:

| Name     | Type                                                       | Description                                                  |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.DecreaseLiquidityParams | tokenId The ID of the token for which liquidity is being decreased, |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 accounted to the position's tokens owed |
| `amount1` | uint256 | The amount of token1 accounted to the position's tokens owed |

### collect

```solidity
  function collect(
    struct INonfungiblePositionManager.CollectParams params
  ) external returns (uint256 amount0, uint256 amount1)
```



Collects up to a maximum amount of fees owed to a specific position to the recipient

#### Parameters:

| Name     | Type                                             | Description                                                  |
| :------- | :----------------------------------------------- | :----------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.CollectParams | tokenId The ID of the NFT for which tokens are being collected, |

recipient The account that should receive the tokens, amount0Max The maximum amount of token0 to collect, amount1Max The maximum amount of token1 to collect

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of fees collected in token0 |
| `amount1` | uint256 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    uint256 tokenId
  ) external
```



Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first.

#### Parameters:

| Name      | Type    | Description                              |
| :-------- | :------ | :--------------------------------------- |
| `tokenId` | uint256 | The ID of the token that is being burned |

### _getAndIncrementNonce

```solidity
  function _getAndIncrementNonce(
  ) internal returns (uint256)
```



### getApproved

```solidity
  function getApproved(
  ) public view returns (address)
```



Returns the account approved for `tokenId` token. Requirements:

- `tokenId` must exist.

### _approve

```solidity
  function _approve(
  ) internal
```



Overrides _approve to use the operator in the position, which is packed with the position permit nonce



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeriphery[NonfungibleTokenPositionDescriptor](https://docs.uniswap.org/contracts/v3/reference/periphery/NonfungibleTokenPositionDescriptor)

# NonfungibleTokenPositionDescriptor

Produces a string containing the data URI for a JSON metadata string

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### tokenURI

```solidity
  function tokenURI(
    contract INonfungiblePositionManager positionManager,
    uint256 tokenId
  ) external returns (string)
```



Produces the URI describing a particular token ID for a position manager

Note this URI may be a data: URI with the JSON contents directly inlined

#### Parameters:

| Name              | Type                                 | Description                                                  |
| :---------------- | :----------------------------------- | :----------------------------------------------------------- |
| `positionManager` | contract INonfungiblePositionManager | The position manager for which to describe the token         |
| `tokenId`         | uint256                              | The ID of the token for which to produce a description, which may not be valid |

#### Return Values:

| Name  | Type                                 | Description                          |
| :---- | :----------------------------------- | :----------------------------------- |
| `The` | contract INonfungiblePositionManager | URI of the ERC721-compliant metadata |

### flipRatio

```solidity
  function flipRatio(
  ) public returns (bool)
```



### tokenRatioPriority

```solidity
  function tokenRatioPriority(
  ) public returns (int256)
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeriphery[SwapRouter](https://docs.uniswap.org/contracts/v3/reference/periphery/SwapRouter)

# SwapRouter

Router for stateless execution of swaps against Uniswap V3

> Input parameters are viewable on the [**Swap Router Interface**](https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/ISwapRouter)

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```



Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                  |
| :------------- | :----- | :----------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
| `amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
| `data`         | bytes  | Any data passed through by the caller via the IUniswapV3PoolActions#swap call |

### exactInputSingle

```solidity
  function exactInputSingle(
    struct ISwapRouter.ExactInputSingleParams params
  ) external returns (uint256 amountOut)
```



Swaps `amountIn` of one token for as much as possible of another token

#### Parameters:

| Name     | Type                                      | Description                                                  |
| :------- | :---------------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputSingleParams | The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `amountOut` | uint256 | The amount of the received token |

### exactInput

```solidity
  function exactInput(
    struct ISwapRouter.ExactInputParams params
  ) external returns (uint256 amountOut)
```



Swaps `amountIn` of one token for as much as possible of another along the specified path

#### Parameters:

| Name     | Type                                | Description                                                  |
| :------- | :---------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputParams | The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `amountOut` | uint256 | The amount of the received token |

### exactOutputSingle

```solidity
  function exactOutputSingle(
    struct ISwapRouter.ExactOutputSingleParams params
  ) external returns (uint256 amountIn)
```



Swaps as little as possible of one token for `amountOut` of another token

#### Parameters:

| Name     | Type                                       | Description                                                  |
| :------- | :----------------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputSingleParams | The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata |

#### Return Values:

| Name       | Type    | Description                   |
| :--------- | :------ | :---------------------------- |
| `amountIn` | uint256 | The amount of the input token |

### exactOutput

```solidity
  function exactOutput(
    struct ISwapRouter.ExactOutputParams params
  ) external returns (uint256 amountIn)
```



Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)

#### Parameters:

| Name     | Type                                 | Description                                                  |
| :------- | :----------------------------------- | :----------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputParams | The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata |

#### Return Values:

| Name       | Type    | Description                   |
| :--------- | :------ | :---------------------------- |
| `amountIn` | uint256 | The amount of the input token |



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical ReferencePeriphery[V3Migrator](https://docs.uniswap.org/contracts/v3/reference/periphery/V3Migrator)

# V3Migrator

## Functions

### constructor

```solidity
  function constructor(
  ) public
```



### receive

```solidity
  function receive(
  ) external
```



### migrate

```solidity
  function migrate(
  ) external
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)

# Deployment Addresses

## Uniswap v3 Contract Deployments

The Uniswap Protocol is made up of multiple contracts on many networks.

Please do not assume contracts are deployed to the same addresses across chains, and be extremely careful to confirm addresses before using a contract.

- [`Ethereum`](https://docs.uniswap.org/contracts/v3/reference/deployments/ethereum-deployments)
- [`Unichain`](https://docs.uniswap.org/contracts/v3/reference/deployments/unichain-deployments)
- [`Arbitrum`](https://docs.uniswap.org/contracts/v3/reference/deployments/arbitrum-deployments)
- [`Optimism`](https://docs.uniswap.org/contracts/v3/reference/deployments/optimism-deployments)
- [`Polygon`](https://docs.uniswap.org/contracts/v3/reference/deployments/polygon-deployments)
- [`Base`](https://docs.uniswap.org/contracts/v3/reference/deployments/base-deployments)
- [`BNB`](https://docs.uniswap.org/contracts/v3/reference/deployments/bnb-deployments)
- [`Avalanche C-Chain`](https://docs.uniswap.org/contracts/v3/reference/deployments/avax-deployments)
- [`CELO`](https://docs.uniswap.org/contracts/v3/reference/deployments/celo-deployments)
- [`Blast`](https://docs.uniswap.org/contracts/v3/reference/deployments/blast-deployments)
- [`ZKsync`](https://docs.uniswap.org/contracts/v3/reference/deployments/ZKsync-deployments)
- [`Zora`](https://docs.uniswap.org/contracts/v3/reference/deployments/Zora-deployments)
- [`WorldChain`](https://docs.uniswap.org/contracts/v3/reference/deployments/WorldChain-deployments)

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[AVAX Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/avax-deployments)

# AVAX Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | AVAX Avalanche C-Chain Addresses             |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD` |
| [Multicall](https://snowtrace.io/address/0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2/contract/43114/code) | `0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0x9AdA7D7879214073F40183F3410F2b3f088c6381` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x27Dd7eE7fE723e83Bf3612a75a034951fe299E99` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0xe89B7C295d73FCCe88eF263F86e7310925DaEBAF` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xE1f93a7cB6fFa2dB4F9d5A2FD43158A428993C09` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0x655C406EBFa14EE2006250925e54ec43AD184f8B` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x94b75331ae8d42c1b61065089b7d48fe14aa73b7` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xCA9D0668C600c4dd07ca54Be1615FE5CDFd76Ac3` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| AVAX    | `43114` | WAVAX                | `0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Arbitrum Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/arbitrum-deployments)

# Arbitrum Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Arbitrum Addresses                           | Arbitrum Sepolia Addresses                   |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e` |
| [Multicall](https://arbiscan.io/address/0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB#code) | `0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB` | `0x2B718b475e385eD29F56775a66aAB1F5cC6B2A0A` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | ``                                           |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | `0x0fd18587734e5C2dcE2dccDcC7DD1EC89ba557d9` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol) | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | ``                                           |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | ``                                           |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | ``                                           |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0x6b2937Bde17889EDCf8fbD8dE31C3C2a70Bc4d65` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0xA5644E29708357803b5A882D272c41cC0dF92B34` | `0x398f43ef2c67B941147157DA1c5a868E906E043D` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0x2779a0CC1c3e0E44D2542EC3e79e3864Ae93Ef0B` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x101F443B4d1b059569D643917553c771E1b9663E` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0xa51afafe0263b40edaef0df8781ea9aa03e381a3` | `0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | ``                                           |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network          | ChainId  | Wrapped Native Token | Address                                      |
| ---------------- | -------- | -------------------- | -------------------------------------------- |
| Arbitrum         | `42161`  | WETH                 | `0x82aF49447D8a07e3bd95BD0d56f35241523fBab1` |
| Arbitrum Sepolia | `421614` | WETH                 | `0x980B62Da83eFf3D4576C647993b0c1D7faf17c73` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[BNB Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/bnb-deployments)

# BNB Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | BNB Address                                  |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7` |
| [Multicall](https://bscscan.com/address/0x963Df249eD09c358A4819E39d9Cd5736c3087184#code) | `0x963Df249eD09c358A4819E39d9Cd5736c3087184` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xC9A7f5b73E853664044ab31936D0E6583d8b1c79` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xD9270014D396281579760619CCf4c3af0501A47C` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x831d93E55AF23A2977E4DA892d5005f4F2995071` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x0281E98322e4e8E53491D576Ee6A2BFCE644C55C` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xAec98e489AE35F243eB63452f6ad233A6c97eE97` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x32681814957e0C13117ddc0c2aba232b5c9e760f` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x78D78E420Da98ad378D7799bE8f4AF69033EB077` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x1906c1d672b88cd1b9ac7593301ca990f94eae07` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0x49B53C35AF9072fC71767577BF6380a88EE32C71` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId | Wrapped Native Token | Address                                      |
| ------------------- | ------- | -------------------- | -------------------------------------------- |
| Binance Smart Chain | `56`    | WBNB                 | `0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Base Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/base-deployments)

# Base Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Base Address                                 | Base Sepolia Address                         |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x33128a8fC17869897dcE68Ed026d694621f6FDfD` | `0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24` |
| [Multicall](https://basescan.org/address/0x091e99cb1c49331a94dd62755d168e941abd0693#code) | `0x091e99cb1C49331a94dD62755D168E941AbD0693` | `0xd867e273eAbD6c853fCd0Ca0bFB6a3aE6491d2C1` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0x3334d83e224aF5ef9C2E7DDA7c7C98Efd9621fA9` | `0xD7303474Baca835743B54D73799688990f24a79D` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d` | `0xedf6066a2b290C185783862C7F4776A2C8077AD1` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0xF9d1077fd35670d4ACbD27af82652a8d84577d9F` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x4f225937EDc33EFD6109c4ceF7b560B2D6401009` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x4615C383F85D0a2BbED973d83ccecf5CB7121463` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1` | `0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7` | `0xCbf8b7f80800bd4888Fbc7bf1713B80FE4E23E10` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a` | `0xC5290058841028F1614F3A6F0F5816cAd0df5E27` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x2626664c2603336E57B271c5C0b26F421741e481` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x6fF5693b99212Da76ad316178A184AB56D299b43` | `0x492E6456D9528771018DeB9E87ef7750EF184104` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0x42bE4D6527829FeFA1493e1fb9F3676d2425C3C1` | ``                                           |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network      | ChainId | Wrapped Native Token | Address                                      |
| ------------ | ------- | -------------------- | -------------------------------------------- |
| Base         | `8453`  | WETH                 | `0x4200000000000000000000000000000000000006` |
| Base Sepolia | `84532` | WETH                 | `0x4200000000000000000000000000000000000006` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Blast Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/blast-deployments)

# Blast Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Blast addresses                              |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd` |
| [Multicall](https://blastscan.io/address/0xdc7f370de7631ce9e2c2e1dcda6b3b5744cf4705#code) | `0xdC7f370de7631cE9e2c2e1DCDA6B3B5744Cf4705` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0x7C9cAa4ac84C8FAD8Bd504DBF90e791F91f41705` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0x2E95185bCdD928a3e984B7e2D6560Ab1b17d7274` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0xAa32bD3926097fd04d22b4433e9867417EE79333` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x497089D9450BB58f536c38c1C0d0A37472303508` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xB22Ef02E13B1900EBF10391e57162402c11BfF05` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xB218e4f7cF0533d4696fDfC419A0023D33345F28` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x15CA7043CD84C5D21Ae76Ba0A1A967d42c40ecE0` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x6Cdcd65e03c1CEc3730AeeCd45bc140D57A25C77` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x549FEB8c9bd4c12Ad2AB27022dA12492aC452B66` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022d473030f116ddee9f6b43ac78ba3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0xeabbcb3e8e415306207ef514f660a3f820025be3` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xEcAF7c276f746170642e97De961f2f0361e1aCc8` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| Blast   | `81457` | WETH                 | `0x4300000000000000000000000000000000000004` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[CELO Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/celo-deployments)

# CELO Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | CELO Address                                 | Alfajores Address                            |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0xAfE208a311B21f13EF87E33A90049fC17A7acDEc` | `0x229Fd76DA9062C1a10eb4193768E192bdEA99572` |
| [Multicall2](https://celoscan.io/address/0x633987602de5c4f337e3dbf265303a1080324204#code) | `0x633987602DE5C4F337e3DbF265303A1080324204` | `0x692A12C7C167c44e54c3d381CA3EE91F058Dc404` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xc1b262Dd7643D4B7cA9e51631bBd900a564BF49A` | `0xE4d1eBb97Fe5fabFaBbB8C004C424EE12dE8A07d` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D` | `0xFdACaEfB0f85C9BE9d319023453cC85C812d7e1E` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0xa9Fd765d85938D278cb0b108DbE4BF7186831186` | `0xE3da4F834D45b27AF95600e6546991dC3B50adAC` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x644023b316bB65175C347DE903B60a756F6dd554` | `0xB00B8C3aB078EB0f7DeC6cE19c1a1da5bf4f8d7e` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x505B43c452AA4443e0a6B84bb37771494633Fde9` | `0x9ddD6325FBE93A715B422883cED853CD843f217C` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A` | `0x0eC9d3C06Bc0A472A80085244d897bb604548824` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x3cFd4d48EDfDCC53D3f173F596f621064614C582` | `0x245d3F47F55c532dbE9340368855Be631B162cfd` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8` | `0x3c1FCF8D6f3A579E98F4AE75EB0adA6de70f5673` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x5615CDAb10dc425a742d643d949a7F474C01abc4` | `0x8C456F41A3883bA0ba99f810F7A2Da54D9Ea3EF0` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x643770E279d5D0733F21d6DC03A8efbABf3255B4` | `0x84904B9E85F76a421223565be7b596d7d9A8b8Ce` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0x6586FB35393abF7Ff454977a9b3c912d218791C6` | `0x8AC47D3e65a3e6aD14596ee7d18ad1d1aA53208F` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## CELO Native Asset

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

**Note: CELO is the native asset, it is a token and will work as a token, needing approval for routers to manage.*

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| CELO    | `42220` | CELO Native Asset    | `0x471EcE3750Da237f93B8E339c536989b8978a438` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Ethereum Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/ethereum-deployments)

# Ethereum Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Mainnet                                      | Ethereum Sepolia Addresses                   |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x0227628f3F023bb0B980b67D528571c95c6DaC1c` |
| [Multicall](https://etherscan.io/address/0x1F98415757620B543A52E61c46B32eB19261F984#code) | `0x1F98415757620B543A52E61c46B32eB19261F984` | ``                                           |
| [Multicall2](https://etherscan.io/address/0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696#code) | `0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696` | `0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | `0x0b343475d44EC2b4b8243EBF81dc888BF0A14b36` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | ``                                           |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol) | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | `0x3B5E3c5E595D85fbFBC2a42ECC091e183E76697C` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | `0x5bE4DAa6982C69aD20A57F1e68cBcA3D37de6207` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | ``                                           |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0x1238536071E1c677A632429e3655c799b22cDA52` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0xA5644E29708357803b5A882D272c41cC0dF92B34` | `0x729004182cF005CEC8Bd85df140094b6aCbe8b15` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x66a9893cc07d91d95644aedd05d03f95e1dba8af` | `0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | ``                                           |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network  | ChainId    | Wrapped Native Token | Address                                      |
| -------- | ---------- | -------------------- | -------------------------------------------- |
| Ethereum | `1`        | WETH                 | `0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2` |
| Sepolia  | `11155111` | WETH                 | `0xfff9976782d46cc05630d1f6ebab18b2324d6b14` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Optimism Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/optimism-deployments)

# Optimism Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Optimism Addresses                           | OP Sepolia Addresses SDK-Core                | OP Sepolia Addresses                         |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF` | `0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24` |
| [Multicall](https://optimistic.etherscan.io/address/0x1F98415757620B543A52E61c46B32eB19261F984#code) | `0x1F98415757620B543A52E61c46B32eB19261F984` | `0x80e4e06841bb76AA9735E0448cB8d003C0EF009a` | `0xd867e273eAbD6c853fCd0Ca0bFB6a3aE6491d2C1` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | `0xD7303474Baca835743B54D73799688990f24a79D` | `0xD7303474Baca835743B54D73799688990f24a79D` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | `0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5` | `0xedf6066a2b290C185783862C7F4776A2C8077AD1` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol) | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d` | `0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | ``                                           | `0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07` | `0xCbf8b7f80800bd4888Fbc7bf1713B80FE4E23E10` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0x0FBEa6cf957d95ee9313490050F6A0DA68039404` | `0xC5290058841028F1614F3A6F0F5816cAd0df5E27` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x851116d9223fabed8e56c0e6b8ad0c31d98b3507` | `0xD5bBa708b39537d33F2812E5Ea032622456F1A95` | `0xD5bBa708b39537d33F2812E5Ea032622456F1A95` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | `0x78eF13931e5625C828ef8Ec455ba7fa09fDa9808` | ``                                           |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network          | ChainId    | Wrapped Native Token | Address                                      |
| ---------------- | ---------- | -------------------- | -------------------------------------------- |
| Optimism         | `10`       | WETH                 | `0x4200000000000000000000000000000000000006` |
| Optimism Sepolia | `11155420` | WETH                 | `0x4200000000000000000000000000000000000006` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Polygon Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/polygon-deployments)

# Polygon Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Polygon Addresses                            |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x1F98431c8aD98523631AE4a59f267346ea31F984` |
| [Multicall](https://polygonscan.com/address/0x1F98415757620B543A52E61c46B32eB19261F984#code) | `0x1F98415757620B543A52E61c46B32eB19261F984` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol) | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) | `0xE592427A0AEce92De3Edee1F18E0157C05861564` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x42B24A95702b9986e82d421cC3568932790A48Ec` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x91ae842A5Ffd8d12023116943e72A606179294f3` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0xA5644E29708357803b5A882D272c41cC0dF92B34` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x1095692A6237d83C6a72F3F5eFEdb9A670C49223` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` |

> **Note**: Polygon Mumbai testnet was deprecated in April 2024. For testing, developers should use Polygon Amoy testnet. Deployment addresses for Amoy are not yet available.

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| Polygon | `137`   | WMATIC               | `0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Unichain Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/unichain-deployments)

# Unichain Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Unichain Addresses                                           | Unichain Sepolia Addresses                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | [`0x1f98400000000000000000000000000000000003`](https://uniscan.xyz/address/0x1f98400000000000000000000000000000000003) | [`0x1F98431c8aD98523631AE4a59f267346ea31F984`](https://sepolia.uniscan.xyz/address/0x1F98431c8aD98523631AE4a59f267346ea31F984) |
| [UniswapInterfaceMulticall](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/UniswapInterfaceMulticall.sol) | [`0xb7610f9b733e7d45184be3a1bc966960ccc54f0b`](https://uniscan.xyz/address/0xb7610f9b733e7d45184be3a1bc966960ccc54f0b) | [`0x9D0F15f2cf58655fDDcD1EE6129C547fDaeD01b1`](https://sepolia.uniscan.xyz/address/0x9D0F15f2cf58655fDDcD1EE6129C547fDaeD01b1) |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | [`0xd5d76fa166ab8d8ad4c9f61aaa81457b66cbe443`](https://uniscan.xyz/address/0xd5d76fa166ab8d8ad4c9f61aaa81457b66cbe443) | [`0x5f739c790a48E97eec0efb81bab5D152c0A0ecA0`](https://sepolia.uniscan.xyz/address/0x5f739c790a48E97eec0efb81bab5D152c0A0ecA0) |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | [`0x385a5cf5f83e99f7bb2852b6a19c3538b9fa7658`](https://uniscan.xyz/address/0x385a5cf5f83e99f7bb2852b6a19c3538b9fa7658) | [`0x6Dd37329A1A225a6Fca658265D460423DCafBF89`](https://sepolia.uniscan.xyz/address/0x6Dd37329A1A225a6Fca658265D460423DCafBF89) |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | [`0x73855d06de49d0fe4a9c42636ba96c62da12ff9c`](https://uniscan.xyz/address/0x73855d06de49d0fe4a9c42636ba96c62da12ff9c) | [`0xd1AAE39293221B77B0C71fBD6dCb7Ea29Bb5B166`](https://sepolia.uniscan.xyz/address/0xd1AAE39293221B77B0C71fBD6dCb7Ea29Bb5B166) |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | [`0x943e6e07a7e8e791dafc44083e54041d743c46e9`](https://uniscan.xyz/address/0x943e6e07a7e8e791dafc44083e54041d743c46e9) | [`0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075`](https://sepolia.uniscan.xyz/address/0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075) |
| [NFT Descriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | [`0x0dfa04b28ab68ffd0e6e17fac6ec16d4846a2004`](https://uniscan.xyz/address/0x0dfa04b28ab68ffd0e6e17fac6ec16d4846a2004) | [`0x2B6221E68D48cDC10CF2e52D913f9380D62555BA`](https://sepolia.uniscan.xyz/address/0x2B6221E68D48cDC10CF2e52D913f9380D62555BA) |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | [`0xb9d0c246f306b1aaf02ae6ba112d5ef25e5b60dc`](https://uniscan.xyz/address/0xb9d0c246f306b1aaf02ae6ba112d5ef25e5b60dc) | [`0xb5FA244C9d6D04B2FBac84418b3c4910ED1Ae5f2`](https://sepolia.uniscan.xyz/address/0xb5FA244C9d6D04B2FBac84418b3c4910ED1Ae5f2) |
| [UniswapV3Staker](https://github.com/Uniswap/v3-staker)      | -                                                            | [`0xd693d8df6CF768248c16f98745Ee0c8E06460487`](https://sepolia.uniscan.xyz/address/0xd693d8df6CF768248c16f98745Ee0c8E06460487) |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/reference/core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH, the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract.

| Network          | ChainId | Wrapped Native Token | Address                                                      |
| ---------------- | ------- | -------------------- | ------------------------------------------------------------ |
| Unichain         | `130`   | WETH                 | [`0x4200000000000000000000000000000000000006`](https://unichain.blockscout.com/token/0x4200000000000000000000000000000000000006) |
| Unichain Sepolia | `1301`  | WETH                 | [`0x4200000000000000000000000000000000000006`](https://unichain-sepolia.blockscout.com/token/0x4200000000000000000000000000000000000006) |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[WorldChain Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/WorldChain-deployments)

# WorldChain Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | WorldChain                                   |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x7a5028BDa40e7B173C278C5342087826455ea25a` |
| [Multicall2](https://worldchain-mainnet.explorer.alchemy.com/address/0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9) | `0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0x8B52DaCB7B5d9A959CDcD5419061c0eDD1296c29` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0xE61df0CaC9d85876aCE5E3037005D80943570623` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0x38c68A1D60C47973EcE5bc1725B65D8Bec438192` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0x70410a302c4a5c52C659b780941c947Abd437FeB` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xe6FcB4952b2d3Fab6DA4BC165831f5575e093feC` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xec12a9F9a09f50550686363766Cc153D03c27b5e` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x9EBDdCBa71C9027E1eB45135672a30bcFEec9de3` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x10158D43e6cc414deE1Bd1eB0EfC6a5cBCfF244c` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/reference/core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network    | ChainId | Wrapped Native Token | Address                                      |
| ---------- | ------- | -------------------- | -------------------------------------------- |
| WorldChain | `480`   | WETH                 | `0x4200000000000000000000000000000000000006` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[ZKsync Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/ZKsync-deployments)

# ZKsync Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | ZKsync Mainnet                               |
| ------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/uniswap-zksync/era-uniswap-v3-core/blob/v1.0.0-zksync-era/contracts/UniswapV3Factory.sol) | `0x8FdA5a7a8dCA67BBcDd10F02Fa0649A937215422` |
| [Multicall2](https://explorer.zksync.io/address/0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C#contract) | `0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C` |
| [ProxyAdmin](https://github.com/uniswap-zksync/era-openzeppelin-contracts/blob/v3.4.1-solc-0.7-2-zksync-era/contracts/proxy/ProxyAdmin.sol) | `0xBb79274aD9C7f68A5B6a7E31F431175BB889b557` |
| [TickLens](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/lens/TickLens.sol) | `0xe10FF11b809f8EE07b056B452c3B2caa7FE24f89` |
| [NFTDescriptor](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.3.0-zksync-era/contracts/libraries/NFTDescriptor.sol) | `0x7d67b8Ff4AbFfc020641F5e430fbeEd03897674d` |
| [NonfungibleTokenPositionDescriptor](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.3.0-zksync-era/contracts/NonfungibleTokenPositionDescriptor.sol) | `0xa819De78cAB1163F8605809392068EdE3BFcDd1E` |
| [TransparentUpgradeableProxy](https://github.com/uniswap-zksync/era-openzeppelin-contracts/blob/v3.4.1-solc-0.7-2-zksync-era/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xAeaBf2d69698C6810D2596fAE86099790A13Ee81` |
| [NonfungiblePositionManager](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/NonfungiblePositionManager.sol) | `0x0616e5762c1E7Dc3723c50663dF10a162D690a86` |
| [V3Migrator](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/V3Migrator.sol) | `0x611841b24E43C4ACfd290B427a3D6cf1A59dac8E` |
| [QuoterV2](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts/blob/v1.1.0-zksync-era/contracts/lens/QuoterV2.sol) | `0x8Cb537fc92E26d8EBBb760E632c95484b6Ea3e28` |
| [SwapRouter02](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts/blob/v1.1.0-zksync-era/contracts/SwapRouter02.sol) | `0x99c56385daBCE3E81d8499d0b8d0257aBC07E8A3` |
| [Permit2](https://github.com/uniswap-zksync/era-permit2/blob/0x000000000022D473030F116dDEE9F6B43aC78BA3-zksync-era/src/Permit2.sol) | `0x0000000000225e31d15943971f47ad3022f714fa` |
| [UniversalRouter](https://github.com/uniswap-zksync/era-universal-router/tree/v1.2.2-zksync-era) | `0x28731BCC616B5f51dD52CF2e4dF0E78dD1136C06` |
| [v3StakerAddress](https://github.com/uniswap-zksync/era-uniswap-v3-staker/blob/v1.0.2-zksync-era/contracts/UniswapV3Staker.sol) | `0xf84268FA8EB857c2e4298720C1C617178F5e78e1` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core`](https://github.com/uniswap-zksync/era-uniswap-v3-core/tree/v1.0.0-zksync-era)
- [`@uniswap/v3-periphery`](https://github.com/uniswap-zksync/era-uniswap-v3-periphery)
- [`@uniswap/swap-router-contracts`](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts)

*Note:* ZKsync contracts are also using the [`ZKsync fork of OpenZeppelin`](https://github.com/uniswap-zksync/era-openzeppelin-contracts#v3.4.1-solc-0.7-2-zksync-era).

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://app.uniswap.org/explore) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| ZKsync  | `324`   | WETH                 | `0x5aea5775959fbc2557cc8789bc1bf90a239d9a91` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/)[Zora Deployments](https://docs.uniswap.org/contracts/v3/reference/deployments/Zora-deployments)

# Zora Deployments

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                     | Zora                                         | Zora Sepolia                                 |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol) | `0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb` | `0x4324A677D74764f46f33ED447964252441aA8Db6` |
| [Multicall2](https://explorer.zora.energy/address/0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15) | `0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15` | `0xA1E7e3A69671C4494EC59Dbd442de930a93F911A` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol) | `0xd4109824FC80dD41ca6ee8D304ec74B8bEdEd03b` | `0x561896C035abFB3C72f754f10fD35f6c450Ffe16` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol) | `0x209AAda09D74Ad3B8D0E92910Eaf85D2357e3044` | `0x23C0F71877a1Fc4e20A78018f9831365c85f3064` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol) | `0xffF2BffC03474F361B7f92cCfF2fD01CFBBDCdd1` | `0xf70C8a20496a5201Fd8D01F627c93aE39cDa1999` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol) | `0xf15D9e794d39A3b4Ea9EfC2376b2Cd9562996422` | `0x5BC936a151Fb4CEBD14467Ca9CBf598b7E645fc0` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x843b0b03c3B3B0434B9cb00AD9cD1D9218E7741b` | `0x68EF3669bEd58213edf9Da598f4E1307680839B2` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol) | `0xbC91e8DfA3fF18De43853372A3d7dfe585137D78` | `0xB8458EaAe43292e3c1F7994EFd016bd653d23c20` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol) | `0x048352d8dCF13686982C799da63fA6426a9D0b60` | `0x65ef259b31bf1d977c37e9434658694267674897` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol) | `0x11867e1b3348F3ce4FcC170BC5af3d23E07E64Df` | `0xC195976fEF0985886E37036E2DF62bF371E12Df0` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol) | `0x7De04c96BE5159c3b5CeffC82aa176dc81281557` | `0x6B36d761981d82B1e07cF3c4daF4cB4615c4850a` |
| [Permit2](https://github.com/Uniswap/permit2)                | `0x000000000022d473030f116ddee9f6b43ac78ba3` | `0x000000000022d473030f116ddee9f6b43ac78ba3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router) | `0x3315ef7ca28db74abadc6c44570efdf06b04b020` | ``                                           |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)      | `0x5eF5A6923d2f566F65f363b78EF7A88ab1E4206f` | `0x5d298AAf21058d14436DBD36940dcB5542b8aFE8` |

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/IUniswapV3Factory#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```



## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network      | ChainId     | Wrapped Native Token | Address                                      |
| ------------ | ----------- | -------------------- | -------------------------------------------- |
| Zora         | `7777777`   | WETH                 | `0x4200000000000000000000000000000000000006` |
| Zora Sepolia | `999999999` | WETH                 | `0x4200000000000000000000000000000000000006` |

[Contracts](https://docs.uniswap.org/contracts/v4/overview)v3 ProtocolTechnical Reference[Error Codes](https://docs.uniswap.org/contracts/v3/reference/error-codes)

# Error Codes

LiquidityMath.sol

- `LS`: Liquidity Sub
- `LA`: Liquidity Add

Oracle.sol

- `OLD`: The target must be chronologically after the oldest observation
- `I`: The pool has not been initialized

Position.sol

- `NP`: Burn cannot be called for a position with 0 liquidity

Tick.sol

- `LO`: LiquidityGrossAfter must be less than MaxLiquidity

TickMath.sol

- `T`: The given tick must be less than, or equal to, the maximum tick
- `R`: second inequality must be < because the price can never reach the price at the max tick

TransferHelper.sol

- `TF`: Transfer Failed : errors with TF if transfer fails

UniswapV3Pool.sol

- `LOK`: The reentrancy guard. A transaction cannot re-enter the pool mid-swap
- `TLU`: The lower tick must be below the upper tick
- `TLM`: The lower tick must be greater, or equal to, the minimum tick
- `TUM`: The upper tick must be lesser than, or equal to, the maximum tick
- `AI`: The pool is already initialized
- `M0`: Mint 0, The balance of token0 in the given pool before minting must be less than, or equal to, the balance after minting
- `M1`: Mint 1, The balance of token1 in the given pool before minting must be less than, or equal to, the balance after minting
- `AS`: `amountSpecified` cannot be zero
- `SPL`: Square root price limit
- `IIA`: Insufficient input amount, an insufficient amount of input token was sent during the callback
- `L`: Liquidity in the pool must be greater than zero for a flash to be executed
- `F0`: The balance of token0 in the given pool before the flash transaction must be less than, or equal to, the balance of token0 after the flash plus the fee
- `F1`: The balance of token1 in the given pool before the flash transaction must be less than, or equal to, the balance of token1 after the flash plus the fee



[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart Wallet[Overview](https://docs.uniswap.org/contracts/smart-wallet/overview)

# Overview

Uniswap smart wallet features are powered by the Calibur contract which is meant to be used alongside [EIP-7702.](https://eips.ethereum.org/EIPS/eip-7702)

Calibur is a singular contract which has been deployed to the same address across all supported networks. For more details, see the [Deployments](https://docs.uniswap.org/contracts/smart-wallet/deployments) page below. It is non upgradeable and has no owner.

Curious about the name?

> Introducing Calibur, a derivation of *Excalibur* and a nod to the mythical sword's reputation as a symbol of rightful authority and exceptional power.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart Wallet[Deployments](https://docs.uniswap.org/contracts/smart-wallet/deployments)

# Deployments

## Deployment Addresses

| Network          | Address                                    | Commit Hash                              | Version |
| ---------------- | ------------------------------------------ | ---------------------------------------- | ------- |
| Mainnet          | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| Unichain         | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| Base             | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| Optimism         | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| BNB              | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| Unichain Sepolia | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |
| Sepolia          | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0  |

### Github Repository

https://github.com/Uniswap/calibur

### Audits

https://github.com/Uniswap/calibur/tree/main/audits

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletConcepts[Delegation](https://docs.uniswap.org/contracts/smart-wallet/concepts/delegation)

# Delegation

This contract is meant to be used with [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702): Set Code for EOAs. After the Ethereum Pectra fork, Externally Owned Accounts (EOAs) can now internalize code at a remotely deployed smart contract address. This process is called **delegation.**

For simplicity, we will refer to these EOAs as *users* and these remote smart contracts as *implementations.* The term *Smart Wallet* will refer to the Uniswap smart wallet product.

Users can only be delegated to one contract at a time but can have other delegations on different chains.

After a user is delegated, they can execute transactions using the logic defined in the contract implementation, enabling advanced features like transaction batching, gas-less transactions, and custom permission controls - all while keeping their original address and on-chain history.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletConcepts[Batched Transactions](https://docs.uniswap.org/contracts/smart-wallet/concepts/batched-transactions)

# Batched Transactions

Batched transactions are transactions which include one or more actions. For example, approving an ERC20 token and a swap using that token. Our smart wallet natively supports batched transactions, saving users gas and clicks.

Our smart wallet supports simple batched calls as well as [ERC-7821](https://eips.ethereum.org/EIPS/eip-7821): **Minimal Batch Executor Interface**, a standard which increases interoperability between dapps and contract implementations.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletConcepts[Gas Abstraction](https://docs.uniswap.org/contracts/smart-wallet/concepts/gas-abstraction)

# Gas Abstraction

Gas abstraction allows users to transact without needing to have a balance of ETH to pay for gas fees. Instead, a third party called a [bundler](https://www.alchemy.com/overviews/what-is-a-bundler) can cover or manage those fees on their behalf.

Our smart wallet implements [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337): **Account Abstraction Using Alt Mempool**, a widely adopted standard within the industry.

By default, EntryPoint v0.8 (0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108) is enabled on the account. This can be disabled or changed by the root signer - please exercise caution as this can lead to a loss of funds.

You can view details about the deployment of the EntryPoint contract [here](https://github.com/eth-infinitism/account-abstraction/releases). It is considered a public good deployed by the community.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletAdvanced Usage[Alternative Signers](https://docs.uniswap.org/contracts/smart-wallet/advanced-usage/alternative-signers)

# Alternative Signers

Calibur allows for a user to add any number of signers to their account. Known as `keys`, the following types are supported: `Secp256k1`, `Secp256r1 (P256)`, and `WebAuthn P256`.

This is an **advanced** feature. Please be aware of the following:

- By default, added keys do not expire and have no hooks.
- A malicious key could steal all of your ETH and tokens

Registering external signers on your account changes the security model. Proceed with caution!

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletAdvanced Usage[Hooks](https://docs.uniswap.org/contracts/smart-wallet/advanced-usage/hooks)

# Hooks

Hooks are powerful add-ons to keys which can perform arbitrary validation on signatures, and/or actions during execution time.

There are two subtypes of hooks: `ValidationHook` and `ExecutionHook`. A hook can implement either, or both interfaces.

Validation hooks have three call sites:

- `afterVerifySignature`
- `afterIsValidSignature`
- `afterValidateUserOp`

Execution hooks have two call sites:

- `beforeExecute`
- `afterExecute`

Hooks must revert to indicate that the given action should revert.

Example functionality which can be implemented in hooks includes:

- Spending limits
- Restricting keys from calling certain contracts and methods
- Turning a key into a multisig, effectively requiring additional signatures for verification
- Automated actions pre/post swaps

There are a few example hooks referenced in the repo. Be aware that these example hooks are not production code and may contain bugs. We do not recommend you to deploy these hooks or use them as reference implementations for productionized code. They are proof of concepts.

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletAdvanced Usage[ERC-7739](https://docs.uniswap.org/contracts/smart-wallet/advanced-usage/erc-7739)

# ERC-7739

ERC-7739 is a standard which defines a defensive rehashing model for external signers on smart contract accounts. This does not apply to signatures from the root EOA (the one delegated to the implementation), but is enforced for all alternative keys which have been added to an account.

The ERC is still in draft [here](https://eips.ethereum.org/EIPS/eip-7739), and has example implementations in [Solady](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol) and [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/signers/ERC7739.sol). We are looking forward to its finalization and welcome any comments / feedback from the community.

Viem has a client-side implementation [here](https://viem.sh/experimental/erc7739/signTypedData)

[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart WalletAdvanced Usage[ERC-7914](https://docs.uniswap.org/contracts/smart-wallet/advanced-usage/erc-7914)

# ERC-7914

ERC-7914 is a standard which adds native Ether “transfer from” functionality to smart contract wallets. It allows for our Smart Wallet to approve other accounts and contracts to spend ETH, which is not possible today with Externally Owned Accounts (EOAs).

We are contributors to the [ERC](https://github.com/ethereum/ERCs/blob/8380220418521ff1995445cff5ca1d0e496a3d2d/ERCS/erc-7914.md) and welcome any feedback from the community on the spec or our implementation.

Calibur’s reference implementation is [here](https://github.com/Uniswap/calibur/blob/main/src/ERC7914.sol).



[Contracts](https://docs.uniswap.org/contracts/v4/overview)Smart Wallet[Technical Reference](https://docs.uniswap.org/contracts/smart-wallet/technical-reference)

# Technical Reference

For more details, see the [technical reference](https://github.com/Uniswap/calibur/tree/main/docs).

### Important Integration Callouts

The Calibur contracts are open sourced and MIT licensed. While anyone is free to build off of them, it is extremely important that integrators protect against certain known integration pitfalls.

- By default, registered keys do not expire and they do not have any hooks attached to them. While they are not admin keys and thus cannot self-call (callback into the Calibur contract), they can still spend any token and ETH balances.
- An admin key added to the account can add other keys with any expiration or admin status
- It is possible to pass along hookData to hooks for extra verification. This data is arbitrary and hook developers MUST verify its uniqueness and integrity.
- The contract does not enforce that the User Verification flag is set in Webauthn signatures
- Signatures from the private key of the EOA are always valid on the Calibur contracts. Those from alternative signers can be invalidated if desired by calling `updateSalt`, which will update the account’s EIP712 domain separator.
- It is completely valid to not execute the ERC7739 rehash code path on a signature originating from the root EOA. This is because this contract makes an assumption that IF the root key is registered on another wallet, that wallet is responsible for rehashing.
- Undelegating and redelegating may leave your account exposed to dirtied storage. Proceed with caution when redelegating to another contract.

For a comprehensive list of best practices, reference the documentation in the Github repository, past audit reports, and inline comments in the contract code.



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDK[Overview](https://docs.uniswap.org/sdk/v3/overview)

# Overview

The Uniswap v3 SDK provides abstractions to assist you with interacting with the Uniswap v3 smart contracts in a Typescript/Javascript environment (e.g. websites, node scripts). It makes uses of the [**Core SDK**](https://docs.uniswap.org/sdk/core/overview) to gain access to abstractions that are common amongst the Uniswap SDKs. With the SDK, you can manipulate data that has been queried from the [EVM](https://ethereum.org/en/developers/docs/evm/) using libraries that assist with needs such as data modeling, protection from rounding errors, and compile time enforced typing.

To begin, we recommend looking at our [**Guides**](https://docs.uniswap.org/sdk/v3/guides/background) which include [runnable examples](https://github.com/Uniswap/examples/tree/main/v3-sdk) and walkthroughs of core usages. These guides will help you better understand how to use the SDK and integrate it into your application.

For complete documentation of the SDK's offerings, see the [**Technical Reference**](https://docs.uniswap.org/sdk/v3/reference/overview).

## Installation

To interact with the v3 SDK we recommend installing though npm:

```bash
npm i --save @uniswap/v3-sdk
npm i --save @uniswap/sdk-core
```



## Developer Links

- [**v3 SDK GitHub Repo**](https://github.com/Uniswap/v3-sdk)
- [**Core SDK GitHub Repo**](https://github.com/Uniswap/sdk-core)
- [**v3 SDK NPM Package**](https://www.npmjs.com/package/@uniswap/v3-sdk)

[![Unit Tests](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/uniswap-v3-sdk/actions?query=workflow%3A"Unit+Tests")[![Lint](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Lint/badge.svg)](https://github.com/Uniswap/uniswap-v3-sdk/actions?query=workflow%3ALint)[![npm version](https://img.shields.io/npm/v/@uniswap/v3-sdk/latest.svg)](https://www.npmjs.com/package/@uniswap/v3-sdk/v/latest)[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/v3-sdk/latest.svg)](https://bundlephobia.com/result?p=@uniswap/v3-sdk@latest)[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)





[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuides[Background](https://docs.uniswap.org/sdk/v3/guides/background)

# Background

Before integrating with Uniswap, it may be helpful for newcomers to review the following background information on some important developer web3 concepts, the structure of our examples, and SDK concepts.

info

Already familiar with web3 development and/or the basics of our SDK and want to get right to the code? Start with our first guide, [Getting a Quote](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting)!

## Providers

Communication with the blockchain is typically done through a provider and local models of smart contracts and their [ABIs](https://docs.uniswap.org/sdk/v3/guides/background#abis).

To achieve this, our examples use the [ethers.js](https://docs.ethers.io/v5/) library. To instantiate a provider you will need a data source. Our examples offer two options:

- **JSON RPC URL**: If you are working directly with the Ethereum mainnet or a local fork, products such as [Infura](https://infura.io/) offer JSON RPC URLs for a wide variety of chains and testnets. For our examples, we'll only be using the Ethereum mainnet.
- **Wallet Extension**: If you are connecting to a wallet browser extension, these wallets embed a source directly into the Javascript window object as `window.ethereum`. This object surfaces information about the user's wallets and provides the ability to communicate with the connected chain. Importantly for our examples, it can be used with `ethers.js` to construct a provider.

## Uniswap's Runnable Examples

Each guide is accompanied and driven by [runnable examples](https://github.com/Uniswap/examples/tree/main/v3-sdk) using React to provide a basic UI for interacting with the example. Each examples provides relevant options such as running against a local blockchain or connecting to the Ethereum mainnet directly. You also have the option of using a wallet extension which can be connected to either environment.

Inputs and environment settings are configured in each example's `config.ts` and allows for simple setup and configuration.

### Developing and Testing

To test your code, we recommend utilizing a local fork of the Ethereum mainnet. To help facilitate easy testing, each example includes a quickstart for running the local chain with a test wallet. To further test, we also recommend using a wallet extension and connecting to the local chain. Finally, each example can be run against the Ethereum mainnet if desired. Full development instructs can be found in the `README.md` of each code example.

### Utility Libraries

Each example is concentrated into a single file within the `libs/` folder of the example, with the entry points noted in each guide and README.

To allow the guides to focus on the SDK's core functionality, additional basic building blocks can be found in each example's `libs` folder. The exported functionality from these files is intended to be the minimum needed for each example and not a complete library for production usage. These also include storing core constants such as definitions for tokens, ABI's, and blockchain addresses that can distract from the core concepts. Below are summaries of the helping libraries you will encounter.

#### Provider Utilities

`provider.ts` wraps the basics of `ethers.js` and connecting to wallet extensions into an abstracted view of a provider, a wallet address, and the ability to send transactions. It also helps abstract the configured environment you wish to run against in your example without making code changes outside of your configuration.

#### Wallet Utilities

`wallet.ts` offers the ability to query a wallet (whether connected via an extension or defined in code/config) for its balances and other essential information.

#### Pool Information

`pool.ts` contains the basic querying of pool information when not essential / core to the relevant guide

#### Display Utilities

```
conversion.ts` provides display and light math wrappers to help show human readable prices when dealing with currency amounts (typically stored as raw numbers and the decimal placement separate for precision reasons) in the form of two functions: `fromReadableAmount` and `toReadableAmount
```

## Notable SDK Structures and Concepts

When working with the SDK it can be helpful to understand some of the design choices and why they are needed. Below you can find a few important concepts.

### ABI's

To allow others to interact with a smart contract, each contract exposes an ABI (Application Binary Interface). As these are defined on the blockchain, we must ensure the correct definitions are provided to our Javascript functions. ABI's are provided from various SDK's and imported in as needed. Some examples will define an ABI directly as needed.

### CurrencyAmount and JSBI

Cryptocurrency applications often work with very small fractions of tokens. As a result, high precision is very important. To ensure precision is upheld, the `CurrencyAmount` class helps store exact values as fractions and utilizes [JSBI](https://github.com/GoogleChromeLabs/jsbi) for compatibility across the web. To display these amounts nicely to users, additional work is sometimes required.

### Currency

The `Currency` class can represent both native currency (ETH) and an ERC20 `Token`. Currencies vary in their relative value, so the `Token` class allows your application to define the number of decimals needed for each currency along with the currency's address, symbol, and name.



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuides[Local Development](https://docs.uniswap.org/sdk/v3/guides/local-development)

# Local Development

## Introduction

Developing your dApps or smart contracts requires some tinkering to get a proper setup that is both a good simulation of how Mainnet will behave, but also customizable enough to suit the needs of a development environment.

One very common approach is to create your own custom chain offline and develop on top of it. The issue with this approach is that if you are integrating with protocols like Uniswap or others that are on Mainnet, it's difficult to simulate on your local chain as the smart contracts from Mainnet are not there.

Another approach is to use a testnet like Ethereum Goerli. While most protocols (including Uniswap) have versions of their smart contracts deployed on common testnets, there are certain behavioural differences. Not all pools that are on Mainnet are on Goerli for example. Also, it's difficult to get enough testnet ETH to account for real testing. And without lots of testnet ETH it's even more difficult to swap to other coins on Uniswap, if that's what you need to do in your development environment.

This guide focuses on yet another approach to local development: Mainnet Forks.

A Mainnet Fork is a local chain that copies the state of Ethereum Mainnet at a given block number. It then gives you access to cheat codes like wallets with thousands of ETH and RPC URLs that you can use as drop-in replacements of real Mainnet RPCs.

This approach combines the best of all other approaches. You have a local chain that you can manipulate to your liking and you have real deployments of all the protocols you need to test and develop your dApp or smart contracts.

info

This guide focuses on Ethereum Mainnet. But you can easily fork any other chain by simply replacing the RPC URL with one of the network you want to use.

For this guide, the following packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`ethers@5`](https://www.npmjs.com/package/ethers)

Please note that we use ethers version 5, as this is still the most commonly used version of ethers.js. If you use version 6, you will need to slightly change the syntax in the examples below.

info

Forking a chain requires archival data and trace calls. Infura and normal geth instances are by default not archival. You can get a free archival RPC that you can use to follow this guide and fork Mainnet you can visit [Chainnodes](https://www.chainnodes.org/).

## Using Foundry and Anvil

There are several developer tools to fork Mainnet. [Anvil](https://github.com/foundry-rs/foundry/tree/master/crates/anvil) by foundry is a newcomer that's fast and easy to setup. This guide focuses on Anvil.

As a first step, follow the [installation guide](https://book.getfoundry.sh/getting-started/installation) in the foundry book.

Once you have done that, you will be able to fork Mainnet straight away. Run the below command in your terminal:

Make sure that you:

- Replace your API Key (get one by heading to [Chainnodes](https://app.chainnodes.org/))
- Replace the block number with a recent one, check [Etherscan](https://etherscan.io/) for that
- If you fork a non-Ethereum Mainnet chain, check [Chainlist](https://chainlist.org/) for the correct chain id and replace both occurrences in the command below

```bash
anvil --fork-url https://mainnet.chainnodes.org/api_key --fork-block-number 17480237 --fork-chain-id 1 --chain-id 1
```



Run `anvil --help` to see all available options.

Once you have done that, you should see something like the below:

![anvil result after calling](https://docs.uniswap.org/assets/images/anvil-result-cbdb52a1c3172c2644331ae2e3bf7869.png)

Your local fork of Mainnet is now running!

And as you can see on the screenshot above, anvil prints a bunch of private keys that are loaded with 10k ETH each. We will use them going forward to send transactions, including swaps on Uniswap pools.

warning

Security consideration: This is a fork of Mainnet and the same chain id is used. You have no replay protection to Ethereum Mainnet. So you need to 1: Never use the anvil private keys on a real chain or send funds to it (they are leaked everywhere) and 2: Not send any transactions to your local fork chain with accounts that you use on Ethereum Mainnet or other real chains.

If you scroll down in your terminal, near the bottom of the anvil logs you will find your RPC URL. If you haven't changed any configs, it should be `127.0.0.1:8545`. This is the RPC URL that you can now use as a drop-in replacement everywhere in your development environment, and interact with it as if it was real Ethereum Mainnet. You can use the http provider `http://127.0.0.1:8545` as well as the Websocket provider `ws://127.0.0.1:8545`.

You can now make a sample RPC request to your http provider using [Postman](https://www.postman.com/) using the below:

POST `http://127.0.0.1:8545`

Body:

```json
{
    "jsonrpc": "2.0",
    "method": "eth_chainId",
    "params": [],
    "id": 1
}
```



The result should look like the below (see image below as well):

```json
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": "0x1"
}
```



![anvil result after calling](https://docs.uniswap.org/assets/images/postman-chainid-result-6b21251b7d4659fd348e4e0ed4869e52.png)

As you can see, the chain id is `1`, just like on Mainnet!

You can find the above example and more in [this Postman workspace](https://www.postman.com/chainnodes/workspace/uniswap-examples) under "Local Development".

## Using your Mainnet Fork

Now that you have a running Mainnet Fork, you will be able to use it everywhere in your development setup. Using one of the private keys provided by anvil, you have access to enough ETH to do endless swaps and smart contract calls.

If you need any other token, you now have the flexibility of swapping your ETH to any token that has a pool deployed on Mainnet. You basically take your fake ETH and swap it to the token you need.

Check out one of the [guides about swapping](https://docs.uniswap.org/sdk/v3/guides/swaps/trading) and replace the RPC URL with your local anvil HTTP link as above.

## Next Steps

Using the above you are fully equipped to continue following the guides about how to use Uniswap while testing everything locally before going on Mainnet. You will also be able to reuse what you have learned when you develop your own protocols or dApps.

You can also continue tapping into other developer tools that make smart contract development easier like [forge](https://github.com/foundry-rs/foundry/tree/master/crates/forge) from foundry. To read more about foundry and their developer tooling, visit their [GitHub](https://github.com/foundry-rs/foundry) or the [foundry book](https://book.getfoundry.sh/).



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuides[Web3 Development Basics](https://docs.uniswap.org/sdk/v3/guides/web3-development-basics)

# Web3 Development Basics

## Introduction

Developing dApps and interacting with Smart Contracts is quite different from Web2, and at times challenging due to little information on this topic compared to other areas of software development.

This developer guide is a quick overview of the space, including references to libraries and guides that are great starting points. Reading this guide should help you identify areas that you might need to learn a bit more about and prepare you for the following Uniswap-specific guides.

It is assumed that you know the basics about Ethereum and the blockchain, including some terminology. If you already know how to build dApps and interact with ethersJS etc. you can safely skip this guide.

## RPCs

The access point to the blockchain are RPC nodes. They are the [standardized interface](https://ethereum.org/en/developers/docs/apis/json-rpc/) to read data from smart contracts, send transactions and interact with on-chain protocols.

RPCs are either [full or archival nodes](https://ethereum.org/en/developers/docs/nodes-and-clients/archive-nodes/) with a ([JSON-RPC](https://www.jsonrpc.org/)) interface.

To support Ethereum's decentralization, one can host a node themselves, for example by using one of the implementations listed below:

- [geth](https://github.com/ethereum/go-ethereum) - The original (reference) implementation of the Ethereum protocol
- [erigon](https://github.com/ledgerwatch/erigon) - A very efficient archival node implementation
- [Nethermind](https://github.com/NethermindEth/nethermind) - An Ethereum implementation focused on stability

As achieving high availability and making sure your node is synced all the time turns out to be quite challenging, there are nodes as a service (RPC) providers that you can use, especially in production environments. When choosing an RPC provider, we suggest you look for an RPC service that supports websockets as they provide far superior performance than HTTP connections. To ensure interoperability, you should also ensure that your RPC provider adheres strictly to the JSON-RPC standard and doesn't require custom requests.

[Chainnodes](https://www.chainnodes.org/) is a robust RPC provider with generous free tier that you can use in both development and production environments. For testing purposes you could also use a free public RPC endpoint, for example from [Chainlist](https://chainlist.org/).

### JSON-RPC Standard

RPCs communicate over the [JSON-RPC](https://www.jsonrpc.org/) standard. To send requests, you take the RPC URL and make a POST request with a JSON body. See the below example:

```
POST https://mainnet.chainnodes.org/API_KEY
```

Body:

```json
{
    "jsonrpc": "2.0",
    "method": "eth_blockNumber",
    "params": [],
    "id": 1
}
```



At the time of writing, this request would respond with the following:

```json
{
    "id": 1,
    "result": "0x11527c0",
    "jsonrpc": "2.0"
}
```



Examining the result, we see that the result is an encoded hex string. After decoding it, we see it returns the current blocknumber of our network, `18163648`.

You can find the above examples, including more, in [this Postman collection](https://www.postman.com/chainnodes/workspace/uniswap-examples).

To check out all possible RPC requests, head over to the [Chainnodes Docs](https://www.chainnodes.org/docs).

### Client implementations

As communicating over HTTP with POST requests directly can be quite difficult, especially if you want to properly encode and decode responses and handle failures and exponential backoffs, there are client implementations that can do the heavy lifting for you. These SDKs have developer friendly APIs and internally handle creating the proper RPC requests, sending them to the endpoint you choose and decoding the response for you.

Some of the major implementations are listed below:

- [ethers.js](https://github.com/ethers-io/ethers.js) - Javascript/Typescript SDK for NodeJS and the Browser. Used throughout the Uniswap Docs.
- [wagmi](https://github.com/wagmi-dev/wagmi) and [viem](https://github.com/wagmi-dev/viem) - Javascript/Typescript, great duo for modern Web3 development in the Browser.
- [web3js](https://github.com/web3/web3.js) - Javascript/Typescript SDK for NodeJS and the Browser by ChainSafe.

Web3 development is not limited to JS. Web3 libraries for various languages include:

- [Web3.swift](https://github.com/Boilertalk/Web3.swift) - Swift SDK for iOS apps and Backends.
- [KEthereum](https://github.com/komputing/KEthereum) - Kotlin SDK for Android development.
- [ethers-rs](https://github.com/gakonst/ethers-rs) - Rust SDK.
- [ethclient](https://github.com/ethereum/go-ethereum/tree/master/ethclient) - Go SDK, part of geth, the reference Ethereum node implementation.
- [web3.py](https://github.com/ethereum/web3.py) - Python SDK.

At the moment, Uniswap only offers Typescript sdks.

As you can see there are lots of SDKs to make it easier to communicate via RPC with the blockchain.

### Local Development

To simulate RPCs and transactions locally, you can check [this guide](https://docs.uniswap.org/sdk/v3/guides/02-local-development).

## Indexers

As RPCs are only a slim abstraction of the data stored in the blockchain, there are certain things that are hard or expensive to access with regular RPC requests.

A common example are transactions of a specific Wallet address. Imagine you want to get a list of all transactions that originated from (or to) a specific Wallet. One could think there should be an RPC method called `eth_getTransactionsForWallet` or something similar. But due to the nature of how the data is stored, this RPC method is not feasible, and hence not implemented.

Now, instead of accessing those kind of things by iterating through every block in the blockchain, you can use Indexers, that are designed to index data like that on the go and provide easy access to it.

### TheGraph

A well-known, standardized implementation of indexers is [TheGraph](https://thegraph.com/). It is used by most major protocols, including Uniswap, to index data and make it accessible to users and dashboards.

Using TheGraph, you can either access open [subgraphs](https://thegraph.com/explorer) via the GraphQL querying language, or [create your own](https://thegraph.com/docs/en/developing/creating-a-subgraph/) and deploy it.

Throughout the docs you will see how to interact with the Uniswap subgraph to fetch tick data and more without ever touching RPCs.

An important note about Indexers though:

While they can be helpful, you need to be aware that the ultimate source of truth comes from the RPCs. As reorgs happen and certain issues on indexers arise, there might be certain datapoints that are either not fully up-to-date or even completely wrong on Indexers. If you have a use-case that requires perfectly correct data all the time, use RPCs directly. If you are just doing data visualization or dashboards, use Indexers if they fit your use-case.

Some popular subgraphs that you can try to fetch data from the blockchain easily (click on playground to give it a try):

- [Uniswap Messari subgraph](https://thegraph.com/explorer/subgraphs/ELUcwgpm14LKPLrBRuVvPvNKHQ9HvwmtKgKSH6123cr7?view=Overview&chain=mainnet)
- [Snapshot Subgraph](https://thegraph.com/explorer/subgraphs/3Q4vnuSqemXnSNHoiLD7wdBbGCXszUYnUbTz191kDMNn?view=Overview&chain=mainnet)
- [Aave V3 Messari subgraph](https://thegraph.com/explorer/subgraphs/HB1Z2EAw4rtPRYVb2Nz8QGFLHCpym6ByBX6vbCViuE9F?view=Overview&chain=mainnet)

## Smart Contract Development

Smart contracts are typically developed using the [Solidity language](https://soliditylang.org/).

There are VSCode plugins that make the development with Solidity easier. One of them is Juan Blanco's "Solidity" that you can find over [here](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity).

You would typically also go for a developer suite with testing, compilation and deployment capabilities:

- [Foundry](https://github.com/foundry-rs/foundry) - Fast and modern developer tools for smart contract engineers.
- [Hardhat](https://github.com/NomicFoundation/hardhat) - Scriptable, easy and battle-tested JS developer suite for smart contracts.

To read data from smart contracts, or interact with them, use the [client SDKs](https://docs.uniswap.org/sdk/v3/guides/web3-development-basics#client-implementations) mentioned above. They help you generate the necessary RPC calls to fetch data from / send transactions to the blockchain and interact with your smart contracts. You can read more about it in the [ethers.js docs](https://docs.ethers.org/v5/api/contract/contract/).

## Blockchain Explorers

Manually gathering information and inspecting data stored in a blockchain is a tedious task. Almost all chains have at least one accompanying block explorer to help visualize addresses, transactions, contracts and more.

For Ethereum mainnet, we suggest using [Etherscan](https://etherscan.io/). You can use Etherscan to inspect [contracts](https://etherscan.io/address/0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45#code), transactions, blocks, and much more.

If you are looking to debug a transaction, [Tenderly](https://dashboard.tenderly.co/tx/mainnet/0xa4affe1abfaf28d1763d6c3ccda33e717462a928abca89415fc6e661dd7e0c55) can also be a very helpful tool. In this example of a failed transaction on the Uniswap V2 Router you can easily see why the execution failed and where.

## The Uniswap development suite

Uniswap offers several SDKs that work together and enable you to easily interact with the Uniswap protocol The most important SDKs are:

- [sdk-core](https://github.com/Uniswap/sdk-core): The core of the Uniswap SDKs, defines classes and types shared across all the SDKs
- [v2-sdk](https://github.com/Uniswap/v2-sdk): An SDK to interact with the Uniswap V2 protocol.
- [v3-sdk](https://github.com/Uniswap/v3-sdk): An SDK to interact with the Uniswap V3 protocol.
- [router-sdk](https://github.com/Uniswap/router-sdk): Provides abstractions to interact with the (older) SwapRouter contracts.
- [universal-router-sdk](https://github.com/Uniswap/universal-router-sdk): Abstracts interactions with the Universal Router.
- [smart-order-router](https://github.com/Uniswap/smart-order-router): Searches for the most efficient routes for a trade.
- [permit2-sdk](https://github.com/Uniswap/permit2-sdk): Simplifies interactions with Permit2 in JS.
- [uniswapx-sdk](https://github.com/Uniswap/uniswapx-sdk): SDK for the UniswapX protocol.

As you know already, all interactions with the blockchain happens through RPCs. So the Uniswap SDKs, as you will see throughout the guides, requires you to have access to an RPC endpoint like [Chainnodes](https://www.chainnodes.org/). When reading data, the data is read from the given RPC endpoint. When actually swapping, you will need to sign a transaction using a private key.

We are continuously working on improving the Uniswap development suite, so stay tuned for more updates.

## Next Steps

Go through the basic guides first and try to fetch some data and interact with the Uniswap ecosystem a little bit. You can even [send your first swap transaction](https://docs.uniswap.org/sdk/v3/guides/swaps/02-trading) on a local fork!

While some concepts in Web3 require thinking outside of the box, this guide should give you a good overview on where to start. You should now be fully equipped to follow our other guides.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesSwaps[Getting a Quote](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting)

# Getting a Quote

## Introduction

This guide will cover how to get the current quotes for any token pair on the Uniswap protocol. It is based on the [Quoting code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/quoting), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this example we will use `quoteExactInputSingle` to get a quote for the pair **USDC - WETH**. The inputs are the **token in**, the **token out**, the **amount in** and the **fee**.

The **fee** input parameter represents the swap fee that is distributed to all in-range liquidity at the time of the swap. It is one of the identifiers of a Pool, along with **tokenIn** and **tokenOut**.

The guide will **cover**:

1. Computing the Pool's deployment address
2. Referencing the Pool contract and fetching metadata
3. Referencing the Quoter contract and getting a quote

At the end of the guide, we should be able to fetch a quote for the given input token pair and the input token amount with the press of a button on the web application.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`quote.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts)

## Example configuration

We will use the example configuration `CurrentConfig` in most code snippets of this guide. It has the format:

```typescript
import { Token } from '@uniswap/sdk-core'

interface ExampleConfig {
  rpc: {
    local: string
    mainnet: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
    poolFee: number
  }
}

export const CurrentConfig: ExampleConfig = {...}
```



The default config of the example uses a local fork of mainnet. If you haven't already, check out our [local development guide](https://docs.uniswap.org/sdk/v3/guides/local-development). To change the rpc endpoint or the Pool used, edit the [`Currentconfig`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/config.ts#L21). To connect to mainnet directly, set the `mainnet` field in the config:

```typescript
export const CurrentConfig: ExampleConfig = {
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  tokens: {
    in: USDC_TOKEN,
    amountIn: 1000,
    out: WETH_TOKEN,
    poolFee: FeeAmount.MEDIUM,
  },
}
```



The pool used is defined by a pair of tokens in [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/constants.ts#L14). You can also change these two tokens and the fee of the pool in the config, just make sure a Pool actually exists for your configuration. Check out the top pools on [Uniswap info](https://info.uniswap.org/#/pools).

## Computing the Pool's deployment address

To interact with the **USDC - WETH** Pool contract, we first need to compute its deployment address. If you haven't worked directly with smart contracts yet, check out this [guide](https://docs.alchemy.com/docs/smart-contract-basics) from Alchemy. The SDK provides a utility method for that:

```typescript
import { computePoolAddress } from '@uniswap/v3-sdk' 

const currentPoolAddress = computePoolAddress({
  factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,
  tokenA: CurrentConfig.tokens.in,
  tokenB: CurrentConfig.tokens.out,
  fee: CurrentConfig.tokens.poolFee,
})
```



Since each *Uniswap V3 Pool* is uniquely identified by 3 characteristics (token in, token out, fee), we use those in combination with the address of the *PoolFactory* contract to compute the address of the **USDC - ETH** Pool. These parameters have already been defined in our [constants.ts](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/constants.ts#L14) file:

```typescript
const WETH_TOKEN = new Token(
  1,
  '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  18,
  'WETH',
  'Wrapped Ether'
)

const USDC_TOKEN = new Token(
  1,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USD//C'
)
```



These constants are used in the `config.ts` file, as mentioned in the Introduction.

We can find the Pool Factory Contract address for our chain [here](https://docs.uniswap.org/contracts/v3/reference/Deployments.md).

## Referencing the Pool contract and fetching metadata

Now that we have the deployment address of the **USDC - ETH** Pool, we can construct an instance of an **ethers** `Contract` to interact with it:

```typescript
import { ethers } from 'ethers'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
const poolContract = new ethers.Contract(
  currentPoolAddress,
  IUniswapV3PoolABI.abi,
  provider
)
```



To construct the *Contract* we need to provide the address of the contract, its ABI and the provider that will carry out the RPC call for us. We get access to the contract's ABI through the [@uniswap/v3-core](https://www.npmjs.com/package/@uniswap/v3-core) package, which holds the core smart contracts of the Uniswap V3 protocol:

```typescript
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'
```



Having constructed our reference to the contract, we can now access its methods through our provider. We use a batch `Promise` call. This approach queries state data concurrently, rather than sequentially, to minimize the chance of fetching out of sync data that may be returned if sequential queries are executed over the span of two blocks:

```typescript
const [token0, token1, fee, liquidity, slot0] = await Promise.all([
  poolContract.token0(),
  poolContract.token1(),
  poolContract.fee(),
  poolContract.liquidity(),
  poolContract.slot0(),
])
```



The return values of these methods will become inputs to the quote fetching function. The `token0` and `token1` variables are the addresses of the tokens in the Pool and should not be mistaken for `Token` objects from the sdk. For the full code, check out [`getPoolConstants()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts#L35) in `quote.ts`.

note

In this example, the metadata we fetch is already present in our inputs. This guide fetches this information first in order to show how to fetch any metadata, which will be expanded on in future guides.

## Referencing the Quoter contract and getting a quote

To get quotes for trades, Uniswap has deployed a **Quoter Contract**. We will use this contract to fetch the output amount we can expect for our trade, without actually executing the trade. Check out the full code for the following snippets in [quote.ts](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts)

Like we did for the Pool contract, we need to construct an instance of an **ethers** `Contract` for our Quoter contract in order to interact with it:

```typescript
const quoterContract = new ethers.Contract(
  QUOTER_CONTRACT_ADDRESS,
  Quoter.abi,
  getProvider()
)
```



We get access to the contract's ABI through the [@uniswap/v3-periphery](https://www.npmjs.com/package/@uniswap/v3-periphery) package, which holds the periphery smart contracts of the Uniswap V3 protocol:

```typescript
import Quoter from '@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json'
```



We get the QUOTE_CONTRACT_ADDRESS for our chain from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).

We can now use our Quoter contract to obtain the quote.

In an ideal world, the quoter functions would be `view` functions, which would make them very easy to query on-chain with minimal gas costs. However, the Uniswap V3 Quoter contracts rely on state-changing calls designed to be reverted to return the desired data. This means calling the quoter will be very expensive and should not be called on-chain.

To get around this difficulty, we can use the `callStatic` method provided by the **ethers.js** `Contract` instances. This is a useful method that submits a state-changing transaction to an Ethereum node, but asks the node to simulate the state change, rather than to execute it. Our script can then return the result of the simulated state change:

```typescript
const quotedAmountOut = await quoterContract.callStatic.quoteExactInputSingle(
  token0,
  token1,
  fee,
  fromReadableAmount(
    CurrentConfig.tokens.amountIn,
    CurrentConfig.tokens.in.decimals
  ).toString(),
  0
)
```



The `fromReadableAmount()` function creates the amount of the smallest unit of a token from the full unit amount and the decimals.

The result of the call is the number of output tokens you'd receive for the quoted swap.

It should be noted that `quoteExactInputSingle` is only 1 of 4 different methods that the quoter offers:

1. `quoteExactInputSingle` - given the amount you want to swap, produces a quote for the amount out for a swap of a single pool
2. `quoteExactInput` - given the amount you want to swap, produces a quote for the amount out for a swap over multiple pools
3. `quoteExactOutputSingle` - given the amount you want to get out, produces a quote for the amount in for a swap over a single pool
4. `quoteExactOutput` - given the amount you want to get out, produces a quote for the amount in for a swap over multiple pools

If we want to trade two tokens that do not share a pool with each other, we will need to make swaps over multiple pools. This is where the `quoteExactInput` and `quoteExactOutput` methods come in. We will dive deeper into routing in the [routing guide](https://docs.uniswap.org/sdk/v3/guides/swaps/routing).

For the `exactOutput` and `exactOutputSingle` methods, we need to keep in mind that a pool can not give us more than the amount of Tokens it holds. If we try to get a quote on an output of 100 WETH from a Pool that only holds 50 WETH, the function call will fail.

## Referencing the QuoterV2 contract and getting a quote

```typescript
const quoterV2Contract = new ethers.Contract(
  QUOTER_V2_CONTRACT_ADDRESS,
  QuoterV2.abi,
  getProvider()
)
```



We get the QUOTE_V2_CONTRACT_ADDRESS for our chain from [V3 refrence deployments](https://docs.uniswap.org/sdk/v3/guides/reference/deployments).

We get access to the contract's ABI through the [@uniswap/v3-periphery](https://www.npmjs.com/package/@uniswap/v3-periphery) package, which holds the periphery smart contracts of the Uniswap V3 protocol:

```typescript
import Quoter as QuoterV2 from '@uniswap/v3-periphery/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json'
```



Let's get the quote for our tokens, where "Quoter" takes multiple arguments in quoteExactInputSingle(), QuoterV2 takes only one argument in the form of an object

```typescript
const quote = await quoterContract.callStatic.quoteExactInputSingle(
  {
    tokenIn: tokenIn.address, // tokenIn is of type Token
    tokenOut: tokenOut.address, // tokenOut is of type Token
    fee: fee, // eg. 3000
    amountIn: fromReadableAmount(amountIn, tokenIn.decimals).toString(),
    sqrtPriceLimitX96: 0,
  }
);
console.log(quote.amountOut);
```



This will return "amountOut" , "gasEstimate", "initializedTicksCrossed" and "sqrtPriceX96After"

1. **AmountOut**: The tokens or cryptocurrency received in a Uniswap swap transaction.
2. **Gas Estimate**: Estimated amount of gas required for executing a Uniswap transaction on the Ethereum network.
3. **InitializedTicksCrossed**: In Uniswap V3, indicates whether liquidity has crossed certain price thresholds within a liquidity range.
4. **SqrtPriceX96After**: Square root of the price after a Uniswap V3 transaction, essential for determining pricing accuracy.

## Next Steps

Now that you're able to make a quote, check out our next guide on [trading](https://docs.uniswap.org/sdk/v3/guides/swaps/trading) using this quote!

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesSwaps[Executing a Trade](https://docs.uniswap.org/sdk/v3/guides/swaps/trading)

# Executing a Trade

## Introduction

This guide will build off our [quoting guide](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting) and show how to use a quote to construct and execute a trade on the Uniswap V3 protocol. It is based on the [Trading code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/trading), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

To get started with local development, also check out the [local development guide](https://docs.uniswap.org/sdk/v3/guides/local-development).

In this example we will trade between two ERC20 tokens: **WETH and USDC**. The tokens, amount of input token, and the fee level can be configured as inputs.

The guide will **cover**:

1. Constructing a route from pool information
2. Constructing an unchecked trade
3. Executing a trade

At the end of the guide, we should be able to create and execute a trade between any two ERC20 tokens using the example's included UI.

note

Included in the example application is functionality to wrap/unwrap ETH as needed to fund the example `WETH` to `USDC` swap directly from an `ETH` balance.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`trading.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/trading.ts)

## Using a wallet extension

Like in the previous guide, our [example](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading) uses a [config file ](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/config.ts)to configurate the inputs used. The strucuture is similar to the quoting config, but we also have the option to select an environment:

```typescript
export interface ExampleConfig {
  env: Environment
  rpc: {
    local: string
    mainnet: string
  }
  wallet: {
    address: string
    privateKey: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
    poolFee: number
  }
}
```



Per default, the env field is set to `Environment.LOCAL`:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.LOCAL,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: '',
  },
  wallet: {
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    privateKey:
      '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  },
  tokens: {
    in: WETH_TOKEN,
    amountIn: 1,
    out: USDC_TOKEN,
    poolFee: FeeAmount.MEDIUM,
  },
}
```



In this example, we have the option to use a Wallet Extension like Metamask to sign the transactions we are sending. To do so, let's change the Environment to `Environment.WALLET_EXTENSION`:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.WALLET_EXTENSION,
  rpc: {
    local: 'http://localhost:8545',
  },
  wallet: {
    ...
  },
  tokens: {
    ...
  },
}
```



Run the example and then add the local network to your wallet browser extension, if you are using Metamask for example, follow [this guide](https://support.metamask.io/hc/en-us/articles/360043227612-How-to-add-a-custom-network-RPC). You should also import a private key to use on your local network, for example `0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80` from Foundry's example wallets.

Consider checking out the [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/README.md) of the example.

If you cannot see the Tokens traded in your wallet, you possibly have to [import them](https://support.metamask.io/hc/en-us/articles/360015489031-How-to-display-tokens-in-MetaMask).

## Constructing a route from pool information

To construct our trade, we will first create an model instance of a `Pool`. We create an **ethers** contract like in the [previous guide](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting#referencing-the-pool-contract-and-fetching-metadata). We will first extract the needed metadata from the relevant pool contract. Metadata includes both constant information about the pool as well as information about its current state stored in its first slot:

```typescript
async function getPoolInfo() {
    const [token0, token1, fee, liquidity, slot0] =
    await Promise.all([
        poolContract.fee(),
        poolContract.liquidity(),
        poolContract.slot0(),
    ])

    return {
        fee,
        liquidity,
        sqrtPriceX96: slot0[0],
        tick: slot0[1],
    } 
}
```



Before continuing, let's talk about the values we fetched here and what they represent:

- `fee` is the fee that is taken from every swap that is executed on the pool in 1 per million - if the `fee` value of a pool is 500, `500/ 1000000` (or 0.05%) of the trade amount is taken as a fee. This fee goes to the liquidity providers of the Pool.
- `liquidity` is the amount of liquidity the Pool can use for trades at the current price.
- `sqrtPriceX96` is the current Price of the pool, encoded as a ratio between `token0` and `token1`.
- `tick` is the tick at the current price of the pool.

Check out the [whitepaper](https://uniswap.org/whitepaper-v3.pdf) to learn more on how liquidity and ticks work in Uniswap V3.

You can find the full code in [`pool.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/pool.ts).

Using this metadata along with our inputs, we will then construct a `Pool`:

```typescript
const poolInfo = await getPoolInfo()

const pool = new Pool(
  CurrentConfig.tokens.in,
  CurrentConfig.tokens.out,
  CurrentConfig.tokens.poolFee,
  poolInfo.sqrtPriceX96.toString(),
  poolInfo.liquidity.toString(),
  poolInfo.tick
)
```



## Creating a Route

With this `Pool`, we can now construct a route to use in our trade. Routes represent a route over one or more pools from one Token to another. Let's imagine we have three pools:

```text
- PoolA: USDC/ WETH
- PoolB: USDT/ WETH
- PoolC: USDT/ DAI
```



We would like to trade from USDC to DAI, so we create a route through our 3 pools:

```text
PoolA -> PoolB -> PoolC
```



The `Route` object can find this route from an array of given pools and an input and output Token.

To keep it simple for this guide, we only swap over one Pool:

```typescript
import { Route } from '@uniswap/v3-sdk'

const swapRoute = new Route(
  [pool],
  CurrentConfig.tokens.in,
  CurrentConfig.tokens.out
)
```



Our `Route` understands that `CurrentConfig.tokens.in` should be traded for `CurrentConfig.tokens.out` over the Array of pools `[pool]`.

## Constructing an unchecked trade

Once we have constructed the route object, we now need to obtain a quote for the given `inputAmount` of the example:

```typescript
const amountOut = await getOutputQuote(swapRoute)
```



As shown below, the quote is obtained using the `v3-sdk`'s `SwapQuoter`, in contrast to the [previous quoting guide](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting), where we directly accessed the smart contact:

```typescript
import { SwapQuoter } from '@uniswap/v3-sdk'
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'

const { calldata } = await SwapQuoter.quoteCallParameters(
  swapRoute,
  CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )
  ),
  TradeType.EXACT_INPUT,
  {
    useQuoterV2: true,
  }
)
```



The `SwapQuoter`'s `quoteCallParameters` function, gives us the calldata needed to make the call to the `Quoter`, and we then decode the returned quote:

```typescript
const quoteCallReturnData = await provider.call({
  to: QUOTER_CONTRACT_ADDRESS,
  data: calldata,
})

return ethers.utils.defaultAbiCoder.decode(['uint256'], quoteCallReturnData)
```



With the quote and the route, we can now construct a trade using the route in addition to the output amount from a quote based on our input. Because we already know the expected output of our Trade, we do not have to check it again. We can use the `uncheckedTrade` function to create our Trade:

```typescript
import { Trade } from 'uniswap/v3-sdk'
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'
import JSBI from 'jsbi'

const uncheckedTrade = Trade.createUncheckedTrade({
  route: swapRoute,
  inputAmount: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )
  ),
  outputAmount: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.out,
    JSBI.BigInt(amountOut)
  ),
  tradeType: TradeType.EXACT_INPUT,
})
```



This example uses an exact input trade, but we can also construct a trade using exact output assuming we adapt our quoting code accordingly.

## Executing a trade

Once we have created a trade, we can now execute this trade with our provider. First, we must give the `SwapRouter` approval to spend our tokens for us:

```typescript
const tokenApproval = await getTokenTransferApproval(CurrentConfig.tokens.in)
```



You can find the approval function [here](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/trading.ts#L151). We will use this function or similar implementations in most guides.

Then, we set our options that define how much time and slippage can occur in our execution as well as the address to use for our wallet:

```typescript
import { SwapOptions } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const options: SwapOptions = {
  slippageTolerance: new Percent(50, 10_000), // 50 bips, or 0.50%
  deadline: Math.floor(Date.now() / 1000) + 60 * 20, // 20 minutes from the current Unix time
  recipient: walletAddress,
}
```



The slippage of our trade is the maximum decrease from our calculated output amount that we are willing to accept for this trade. The deadline is the latest point in time when we want the transaction to go through. If we set this value too high, the transaction could be left waiting for days and we would need to pay gas fees to cancel it.

Next, we use the `SwapRouter` class, a representation of the Uniswap [SwapRouter Contract](https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol), to get the associated call parameters for our trade and options:

```typescript
import { SwapRouter } from '@uniswap/v3-sdk'

const methodParameters = SwapRouter.swapCallParameters([uncheckedTrade], options)
```



Finally, we can construct a transaction from the method parameters and send the transaction:

```typescript
const tx = {
  data: methodParameters.calldata,
  to: SWAP_ROUTER_ADDRESS,
  value: methodParameters.value,
  from: walletAddress,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const res = await wallet.sendTransaction(tx)
```



## Next Steps

The resulting example allows for trading between any two ERC20 tokens, but this can be suboptimal for the best pricing and fees. To achieve the best possible price, we use the Uniswap auto router to route through pools to get an optimal cost. Our [routing](https://docs.uniswap.org/sdk/v3/guides/swaps/routing) guide will show you how to use this router and execute optimal swaps.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesSwaps[Routing a Swap](https://docs.uniswap.org/sdk/v3/guides/swaps/routing)

# Routing a Swap

## Introduction

This guide will cover how to use Uniswap's smart order router to compute optimal routes and execute swaps. Rather than trading between a single pool, smart routing may use multiple hops (as many as needed) to ensure that the end result of the swap is the optimal price. It is based on the [routing code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/routing), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this example we will trade between **WETH and USDC**, but you can configure your example to use any two currencies and amount of input currency.

The guide will **cover**:

1. Creating a router instance
2. Creating a route
3. Swapping using a route

At the end of the guide, we should be able to create a route and execute a swap between any two currencies tokens using the example's included UI.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`routing.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/src/libs/routing.ts)

The config, which we will use in some code snippets in this guides has this structure:

```typescript
import { Token } from '@uniswap/sdk-core'

interface ExampleConfig {
  env: Environment
  rpc: {
    local: string
    mainnet: string
  }
  wallet: {
    address: string
    privateKey: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
  }
}

export const CurrentConfig: ExampleConfig = {...}
```



## Creating a router instance

To compute our route, we will use the `@uniswap/smart-order-router` package, specifically the `AlphaRouter` class which requires a `chainId` and a `provider`. Note that routing is not supported for local forks, so we will use a mainnet provider even when swapping on a local fork:

```typescript
import { AlphaRouter, ChainId } from '@uniswap/smart-order-router'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const router = new AlphaRouter({
  chainId: ChainId.MAINNET,
  provider,
})
```



## Creating a route

We will use the [SwapRouter02](https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) for our trade. The `smart-order-router` package provides us with a `SwapOptionsSwapRouter02` interface, defining the wallet to use, slippage tolerance, and deadline for the transaction that we need to interact with the contract:

```typescript
import { SwapOptionsSwapRouter02, SwapType } from '@uniswap/smart-order-router'
import { Percent } from '@uniswap/sdk-core'

const options: SwapOptionsSwapRouter02 = {
  recipient: CurrentConfig.wallet.address,
  slippageTolerance: new Percent(50, 10_000),
  deadline: Math.floor(Date.now() / 1000 + 1800),
  type: SwapType.SWAP_ROUTER_02,
}
```



Like explained in the [previous guide](https://docs.uniswap.org/sdk/v3/guides/swaps/trading#executing-a-trade), it is important to set the parameters to sensible values.

Using these options, we can now create a trade (`TradeType.EXACT_INPUT` or `TradeType.EXACT_OUTPUT`) with the currency and the input amount to use to get a quote. For this example, we'll use an `EXACT_INPUT` trade to get a quote outputted in the quote currency.

```typescript
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'

const rawTokenAmountIn: JSBI = fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )

const route = await router.route(
  CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    rawTokenAmountIn
  ),
  CurrentConfig.tokens.out,
  TradeType.EXACT_INPUT,
  options
)
```



The `fromReadableAmount` function calculates the amount of tokens in the Token's smallest unit from the full unit and the Token's decimals:

src/libs/conversion.ts

```typescript
export function fromReadableAmount(amount: number, decimals: number): JSBI {
  const extraDigits = Math.pow(10, countDecimals(amount))
  const adjustedAmount = amount * extraDigits
  return JSBI.divide(
    JSBI.multiply(
      JSBI.BigInt(adjustedAmount),
      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimals))
    ),
    JSBI.BigInt(extraDigits)
  )
}
```



`route` and `route.methodParameters` are *optional* as the request can fail, for example if **no route exists** between the two Tokens or because of networking issues. We check if the call was succesful:

```typescript
if (!route || !route.methodParameters) {
    // Handle failed request
}
```



Depending on our preferences and reason for the issue we could retry the request or throw an Error.

## Swapping using a route

First, we need to give approval to the `SwapRouter` smart contract to spend our tokens for us:

```typescript
import { ethers } from 'ethers'
...

const wallet = new ethers.Wallet(privateKey, provider)
const tokenContract = new ethers.Contract(
    CurrentConfig.tokens.in.address, 
    ERC20ABI, 
    wallet
)
const tokenApproval = await tokenContract.approve(
    V3_SWAP_ROUTER_ADDRESS, 
    ethers.BigNumber.from(rawTokenAmountIn.toString())
)
```



To be able to spend the tokens of a wallet, a smart contract first needs to get an approval from that wallet. ERC20 tokens have an `approve` function that accepts the address of the smart contract that we want to allow spending our tokens and the amount the smart contract should be allowed to spend.

We can get the **V3_SWAP_ROUTER_ADDRESS** for our chain from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md). Keep in mind that different chains might have **different deployment addresses** for the same contracts. The deployment address for local forks of a network are the same as in the network you forked, so for a **fork of mainnet** it would be the address for **Mainnet**.

We need to wait one block for the approval transaction to be included by the blockchain.

Once the approval has been granted, we can now execute the trade using the route's computed calldata, values, and gas values:

```typescript
const txRes = await wallet.sendTransaction({
  data: route.methodParameters.calldata,
  to: V3_SWAP_ROUTER_ADDRESS,
  value: route.methodParameters.value,
  from: wallet.address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
})
```



After swapping, you should see the currency balances update in the UI shortly after the block is confirmed.

You can find the full code in [`routing.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/src/libs/routing.ts).

## Next Steps

Now that you're familiar with trading, consider checking out our next guides on [pooling liquidity](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data) to Uniswap!





[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesPooling Liquidity[Minting a Position](https://docs.uniswap.org/sdk/v3/guides/liquidity/minting)

# Minting a Position

## Introduction

This guide will cover how to create (or mint) a liquidity position on the Uniswap V3 protocol. It is based on the [minting a position code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/minting-position), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position for the **USDC - DAI** pair. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for and the Pool **fee**.

The guide will **cover**:

1. Giving approval to transfer our tokens
2. Creating an instance of a `Pool`
3. Calculating our `Position` from our input tokens
4. Configuring and executing our minting transaction

At the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`mintPosition()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/positions.ts#L37)

## Giving approval to transfer our tokens

We want to use the `NonfungiblePositionManager` contract to create our liqudity position. In situations where a smart contract is transfering tokens on our behalf, we need to give it approval to do so. This is done by interacting with the Contract of the contract, considering ERC20 Tokens are smart contracts of their own.

Considering this, the first step to create our position is to give approval to the protocol's `NonfungiblePositionManager` to transfer our tokens:

```typescript
const token0Approval = await getTokenTransferApproval(
  token0Address,
  amount0
)
const token1Approval = await getTokenTransferApproval(
  token1Address,
  amount1
)
```



The logic to achieve that is wrapped in the `getTokenTransferApprovals` function. In short, since both **USDC** and **DAI** are ERC20 tokens, we setup a reference to their smart contracts and call the `approve` function:

```typescript
import { ethers, BigNumber } from 'ethers'

async function getTokenTransferApproval(address: string, amount: BigNumber) {
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

    const tokenContract = new ethers.Contract(
        address,
        ERC20_ABI,
        provider
    )

    return tokenContract.approve(
        NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
        amount
    )
}
```



We can get the Contract address for the NonfungiblePositionManager from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md). For Ethereum mainnet or a local fork of mainnet, we see that the contract address is `0xC36442b4a4522E871399CD717aBDD847Ab11FE88`. In our example, this is defined in the [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts) file.

## Creating an instance of a `Pool`

Having approved the transfer of our tokens, we now need to get data about the pool for which we will provide liquidity, in order to instantiate a Pool class.

To start, we compute our Pool's address by using a helper function and passing in the unique identifiers of a Pool - the **two tokens** and the Pool **fee**. The **fee** input parameter represents the swap fee that is distributed to all in range liquidity at the time of the swap.

```typescript
import { computePoolAddress, FeeAmount } from '@uniswap/v3-sdk'
import { Token } from '@uniswap/sdk-core'

const token0: Token = ...
const token1: Token = ...
const fee: FeeAmount = ...
const POOL_FACTORY_CONTRACT_ADDRESS: string = ...

const currentPoolAddress = computePoolAddress({
  factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,
  tokenA: token0,
  tokenB: token1,
  fee: poolFee,
})
```



Again, we can get the factory contract address from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md). For Ethereum mainnet, or a local fork of mainnet, it is `0x1F98431c8aD98523631AE4a59f267346ea31F984`. In our example, it is defined in [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts)

Then, we get the Pool's data by creating a reference to the Pool's smart contract and accessing its methods, very similar to what we did in the [Quoting guide](https://docs.uniswap.org/sdk/v3/guides/swaps/quoting#referencing-the-pool-contract-and-fetching-metadata):

```typescript
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'

const poolContract = new ethers.Contract(
  currentPoolAddress,
  IUniswapV3PoolABI.abi,
  provider
)

const [liquidity, slot0] =
  await Promise.all([
    poolContract.liquidity(),
    poolContract.slot0(),
  ])
```



Having collected the required data, we can now create an instance of the `Pool` class:

```typescript
import { Pool } from '@uniswap/v3-sdk'

const configuredPool = new Pool(
  token0,
  token1,
  poolFee,
  slot0.sqrtPriceX96.toString(),
  liquidity.toString(),
  slot0.tick
)
```



We need a Pool instance to create our Position as various parameters of liquidity positions depend on the state of the Pool where they are created. An example is the current price (named *sqrtPriceX96* after the way it is encoded) to know the ratio of the two Tokens we need to send to the Pool.

Liquidity provided below the current Price will be provided in the first Token of the Pool, while liquidity provided above the current Price is made up by the second Token.

## Calculating our `Position` from our input tokens

Having created the instance of the `Pool` class, we can now use that to create an instance of a `Position` class, which represents the price range for a specific pool that LPs choose to provide in:

```typescript
import { Position } from '@uniswap/v3-sdk'
import { BigIntish } from '@uniswap/sdk-core'

// The maximum token amounts we want to provide. BigIntish accepts number, string or JSBI
const amount0: BigIntish = ...
const amount1: BigIntish = ...

const position = Position.fromAmounts({
  pool: configuredPool,
  tickLower:
    nearestUsableTick(configuredPool.tickCurrent, configuredPool.tickSpacing) -
    configuredPool.tickSpacing * 2,
  tickUpper:
    nearestUsableTick(configuredPool.tickCurrent, configuredPool.tickSpacing) +
    configuredPool.tickSpacing * 2,
  amount0: amount0,
  amount1: amount1,
  useFullPrecision: true,
})
```



We use the `fromAmounts` static function of the `Position` class to create an instance of it, which uses the following parameters:

- The **tickLower** and **tickUpper** parameters specify the price range at which to provide liquidity. This example calls **nearestUsableTick** to get the current useable tick and adjust the lower parameter to be below it by two **tickSpacing** and the upper to be above it by two tickSpacing. This guarantees that the provided liquidity is "in range", meaning it will be earning fees upon minting this position
- **amount0** and **amount1** define the maximum amount of currency the liquidity position can use. In this example, we supply these from our configuration parameters.

Given those parameters, `fromAmounts` will attempt to calculate the maximum amount of liquidity we can supply.

## Configuring and executing our minting transaction

The Position instance is then passed as input to the `NonfungiblePositionManager`'s `addCallParameters` function. The function also requires an [`AddLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L77) object as its second parameter. This is either of type [`MintOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L74) for minting a new position or [`IncreaseOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L75) for adding liquidity to an existing position. For this example, we're using a `MintOptions` to create our position.

```typescript
import { MintOptions, NonfungiblePositionManager } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const mintOptions: MintOptions = {
  recipient: address,
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
}

// get calldata for minting a position
const { calldata, value } = NonfungiblePositionManager.addCallParameters(
  position,
  mintOptions
)
```



The `MintOptions` interface requires three keys:

- `recipient` defines the address of the Position owner, so in our case the address of our wallet.
- `deadline` defines the latest point in time at which we want our transaction to be included in the blockchain.
- `slippageTolerance` defines the maximum amount of **change of the ratio** of the Tokens we provide. The ratio can change if for example **trades** that change the price of the Pool are included before our transaction.

The `addCallParameters` function returns the calldata as well as the value required to execute the transaction:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}
```



We use our wallet to send the transaction. As it is a write call, we need to sign the transaction with a valid private key.

```typescript
const wallet = new ethers.Wallet(privateKey, provider)

const txRes = await wallet.sendTransaction(transaction)
```



Write calls do not return the result of the transaction. If we want to read the result we would need to use for example `trace_transaction`. You can find an example of that in the [Range Order guide](https://docs.uniswap.org/sdk/v3/guides/advanced/range-orders). In this example, we don't need the result of the transaction.

The effect of the transaction is to mint a new Position NFT. We should see a new position with liquidity in our list of positions.

## Next Steps

Once you have minted a position, our next guide [Adding and Removing Liquidity](https://docs.uniswap.org/sdk/v3/guides/liquidity/modifying-position) will demonstrate how you can add and remove liquidity from that minted position!

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesPooling Liquidity[Fetching Positions](https://docs.uniswap.org/sdk/v3/guides/liquidity/fetching-positions)

# Fetching Positions

## Introduction

This guide will cover how to create (or mint) a liquidity position on the Uniswap V3 protocol. Like the [Liquidity Position guide](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data) it doesn't have an accompanying example, nevertheless the concepts and functions used here can be found among the various examples that interact with liquidity positions.

info

If you need an introduction to liquidity positions, check out the [Liquidity Position guide](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data)

The [NonfungiblePositionManager Contract](https://docs.uniswap.org/contracts/v3/reference/periphery/NonfungiblePositionManager) can be used to create Positions, as well as get information on **existing Positions**. In this guide, we will fetch **all Positions** an address has and fetch the **detailed Position Data** for those positions.

The guide will **cover**:

1. Creating an ethersJS contract to interact with the NonfungiblePositionManager.
2. Fetching all positions for an address.
3. Fetching the position info for the positions.

At the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application.

For this guide, we do not need to use the Uniswap SDKs, we will only import the contract ABI for the NonfungiblePositionManager Contract from [`@uniswap/v3-periphery`](https://www.npmjs.com/package/@uniswap/v3-periphery).

## Connecting to the NFTPositionManager Contract

We use **ethersJS** to interact with the NonfungiblePositionManager Contract. Let's create an ethers Contract:

```typescript
import { ethers } from 'ethers'
import INONFUNGIBLE_POSITION_MANAGER from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const nfpmContract = new ethers.Contract(
    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    INONFUNGIBLE_POSITION_MANAGER.abi,
    provider
)
```



We get the Contract ABI from the 'v3-periphery` package and the contract address from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md)

## Fetching the Position Ids

We want to fetch all Position Ids for our address. We first fetch the number of positions and then the ids by their indices.

We fetch the number of positions using the `balanceOf` read call:

```typescript
const numPositions = await nfpmContract.balanceOf(address)
```



Next we iterate over the number of positions and fetch the ids:

```typescript
const calls = []

for (let i = 0; i < numPositions; i++) {
    calls.push(
        nfpmContract.tokenOfOwnerByIndex(address, i)
    )
}

const positionIds = await Promise.all(calls)
```



## Fetching the Position Info

Now that we have the ids of the Positions associated with our address, we can fetch the position info using the `positions` function.

The solidity function returns a lot of values describing the Position:

```solidity
function positions(
    uint256 tokenId
  ) external view returns (
    uint96 nonce, 
    address operator, 
    address token0, 
    address token1, 
    uint24 fee, 
    int24 tickLower, 
    int24 tickUpper, 
    uint128 liquidity, 
    uint256 feeGrowthInside0LastX128, 
    uint256 feeGrowthInside1LastX128, 
    uint128 tokensOwed0, 
    uint128 tokensOwed1
    )
```



In this example we only care about values needed to interact with positions, so we create an Interface `PositionInfo`:

```typescript
interface PositionInfo {
  tickLower: number
  tickUpper: number
  liquidity: JSBI
  feeGrowthInside0LastX128: JSBI
  feeGrowthInside1LastX128: JSBI
  tokensOwed0: JSBI
  tokensOwed1: JSBI
}
```



We fetch the Position data with `positions`:

```typescript
const positionCalls = []

for (let id of positionIds) {
    positionCalls.push(
        nfpmContract.positions(id)
    )
}

const callResponses = await Promise.all(positionCalls)
```



Finally, we map the RPC response to our interface:

```typescript
const positionInfos = callResponses.map((position) => {
    return {
        tickLower: position.tickLower,
        tickUpper: position.tickUpper,
        liquidity: JSBI.BigInt(position.liquidity),
        feeGrowthInside0LastX128: JSBI.BigInt(position.feeGrowthInside0LastX128),
        feeGrowthInside1LastX128: JSBI.BigInt(position.feeGrowthInside1LastX128),
        tokensOwed0: JSBI.BigInt(position.tokensOwed0),
        tokensOwed1: JSBI.BigInt(position.tokensOwed1),
  }
})
```



We now have an array containing PositionInfo for all positions that our address holds.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesPooling Liquidity[Adding & Removing Liquidity](https://docs.uniswap.org/sdk/v3/guides/liquidity/modifying-position)

# Adding & Removing Liquidity

## Introduction

This guide will cover how to modify a liquidity position by adding or removing liquidity on the Uniswap V3 protocol. It is based on the [modifying a position code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/modifying-position), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/modifying-position/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position and then modify the provided liquidity for the **USDC - DAI** pair. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the Pool **fee** and the **fraction** by which to **add and remove** from our position.

The guide will **cover**:

1. Adding liquidity to our position
2. Removing liquidity from our position

At the end of the guide, given the inputs above, we should be able to add or remove liquidity from a minted position with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`addLiquidity()`](https://github.com/Uniswap/examples/blob/d34a53412dbf905802da2249391788a225719bb8/v3-sdk/modifying-position/src/example/Example.tsx#L33) and [`removeLiquidity()`](https://github.com/Uniswap/examples/blob/733d586070afe2c8cceb35d557a77eac7a19a656/v3-sdk/modifying-position/src/example/Example.tsx#L83)

note

This guide assumes you are familiar with our [Minting a Position](https://docs.uniswap.org/sdk/v3/guides/liquidity/minting) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.

## Configuration and utils

The example can be configured in the [`config.ts`](https://github.com/Uniswap/examples/blob/d34a53412dbf905802da2249391788a225719bb8/v3-sdk/modifying-position/src/config.ts) file. The `CurrentConfig` object has this structure:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.LOCAL,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  wallet: {
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    privateKey:
      '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  },
  tokens: {
    token0: USDC_TOKEN,
    token0Amount: 1000,
    token1: DAI_TOKEN,
    token1Amount: 1000,
    poolFee: FeeAmount.LOW,
    fractionToRemove: 1,
    fractionToAdd: 0.5,
  },
}
```



You should already be familiar with the `rpc`, `wallet` and token parameters, they are used in the same way as in the guides earlier in our v3-sdk series. The `fractionToAdd` variable is the multiplicator by which we will increase the Position. A fraction of **0.5** means we increase the liquidity by **50%**. The `fractionToRemove` variable is the fraction of the Position that we want to remove later in the guide. A fraction of **1** means we remove **100%** of the liquidity.

## Adding liquidity to our position

Assuming we have already minted a position, our first step is to construct the modified position using our original position to calculate the amount by which we want to increase our current position:

```typescript
const fractionToAdd: number = ...

const amount0Increased: JSBI = fromReadableAmount(
    readableAmount0 * fractionToAdd, 
    token0.decimals
)
const amount1Increase: JSBI = fromReadableAmount(
    readableAmount1 * fractionToAdd, 
    token1.decimals
)

const positionToIncreaseBy = constructPosition(
    amount0Increased,
    amount1Increase
  )
)
```



The `fromReadableAmount()` function calculates the amount of tokens in their smallest unit, so for example 1 ETH would be `1000000000000000000` Wei as ETH has 18 decimals.

A better way to get the amounts might be to fetch them with the positionId directly from the blockchain. We demonstrated how to do that in the [first guide](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data#fetching-positions) of this series.

```typescript
import { Pool, Position } from '@uniswap/v3-sdk'
import JSBI from 'jsbi'

function constructPosition(
    amount0: JSBI,
    amount1: JSBI
): Position {
    // create Pool same as in the previous guide
    const pool = new Pool(...)

    // create position using the maximum liquidity from input amounts
    return Position.fromAmounts({
        pool,
        tickLower:
            nearestUsableTick(pool.tickCurrent, pool.tickSpacing) -
            pool.tickSpacing * 2,
        tickUpper:
            nearestUsableTick(pool.tickCurrent, pool.tickSpacing) +
            pool.tickSpacing * 2,
        amount0,
        amount1,
        useFullPrecision: true,
    })
}
```



The function receives two arguments, which are the amounts that are used to construct the Position instance. In this example, both of the arguments follow the same logic: we multiply the parameterized `tokenAmount` by the parameterized `fractionToAdd` since the new liquidity position will be added on top of the already minted liquidity position.

We then need to construct an options object of type [`AddLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L77) similar to how we did in the minting case. In this case, we will use [`IncreaseOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L75):

```typescript
import { AddLiquidityOptions } from '@uniswap/v3-sdk'

const addLiquidityOptions: AddLiquidityOptions = {
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
  tokenId,
}
```



Compared to minting, we have omitted the `recipient` parameter and instead passed in the `tokenId` of the position we previously minted. As the Position already exists, the recipient doesn't change, instead the NonfungiblePositionManager contract can modify the existing Position by accessing it with its id.

The tokenId can be fetched with the tokenOfOwnerByIndex function of the NonfungiblePositionManager Contract as described [here](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data#fetching-positions).

The newly created position along with the options object are then passed to the `NonfungiblePositionManager`'s `addCallParameters`:

```typescript
import { NonfungiblePositionManager } from '@uniswap/v3-sdk'

const positionToIncreaseBy = constructPosition(CurrentConfig.tokens.amount0, CurrentConfig.tokens.amount1)

const { calldata, value } = NonfungiblePositionManager.addCallParameters(
  positionToIncreaseBy,
  addLiquidityOptions
)
```



The return values of `addCallParameters` are the calldata and value of the transaction we need to submit to increase our position's liquidity. We can now build and execute the transaction:

```typescript
import { ethers } from 'ethers'

const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const wallet = new ethers.Wallet(privateKey, provider)

const txRes = await wallet.sendTransaction(transaction)
```



We can get the Contract address for the NonfungiblePositionManager from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).

After pressing the button, note how the balance of USDC and DAI drops and our position's liquidity increases.

## Removing liquidity from our position

The `removeLiquidity` function is the mirror action of adding liquidity and will be somewhat similar as a result, requiring a position to already be minted.

To start, we create a position identical to the one we minted:

```typescript
const amount0: JSBI = fromReadableAmount(
    readableAmount0 * fractionToAdd, 
    token0.decimals
)
const amount1: JSBI = fromReadableAmount(
    readableAmount1 * fractionToAdd, 
    token1.decimals
)

const currentPosition = constructPosition(
  amount0,
  amount1
)
```



We then need to construct an options object of type [`RemoveLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L138):

```typescript
import { RemoveLiquidityOptions } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const removeLiquidityOptions: RemoveLiquidityOptions = {
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
  tokenId: positionId,
  // percentage of liquidity to remove
  liquidityPercentage: new Percent(0.5),
  collectOptions,
}
```



Just as with adding liquidity, we have we have omitted the `recipient` parameter and instead passed in the `tokenId` of the position we previously minted.

We have also provide two additional parameters:

- `liquidityPercentage` determines how much liquidity is removed from our initial position (as a `Percentage`), and transfers the removed liquidity back to our address. We set this percentage from our guide configuration ranging from 0 (0%) to 1 (100%). In this example we would remove 50% of the liquidity.
- [`collectOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L105) gives us the option to collect the fees, if any, that we have accrued for this position. In this example, we won't collect any fees, so we provide zero values. If you'd like to see how to collect fees without modifying your position, check out our [collecting fees](https://docs.uniswap.org/sdk/v3/guides/liquidity/liquidity-fees) guide!

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'
import { CollectOptions } from '@uniswap/v3-sdk'

const collectOptions: Omit<CollectOptions, 'tokenId'> = {
  expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(
    token0,
    0
  ),
  expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(
    token1,
    0
  ),
  recipient: address,
}
```



The position object along with the options object is passed to the `NonfungiblePositionManager`'s `removeCallParameters`, similar to how we did in the adding liquidity case:

```typescript
const { calldata, value } = NonfungiblePositionManager.removeCallParameters(
  currentPosition,
  removeLiquidityOptions
)
```



The return values `removeCallParameters` are the calldata and value that are needed to construct the transaction to remove liquidity from our position. We can build the transaction and send it for execution:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const txRes = await wallet.sendTransaction(transaction)
```



After pressing the button, note how the balance of USDC and DAI increases and our position's liquidity drops.

## Next Steps

Now that you can mint and modify a position, check out how to [collect fees](https://docs.uniswap.org/sdk/v3/guides/liquidity/04-collecting-fees.md) from the position!

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesPooling Liquidity[Collecting Fees](https://docs.uniswap.org/sdk/v3/guides/liquidity/liquidity-fees)

# Collecting Fees

## Introduction

This guide will cover how to collect fees from a liquidity position on the Uniswap V3 protocol. It is based on the [collecting fees code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/collecting-fees), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position for the **USDC - DAI** pair. We will then attempt to collect any fees that the position has accrued from those trading against our provisioned liquidity. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the Pool **fee** and the **max amount of accrued fees** we want to collect for each token.

The guide will **cover**:

1. Setting up our fee collection
2. Submitting our fee collection transaction

At the end of the guide, given the inputs above, we should be able to collect the accrued fees (if any) of a minted position with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`collectFees()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/src/libs/liquidity.ts#L35).

note

This guide assumes you are familiar with our [Minting a Position](https://docs.uniswap.org/sdk/v3/guides/liquidity/01-minting-position.md) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.

## Setting up our fee collection

All of the fee collecting logic can be found in the [`collectFees`](https://github.com/Uniswap/examples/blob/be67e7df220b0a270c9d18bbaab529e017213adf/v3-sdk/collecting-fees/src/example/Example.tsx#L24) function. Notice how the **Collect Fees** button is disabled until a position is minted. This happens because there will be no fees to collect unless there is a position whose liquidity has been traded against.

To start, we fetch the position from the NonfungiblePositionManager Contract to get the fees we are owed:

```typescript
import { ethers } from 'ethers'
import JSBI from 'jsbi'
...

const nfpmContract = new ethers.Contract(NONFUNGIBLE_POSITION_MANAGER_ADDRESS, provider)
const position = nfpmContract.positions(positionId)
```



Next, we construct an options object of type [`CollectOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L105) that holds the data about the fees we want to collect:

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const collectOptions: CollectOptions = {
  tokenId: positionId,
  expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.token0,
    JSBI.BigInt(position.tokensOwed0)
  ),
  expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.token1,
    JSBI.BigInt(position.tokensOwed1)
  ),
  recipient: address,
}
```



Read more about fetching position info [here](https://docs.uniswap.org/sdk/v3/guides/liquidity/position-data#fetching-positions).

Similar to the other functions exposed by the `NonfungiblePositionManager`, we pass the `tokenId` and the `recipient` of the fees, which in this case is our function's input position id and our wallet's address.

The other two `CurrencyAmount` parameters (`expectedCurrencyOwed0` and `expectedCurrencyOwed1`) define the **maximum** amount of currency we expect to get collect through accrued fees of each token in the pool. We set these through our guide's configuration.

In a real world scenario, we can fetch the amount of fees that are owed to the Position through the `positions()` function of the NonfungiblePositionManager Contract. We fetch the position info like in this code snippet taken from the [Fetching Positions guide](https://docs.uniswap.org/sdk/v3/guides/liquidity/fetching-positions):

```typescript
const positionInfos = callResponses.map((position) => {
    return {
        tickLower: position.tickLower,
        tickUpper: position.tickUpper,
        liquidity: JSBI.BigInt(position.liquidity),
        feeGrowthInside0LastX128: JSBI.BigInt(position.feeGrowthInside0LastX128),
        feeGrowthInside1LastX128: JSBI.BigInt(position.feeGrowthInside1LastX128),
        tokensOwed0: JSBI.BigInt(position.tokensOwed0),
        tokensOwed1: JSBI.BigInt(position.tokensOwed1),
  }
})
```



The `tokensOwed0` and `tokensOwed1` values are the fees owed.

In this example, we have the values hardcoded in the [`config.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/src/config.ts) file.

## Submitting our fee collection transaction

Next, we get the call parameters for collecting our fees from our `NonfungiblePositionManager` using the constructed `CollectOptions`:

```typescript
const { calldata, value } =
  NonfungiblePositionManager.collectCallParameters(collectOptions)
```



The function above returns the calldata and value required to construct the transaction for collecting accrued fees. Now that we have both the calldata and value we needed for the transaction, we can build and execute the it:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const txRes = await wallet.sendTransaction(transaction)
```



After pressing the button, if someone has traded against our position, we should be able to note how the balance of USDC and DAI increases as we collect fees.

## Next Steps

The previous guides detail all the atomic steps needed to create and manage positions. However, these approaches may not use all of your desired currency. To ensure you are using your full funds while minimizing gas prices, check out our guide on [Swapping and Adding Liquidity](https://docs.uniswap.org/sdk/v3/guides/liquidity/swap-and-add) in a single transaction!

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesPooling Liquidity[Swapping and Adding Liquidity](https://docs.uniswap.org/sdk/v3/guides/liquidity/swap-and-add)

# Swapping and Adding Liquidity

## Introduction

This guide will cover how to execute a swap-and-add operation in a single atomic transaction. It is based on the [swap-and-add example](https://github.com/Uniswap/examples/tree/main/v3-sdk/swap-and-add-liquidity), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/tree/main/v3-sdk/swap-and-add-liquidity) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

When adding liquidity to a Uniswap v3 pool, you must provide two assets in a particular ratio. In many cases, your contract or the user's wallet hold a different ratio of those two assets. In order to deposit 100% of your assets, you must first swap your assets to the optimal ratio and then add liquidity.

However, the swap may shift the balance of the pool and thus change the optimal ratio. To avoid that, we can execute this swap-and-add liquidity operation in an atomic fashion, using a router. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the **amount** of each token to swap-and-add, and the Pool **fee**.

The guide will **cover**:

1. Setup a router instance
2. Configuring our ratio calculation
3. Calculating our currency ratio
4. Constructing and executing our swap-and-add transaction

At the end of the guide, given the inputs above, we should be able swap-and-add liquidity using 100% of the input assets with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`swapAndAddLiquidity()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/swap-and-add-liquidity/src/libs/liquidity.ts#L48).

note

This guide assumes you are familiar with our [Minting a Position](https://docs.uniswap.org/sdk/v3/guides/liquidity/01-minting-position.md) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.

## Setup a router instance

The first step is to approve the `SwapRouter` smart contract to spend our tokens for us in order for us to add liquidity to our position:

```typescript
const tokenInApproval = await getTokenTransferApproval(
  token0,
  V3_SWAP_ROUTER_ADDRESS
)

const tokenOutApproval = await getTokenTransferApproval(
  token1,
  V3_SWAP_ROUTER_ADDRESS
)
```



We described the `getTokenTransferApproval` function [here](https://docs.uniswap.org/sdk/v3/guides/liquidity/minting#giving-approval-to-transfer-our-tokens).

Then we can setup our router, the [`AlphaRouter`](https://github.com/Uniswap/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/alpha-router/alpha-router.ts#L333), which is part of the [smart-order-router package](https://www.npmjs.com/package/@uniswap/smart-order-router). The router requires a `chainId` and a `provider` to be initialized. Note that routing is not supported for local forks, so we will use a mainnet provider even when swapping on a local fork:

```typescript
import { ethers } from 'ethers'
import { AlphaRouter } from '@uniswap/smart-order-router'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const router = new AlphaRouter({ chainId: 1, provider })
```



For a more detailed example, check out our [routing guide](https://docs.uniswap.org/sdk/v3/guides/trading/03-routing.md).

## Configuring our ratio calculation

Having created the router, we now need to construct the parameters required to make a call to its `routeToRatio` function, which will ensure the ratio of currency used matches the pool's required ratio to add our total liquidity. This will require the following parameters:

The first two parameters are the currency amounts we use as input to the `routeToRatio` algorithm:

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const token0CurrencyAmount = CurrencyAmount.fromRawAmount(
  token0,
  fromReadableAmount(
    token0AmountToAdd,
    token0.decimals
  )
)

const token1CurrencyAmount = CurrencyAmount.fromRawAmount(
  token1,
  fromReadableAmount(
    token1AmountToAdd,
    token1.decimals
  )
)
```



Next, we will create a placeholder position with a liquidity of `1` since liquidity is still unknown and will be set inside the call to `routeToRatio`:

```typescript
import { Pool, Position, nearestUsableTick } from '@uniswap/v3-sdk'

const placeholderPosition = new Position{
    pool,
    liquidity: 1,
    tickLower:
      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) -
      pool.tickSpacing * 2,
    tickUpper:
      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) +
      poolInfo.tickSpacing * 2
}
```



We then need to create an instance of `SwapAndAddConfig` which will set additional configuration parameters for the `routeToRatio` algorithm:

- `ratioErrorTolerance` determines the margin of error the resulting ratio can have from the optimal ratio.
- `maxIterations` determines the maximum times the algorithm will iterate to find a ratio within error tolerance. If max iterations is exceeded, an error is returned. The benefit of running the algorithm more times is that we have more chances to find a route, but more iterations will longer to execute. We've used a default of 6 in our example.

```typescript
import { Fraction } from '@uniswap/sdk-core'
import { SwapAndAddConfig } from '@uniswap/smart-order-router'

const swapAndAddConfig: SwapAndAddConfig = {
  ratioErrorTolerance: new Fraction(1, 100),
  maxIterations: 6,
}
```



Finally, we will create an instance of `SwapAndAddOptions` to configure which position we are adding liquidity to and our defined swapping parameters in two different objects:

- **`swapConfig`** configures the `recipient` of leftover dust from swap, `slippageTolerance` and a `deadline` for the swap.
- **`addLiquidityOptions`** must contain a `tokenId` to add to an existing position

```typescript
import { SwapAndAddOptions } from '@uniswap/smart-order-router'

const swapAndAddOptions: SwapAndAddOptions = {
  swapOptions: {
    type: SwapType.SWAP_ROUTER_02,
    recipient: address,
    slippageTolerance: new Percent(50, 10_000),
    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  },
  addLiquidityOptions: {
    tokenId: positionId,
  },
}
```



## Calculating our currency ratio

Having constructed all the parameters we need to call `routeToRatio`, we can now make the call to the function:

```typescript
import { SwapToRatioResponse } from '@uniswap/smart-order-router'

const routeToRatioResponse: SwapToRatioResponse = await router.routeToRatio(
  token0CurrencyAmount,
  token1CurrencyAmount,
  currentPosition,
  swapAndAddConfig,
  swapAndAddOptions
)
```



The return type of the function call is [SwapToRatioResponse](https://github.com/Uniswap/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/router.ts#L121). If a route was found successfully, this object will have two fields: the status (success) and the `SwapToRatioRoute` object. We check to make sure that both of those conditions hold true before we construct and submit the transaction:

```typescript
import { SwapToRatioStatus } from '@uniswap/smart-order-router'

if (
  !routeToRatioResponse ||
  routeToRatioResponse.status !== SwapToRatioStatus.SUCCESS
) {
  // Handle Failed Transaction
}
```



In case a route was not found, we return from the function a `Failed` state for the transaction.

## Constructing and executing our swap-and-add transaction

After making sure that a route was successfully found, we can now construct and send the transaction. The response (`SwapToRatioRoute`) will have the properties we need to construct our transaction object:

```typescript
import { SwapToRatioRoute } from '@uniswap/smart-order-router'

const route: SwapToRatioRoute = routeToRatioResponse.result
const transaction = {
  data: route.methodParameters?.calldata,
  to: V3_SWAP_ROUTER_ADDRESS,
  value: route.methodParameters?.value,
  from: address,
}

const txRes = await wallet.sendTransaction(transaction)
```



If the transaction was successful, our swap-and-add will be completed! We should see our input token balances decrease and our position balance should be increased accordingly.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesAdvanced[Introduction](https://docs.uniswap.org/sdk/v3/guides/advanced/introduction)

# Introduction

For some more advanced use cases, it is necessary to use multiple tools in the Uniswap toolchain.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

The following examples use **ethersJS** and the **Uniswap V3 subgraph** hosted on The Graph's hosted service. To learn more about Uniswap's subgraphs, visit the [API](https://docs.uniswap.org/api/subgraph/overview) section.

We will take a deep dive into the Uniswap V3 protocol and use practical examples to understand the data stored by the Uniswap smart contracts. We will explore how we can compute the available liquidity in a specific price range, visualize **liquidity density** in pools, use Uniswap as a **price oracle** and swap by creating **Range Orders**.

These guides are a bit longer than the previous ones and provide more theoretical background.

## Theoretical background

Some of the guides presented here require a bit of theoretical and mathematical background. To get the most out of the advanced guides, we encourage you to take a step back and read a bit about the math and theories behind the Uniswap protocol.

The most complete source of information on the Uniswap protocol is the [Uniswap V3 book](https://uniswapv3book.com/).

Besides the [concepts](https://docs.uniswap.org/concepts/uniswap-protocol) section of the Docs, the [Uniswap V3 whitepaper](https://uniswap.org/whitepaper-v3.pdf) is a great introduction to the protocol. If you haven't checked it out yet, it is probably more concise and easier to understand than you would expect.

### Datatypes in Solidity

Uniswap V3 pools make use of a number of Datatypes Solidity offers to efficiently store their state. If you are not familiar with Solidity data types yet, it can help to take a look at the [Solidity language reference](https://docs.soliditylang.org/en/v0.8.7/types.html#). For the following guides, it is beneficial to take a look at two of them, which we will outline here.

Ticks are stored as a [mapping(int24 => Tick.Info)](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L93). Solidity [mappings](https://docs.soliditylang.org/en/v0.8.7/types.html#mapping-types) are very similar to hash maps, such that we can access any Value with their key with just one read operation. The [`Tick.Info`](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Tick.sol#L17) stores the values of the Tick that we need to work with the Pool:

```solidity
struct Info {
        // the total position liquidity that references this tick
        uint128 liquidityGross;
        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
        int128 liquidityNet;
        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint256 feeGrowthOutside0X128;
        uint256 feeGrowthOutside1X128;
        // the cumulative tick value on the other side of the tick
        int56 tickCumulativeOutside;
        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint160 secondsPerLiquidityOutsideX128;
        // the seconds spent on the other side of the tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint32 secondsOutside;
        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
        bool initialized;
    }
```



We will use most of these values in the following guides.

In our case, we can access any `Tick.Info` value stored in the pool by its `int24` key. The key of the Tick is usually called its *index*. Mappings are not iterable, so if we are trying to fetch all the Ticks stored in a Pool, we can't just iterate over the mapping. Instead, we have to know the keys (indices) of the mapping, we will explore how to do that in the [Pool data guide](https://docs.uniswap.org/sdk/v3/guides/advanced/pool-data).

The second Solidity datatype we need to understand are normal unsigned [Integers](https://docs.soliditylang.org/en/v0.8.7/types.html#integers). Solidity supports unsigned integer sizes between `uint8` and `uint256`, which are 8 and 256 bits long respectively.

Let's take a look at the `tickBitmap` function of a V3 Pool:

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```



Similar to the tick mapping, the tickBitmap is a mapping of type [mapping(int16 => uint256)](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L95).

Let's look at the WETH/USDC pool with LOW fee on [Etherscan](https://etherscan.io/address/0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640#readContract). If we call the `tickBitmap` function with the input `0` we get the following response (at the time of writing):

![TickBitmapEtherscan](https://docs.uniswap.org/assets/images/tickBitmap-etherscan-865c516ba55726c9ef7be35a433d4d9c.png)

The `uint256` return value is interpreted as the representation of a decimal number by Etherscan. The actual raw return value are 256 bits, that look something like this:

```raw
0x0000 ... lots of zeros and ones ... 000000110000000000
```



We interpret this string of zeros and ones not as the representation of a number, but rather as 256 booleans.

If the value of a position in the value is 1, the Tick at this position is **initialized**, meaning it holds a value.

With this trick, V3 Pools allow us to fetch the status of **256 ticks** with one call. We will go into more details on how to calculate the tick indices from the tickBitmaps we fetch in the following guides.

## History of Uniswap

To get a better understanding of the V3 protocol, it can also be beneficial to understand the **history of decentralized exchanges** and the Uniswap protocol since it was founded in 2018. You can read more about the older versions of Uniswap in the [V1](https://hackmd.io/@HaydenAdams/HJ9jLsfTz?type=view#Swaps-vs-Transfers) and [V2](https://uniswap.org/whitepaper.pdf) whitepapers, as well as the [V1](https://docs.uniswap.org/contracts/v1/overview) and [V2](https://docs.uniswap.org/contracts/v2/overview) section in the contract section.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesAdvanced[Fetching Pool Data](https://docs.uniswap.org/sdk/v3/guides/advanced/pool-data)

# Fetching Pool Data

## Introduction

This guide will cover how to initialize a Pool with full tick data to allow offchain calculations. It is based on the [Fetching Pool data example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/README.md) and follow the setup instructions.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this example we will use **ethers JS** and **ethers-multicall** to construct a `Pool` object that we can use in the following guides.

This guide will **cover**:

1. Computing the Pool's address
2. Referencing the Pool contract and fetching metadata
3. Fetching the positions of all initialized Ticks with multicall
4. Fetching all ticks by their indices with a multicall
5. Constructing the Pool object

At the end of the guide, we will have created a `Pool` Object that accurately represents the state of a V3 pool at the time we fetched it.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

We will also use the `ethers-multicall` npm package:

- [`ethers-multicall`](https://www.npmjs.com/package/ethers-multicall)

The core code of this guide can be found in [`fetcher.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/libs/fetcher.ts)

## Configuration

The example accompanying this guide can be configured in the [`config.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/config.ts) file. The default configuration defines the rpc endpoint and the pool that is used for this guide:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.MAINNET,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  ...
  pool: {
    token0: USDC_TOKEN,
    token1: WETH_TOKEN,
    fee: FeeAmount.MEDIUM,
  },
}
```



FeeAmount.MEDIUM means that the pool has a swap fee of **0.3%**. The `USDC_TOKEN` and `WETH_TOKEN` are defined in the [`constants.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/libs/constants.ts) file:

```typescript
export const WETH_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  18,
  'WETH',
  'Wrapped Ether'
)

export const USDC_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USD//C'
)
```



## Computing the Pool's deployment address

In this example, we will construct the **USDC - WETH** Pool with **MEDIUM** fees. The SDK provides a method to compute the address:

```typescript
import { Pool } from '@uniswap/v3-sdk'
import { CurrentConfig } from '../config.ts'

const poolAddress = Pool.getAddress(
    CurrentConfig.pool.token0, 
    CurrentConfig.pool.token1, 
    CurrentConfig.pool.fee
  )
```



Uniswap V3 allows 4 different Fee tiers when deploying a pool, so multiple pools can exist for each pair of tokens.

## Creating a Pool Contract instance and fetching metadata

Now that we have the address of a **USDC - ETH** Pool, we can construct an instance of an **ethers** `Contract` to interact with it. To construct the Contract we need to provide the address of the contract, its ABI and a provider connected to an [RPC endpoint](https://www.chainnodes.org/docs). We get access to the contract's ABI through the `@uniswap/v3-core` package, which holds the core smart contracts of the Uniswap V3 protocol:

```typescript
import { ethers } from 'ethers'
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'

const provider = getProvider()
const poolContract = new ethers.Contract(
    poolAddress,
    IUniswapV3PoolABI.abi,
    provider
)
```



The `getProvider()` function returns an `ethers.providers.JsonRpcProvider` with either the local or mainnet rpc url that we defined, depending on the Environment that we set in `config.ts`.

Once we have set up our reference to the contract, we can proceed to access its methods. To construct our offchain representation of the Pool Contract, we need to fetch its liquidity, sqrtPrice, currently active tick and the full Tick data. We get the **liquidity**, **sqrtPrice** and **tick** directly from the blockchain by calling `liquidity()`and `slot0()` on the Pool contract:

```typescript
const [liquidity, slot0] =
  await Promise.all([
    poolContract.liquidity(),
    poolContract.slot0(),
  ])
```



The [slot0 function](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState#slot0) represents the first (0th) storage slot of the pool and exposes multiple useful values in a single function:

```solidity
  function slot0(
  ) external view returns (
    uint160 sqrtPriceX96, 
    int24 tick, 
    uint16 observationIndex, 
    uint16 observationCardinality, 
    uint16 observationCardinalityNext, 
    uint8 feeProtocol, 
    bool unlocked
  )
```



For our use case, we only need the `sqrtPriceX96` and the currently active `tick`.

## Fetching all Ticks

V3 pools use ticks to [concentrate liquidity](https://docs.uniswap.org/concepts/protocol/concentrated-liquidity) in price ranges and allow for better pricing of trades. Even though most Pools only have a couple of **initialized ticks**, it is possible that a pools liquidity is defined by thousands of **initialized ticks**. In that case, it can be very expensive or slow to get all of them with normal RPC calls.

If you are not familiar with the concept of ticks, check out the [`introduction`](https://docs.uniswap.org/sdk/v3/guides/advanced/introduction).

To access tick data, we will use the `ticks` function of the V3 Pool contract:

```solidity
  function ticks(
    int24 tick
  ) external view returns (
    uint128 liquidityGross, 
    int128 liquidityNet, 
    uint256 feeGrowthOutside0X128, 
    uint256 feeGrowthOutside1X128, 
    int56 tickCumulativeOutside, 
    uint160 secondsPerLiquidityOutsideX128, 
    uint32 secondsOutside, 
    bool initialized
  )
```



The `tick` parameter that we provide the function with is the **index** (memory position) of the Tick we are trying to fetch. To get the indices of all initialized Ticks of the Pool, we can calculate them from the **tickBitmaps**. To fetch a `tickBitmap` function of the V3 Pool:

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```



A pool stores lots of bitmaps, each of which contain the status of 256 Ticks. The parameter `int16 wordPosition` the function accepts is the position of the bitMap we want to fetch. We can calculate all the position of bitMaps (or words as they are sometimes called) from the `tickSpacing` of the Pool, which is in turn dependant on the Fee tier.

So to summarise we need 4 steps to fetch all initialized ticks:

1. Calculate all bitMap positions from the tickSpacing of the Pool.
2. Fetch all bitMaps using their positions.
3. Calculate the memory positions of all Ticks from the bitMaps.
4. Fetch all Ticks by their memory position.

We will use multicalls for the fetch calls.

## Multicall

Multicall contracts **aggregate results** from multiple contract calls and therefore allow sending multiple contract calls in **one RPC request**. This can improve the **speed** of fetching large amounts of data significantly and ensures that the data fetched is all from the **same block**.

We will use the Multicall2 contract by MakerDAO. We use the `ethers-muticall` npm package to easily interact with the Contract.

## Calculating all bitMap positions

As mentioned, Uniswap V3 Pools store **bitmaps**, also called *words*, that represent the state of **256 initializable ticks** at a time. The value at a bit of a word is 1 if the tick at this index is initialized and 0 if it isn't. We can calculate the positions of initialized ticks from the **words** of the Pool.

All ticks of Uniswap V3 pools are between the indices `-887272` and `887272`. We can calculate the minimum and maximum word from these indices and the Pool's tickSpacing:

```typescript
function tickToWord(tick: number): number {
  let compressed = Math.floor(tick / tickSpacing)
  if (tick < 0 && tick % tickSpacing !== 0) {
    compressed -= 1
  }
  return compressed >> 8
}

const minWord = tickToWord(-887272)
const maxWord = tickToWord(887272)
```



Ticks can only be initialized at indices that are **divisible by the tickSpacing**. One word contains 256 ticks, so we can compress the ticks by right shifting 8 bit.

## Fetching bitMaps from their position

Knowing the positions of words in the Pool contract, we can now fetch them from the Pool using multicall and the `tickBitmap` read call.

First we initialize our multicall providers and Pool Contract:

```typescript
import { ethers } from 'ethers'
import { Contract, Provider } from 'ethers-multicall'

const ethersProvider = new ethers.providers.JsonRpcProvider("...rpcUrl")
const multicallProvider = new Provider(ethersProvider)
await multicallProvider.init()

const poolContract = new Contract(poolAddress, IUniswapV3PoolABI.abi)
```



The `multicallProvider` creates the multicall request and sends it via the ethers Provider.

Next we loop through all possible word positions and add a `tickBitmap` call for each:

```typescript
let calls: any[] = []
let wordPosIndices: number[] = []
for (let i = minWord; i <= maxWord; i++) {
  wordPosIndices.push(i)
  calls.push(poolContract.tickBitmap(i))
}
```



We also keep track of the word position indices to be able to loop through them in the same order we added the calls to the array.

We use the `multicallProvider.all()` function to send a multicall and map the results:

```typescript
const results: bigint[] = (await multicallProvider.all(calls)).map(
    (ethersResponse) => {
      return BigInt(ethersResponse.toString())
    }
  )
```



A great visualization of what the bitMaps look like can be found in the [Uniswap V3 development book](https://uniswapv3book.com/milestone_2/tick-bitmap-index.html):

![TickBitmap](https://docs.uniswap.org/assets/images/tickBitmap_cut-0657ffe617e53a11e38397e09300fe73.png)

We encourage anyone trying to get a deeper understanding of the Uniswap protocol to read the Uniswap V3 Book.

## Calculating the memory positions of all Ticks

Now that we fetched all **bitMaps**, we check which ticks are initialized and calculate the **tick position** from the **word index** and the **tickSpacing** of the pool.

We check if a tick is **initialized** inside the word by shifting a bit by the index we are looking at and performing a bitwise AND operation:

```typescript
const bit = 1n
const initialized = (bitmap & (bit << BigInt(i))) !== 0n
```



If the tick is **initialized**, we revert the compression from tick to word we made earlier by multiplying the word index with 256, which is the same as left shifting by 8 bit, adding the position we are currently at, and multiplying with the tickSpacing:

```typescript
const tickIndex = (ind * 256 + i) * tickSpacing
```



The whole loop looks like this:

```typescript
const tickIndices: number[] = []

  for (let j = 0; j < wordPosIndices.length; j++) {
    const ind = wordPosIndices[j]
    const bitmap = results[j]

    if (bitmap !== 0n) {
      for (let i = 0; i < 256; i++) {
        const bit = 1n
        const initialized = (bitmap & (bit << BigInt(i))) !== 0n
        if (initialized) {
          const tickIndex = (ind * 256 + i) * tickSpacing
          tickIndices.push(tickIndex)
        }
      }
    }
  }
```



We now have an array containing the indices of all initialized Ticks.

## Fetching all Ticks by their indices

We use the multicallProvider again to execute an aggregated read call for all tick indices. We create an array of call Promises again and use `.all()` to make our multicall:

```typescript
const calls: any[] = []

for (const index of tickIndices) {
  calls.push(poolContract.ticks(index))
}

const results = await multicallProvider.all(calls)
```



Again, the order of the results array is the same as the elements in **tickIndices**.

We are able to combine the **tickIndices** and **results** array to create an array of `Tick` objects:

```typescript
const allTicks: Tick[] = []

  for (let i = 0; i < tickIndices.length; i++) {
    const index = tickIndices[i]
    const ethersResponse = results[i]
    const tick = new Tick({
      index,
      liquidityGross: JSBI.BigInt(ethersResponse.liquidityGross.toString()),
      liquidityNet: JSBI.BigInt(ethersResponse.liquidityNet.toString()),
    })
    allTicks.push(tick)
  }
```



We need to parse the response from our RPC provider to JSBI values that the v3-sdk can work with.

## Constructing the Pool

We have everything to construct our `Pool` now:

```typescript
const usdcWethPool = new Pool(
    USDC,
    WETH,
    feeAmount,
    slot0.sqrtPriceX96,
    liquidity,
    slot0.tick,
    allTicks
)
```



With this fully initialized Pool, we can make accurate offchain calculations.

## Next Steps

Now that you are familiar with fetching Pool data, continue your journey with the [next example](https://docs.uniswap.org/sdk/v3/guides/advanced/active-liquidity) on visualizing the Liquidity density of a pool.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesAdvanced[Active Liquidity](https://docs.uniswap.org/sdk/v3/guides/advanced/active-liquidity)

# Active Liquidity

## Introduction

This guide will cover how to fetch and compute the active liquidity in the specific Tick ranges of a pool. It is based on the [Liquidity Density example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data) and can be seen used in production, albeit in a more sophisticated way, in the [Uniswap Analytics](https://info.uniswap.org/#/pools) website.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this guide, we will use the V3 subgraph to fetch all ticks from **theGraph** and compute the active liquidity our Pool can use at each Tick. We then use `recharts` to draw a chart that visualizes our Pool's liqudity density.

This guide will cover:

1. Getting the tickSpacing and currently active Tick from the Pool
2. Calculating active liquidity from net liquidity
3. Drawing a chart from the Tick data

This guide will not cover:

- Specifics of working with the recharts library. You can read more about that [here](https://recharts.org/en-US/).

At the end of the guide, we should be able to visualize the liquidity of any V3 Pool.

## Understanding Active Liquidity

To visualize the distribution of active liquidity in our Pool, we want to draw our Chart around the currently active Tick. For that we have to first understand:

- What is an initialized Tick?
- What is the current Tick?

### Initialized Ticks

When providing liquidity for a pool, the LP decides the **price range** in which the liquidity should be provided, and the amount of liquidity to be provided. The pool understands the position as **liquidity between the lower and upper Tick**. The Tick Index in this context is a representation of the price between the Pool's assets.

Looking at this [visualization](https://www.desmos.com/calculator/oduetjzfp4) of multiple positions in a V3 Pool, we can see that the liquidity available for a swap does not change inside a position, but when crossing into the next position. This is what the **Initialized Ticks** of a Pool represent - they are a representation of the start or end of one or more positions.

![LiquidityNet1](https://docs.uniswap.org/assets/images/liquidityNetComparison-78ca8c6429f5794274f7ed80323a5db7.png)

When entering or leaving a position, its liquidity is added or removed from the **active liquidity available** for a Swap. The initialized Ticks store this **change in available liquidity** in the `liquidityNet` field. The change is always stored in relation to the currently active Tick - the current price. When the price crosses an initialized Tick, it gets updated and liqudity that was previously added when crossing the Tick would now be removed and vice versa.

The `liquidityGross` value represents the gross value of liquidity referencing the tick. This is important for the edge case that one position ends at a Tick and a second position with exactly the same liquidity value would start at the Tick. In this case `liquidityNet` would be **0** but `liquidityGross` would still have a value, which ensures that the Tick is not deleted from the Pool.

To visualize liquidity in a graph, we will only need to consider the changes, so it's sufficient to fetch the Ticks with `liquidityNet` not 0.

### Fetching initialized Ticks

To fetch all ticks of our Pool, we will use the [Uniswap V3 graph](https://docs.uniswap.org/api/subgraph/overview). To visualize active liquidity, we need the **tickIdx**, the **liquidityGross** and the **liquidityNet**.

We define our GraphQL query and [send a POST request](https://axios-http.com/docs/post_example) to the V3 subgraph API endpoint:

```typescript
axios.post(
        "https://gateway.thegraph.com/api/${api_key}/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
        {"query": `{ ticks(
              where: {poolAddress: "${poolAddress.toLowerCase()}", liquidityNet_not: "0"}
              first: 1000,
              skip: ${skip},
              orderBy: tickIdx,
              orderDirection: asc
            ) {
              tickIdx
              liquidityGross
              liquidityNet
            }
          }`
        },
        {
            headers: {
                "Content-Type": "application/json"
            }
        }
    )
```



We only fetch the ticks that **have liquidity**, and we convert the poolAddress to **lower case** for the subgraph to work with. To make sure the Ticks are ordered correctly, we also define the **order direction** in the query.

note

GraphQL is only able to fetch 1000 records at a time. If a pool has more than 1000 initialized ticks, multiple calls are necessary to get all of them.

The ticks we got from **theGraph** have this format:

```typescript
interface GraphTick {
    tickIdx: string
    liquidityGross: string
    liquidityNet: string
}
```



### Current Tick

The current Tick of the Pool represents the **current Price** after the last swap. Considering that the initialized Ticks only represent positions, we see that it is not necessarily one of the initialized Ticks but can be at any point in between them. The active liqudity at the current Price is also stored in the smart contract - we already fetched it with the `liquidity` function in the [previous guide](https://docs.uniswap.org/sdk/v3/guides/advanced/pool-data).

### Tickspacing

Only the Ticks with indices that are divisible with 0 remainder by the tickspacing of a Pool are initializable. This is a convention defined by the protocol to save gas. The Tickspacing of the Pool is dependent on the Fee Tier. Pools with lower fees are meant to be used for more stable Token Pairs and allow for more granularity in where LPs position their liquidity.

We can get the `tickSpacing` from the `TICK_SPACINGS` enum exposed by the `v3-sdk`:

```typescript
import { TICK_SPACINGS }

const tickSpacing = TICK_SPACINGS[fee]
```



Alternatively, if we have already constructed a `Pool` object, we could just call `Pool.tickSpacing()`.

### Putting it all together

For the purpose of visualizing the liquidity density of the Pool, it rarely makes sense to display the full Tick Range of the Pool, as the vast majority of liquidity will be focused in a narrow price range.

Instead, we will display a sensible number of Ticks around the current price.

## Calculating active liquidity

We know the spacing between Ticks and the Initialized Ticks where active liquidity changes. All we have to do is start calculating from the current Tick and iterate outwards.

The code mentioned in the following snippets can be found in [`active-liquidity.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

To draw our chart we want a data structure that looks something like this:

```typescript
interface TickProcessed {
    tickIdx: number,
    liquidityActive: JSBI,
    liquidityNet: JSBI,
    price0: string,
    price1: string,
    isCurrent: boolean
}
```



To access the initialized Ticks directly from their Tick Index, we store them in a [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type):

```typescript
const tickIdxToTickDictionary: Record<string, GraphTick> = Object.fromEntries(
    ticks.map((graphTick) => [graphTick.tickIdx, graphTick])
  ) 
```



The `ticks` variable in this code snippet is the result we got from the V3 Subgraph earlier.

We want to mark the Tick closest to the current Price and we want to be able to display the prices at a Tick to the user. We calculate the **initializable Tick** closest to the current price and create the active Tick that we start from:

```typescript
import { tickToPrice } from '@uniswap/v3-sdk'

const activeTickIdx = Math.floor(pool.tickCurrent / tickSpacing) * tickSpacing

const activeTickProcessed: TickProcessed = {
    tickIdx: activeTickIdx,
    liquidityActive: pool.liquidity,
    liquidityNet: JSBI.BigInt(0),
    price0: tickToPrice(tokenA, tokenB, activeTickIdx).toFixed(6),
    price1: tickToPrice(tokenB, tokenA, activeTickIdx).toFixed(6),
    isCurrent: true
}
```



Here we also calculate the price of the tokens from the tickIdx, the `v3-sdk` exports a handy utility function for that, `tickToPrice`. We store the Price as a string as we won't make any further calculations in this example. We will instead use it to display prices in the tooltip of our chart. Notice how the `price0` is the Price of tokenA in terms of tokenB and the `price1` is the Price of tokenB in terms of tokenA **at the specified Tick**.

If the **current Tick is initialized**, we also need to set the **liquidityNet** to correctly handle moving out of the position:

```typescript
const currentTickInitialized = tickIdxToTickDictionary[activeTickIdx]
if (currentTickInitialized !== undefined) {
    activeTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
}
```



We now start iterating outwards from the active Tick and compute the active liquidity for each Tick we want to display. The processed Tick is then saved in an Array of `TickProcessed`. We choose an arbitrary number of Ticks we want to display, for this example we calculate 100 Ticks in each direction.

```typescript
import { TickMath, tickToPrice } from '@uniswap/v3-sdk'

let previousTickProcessed = {
    ...activeTickProcessed
}

processedTicks: TickProcessed[] = []

for (let i = 0; i < 100; i++) {
    const currentTickIdx = previousTickProcessed.tickIdx + tickSpacing

    if (currentTickIdx > TickMath.MAX_TICK) {
        break
    }

    const currentTickProcessed = {
        liquidityActive: previousTickProcessed.liquidityActive,
        tickIdx: currentTickIdx,
        liquidityNet: JSBI.BigInt(0),
        price0: tickToPrice(token0, token1, currentTickIdx),
        price1: tickToPrice(token1, token0, currentTickIdx),
        isActive: false
    }
    
    ...
}
```



We calculate one Tick at a time, and we need to make sure our Tick stays inside the possible price range by checking against `TickMath.MAX_TICK`. Again, we check if our current Tick is initialized and if so, recalculate the active liquidity:

```typescript
for (let i = 0; i < 100; i++) {

    ...

    const currentTickInitialized = tickIdxToTickDictionary[currentTickIdx]

    if (currentTickInitialized !== undefined) {
        currentTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
        currentTickProcessed.liquidityActive = JSBI.add(
            previousTickProcessed.liquidityActive,
            JSBI.BigInt(currentTickInitialized.liquidityNet)
        )
    }

    processedTicks.push(currentTickProcessed)
    previousTickProcessed = currentTickProcessed
}
```



After we are done calculating the next 100 Ticks after the current Tick, we iterate in the opposite direction for the previous Ticks. Iterating downwards, we need to subtract the net liquidity where we added it when iterating upwards. You can find a full code example in the [Uniswap Example repository](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

We are finally able to combine the previous, active and subsequent Ticks:

```typescript
const allProcessedTicks = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)
```



## Drawing the Chart

We are done with our calculations and move on to displaying the data. **Recharts** is not able to handle JSBI, so we need to convert the Array we created to a format it can handle:

```typescript
const chartTicks: TicksChart[] = allProcessedTicks.map((tickProcessed) => {
    return {...processedTick, liquidityActiveChart: parseFloat(tickProcessed.liquidityActive.toString())}
})
```



The loss of precision will not be visually noticeable in the chart and we are still able to display the exact number in a Tooltip if we wish to. Liquidity is stored in a `uint128` format onchain, so the maximum loss of precision will be far smaller than the number of decimals of almost any ERC20 Token.

Finally, we draw the Chart:

```jsx
<ResponsiveContainer width="80%" height={400}>
    <BarChart>
        <XAxis />
        <YAxis />
        <Bar dataKey="liquidityActiveChart" fill="#2172E5">
            {chartTicks.map((entry, index) => {
                return (
                <Cell
                   key={`cell-${index}`}
                   fill={entry.isActive ? '#F51E87' : '#2172E5'}
                />
                )
            })}
        </Bar>
    </BarChart>
</ResponsiveContainer>
```



In a real application, you will probably want to format the chart properly and display additional information for users. Check out the full [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts) to this guide and the official recharts [documentation](https://recharts.org/).

You can also take a look at the [Uniswap Info](https://github.com/Uniswap/v3-info) repository to see a similar chart used in production.

## Locked Liquidity

If you run the example, you will notice that the chart also displays a custom tooltip with additional information that we didn't touch on in this example. The total locked liqudity in the tooltip represents the sum of positions in the currency locked at the selected Tick. It is calculated as the maximum token output of a swap when crossing to the next Tick. The V3 pool here is initialized with only the liquidity of the current Tick.

Depending on your use case, it may make sense to display this value. You can find the full code in the [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

## Next Steps

Now that you are familiar with liquidity data, consider checking out our [next guide](https://docs.uniswap.org/sdk/v3/guides/advanced/price-oracle) on using Uniswap as a Price Oracle.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesAdvanced[Active Liquidity](https://docs.uniswap.org/sdk/v3/guides/advanced/active-liquidity)

# Active Liquidity

## Introduction

This guide will cover how to fetch and compute the active liquidity in the specific Tick ranges of a pool. It is based on the [Liquidity Density example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data) and can be seen used in production, albeit in a more sophisticated way, in the [Uniswap Analytics](https://info.uniswap.org/#/pools) website.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this guide, we will use the V3 subgraph to fetch all ticks from **theGraph** and compute the active liquidity our Pool can use at each Tick. We then use `recharts` to draw a chart that visualizes our Pool's liqudity density.

This guide will cover:

1. Getting the tickSpacing and currently active Tick from the Pool
2. Calculating active liquidity from net liquidity
3. Drawing a chart from the Tick data

This guide will not cover:

- Specifics of working with the recharts library. You can read more about that [here](https://recharts.org/en-US/).

At the end of the guide, we should be able to visualize the liquidity of any V3 Pool.

## Understanding Active Liquidity

To visualize the distribution of active liquidity in our Pool, we want to draw our Chart around the currently active Tick. For that we have to first understand:

- What is an initialized Tick?
- What is the current Tick?

### Initialized Ticks

When providing liquidity for a pool, the LP decides the **price range** in which the liquidity should be provided, and the amount of liquidity to be provided. The pool understands the position as **liquidity between the lower and upper Tick**. The Tick Index in this context is a representation of the price between the Pool's assets.

Looking at this [visualization](https://www.desmos.com/calculator/oduetjzfp4) of multiple positions in a V3 Pool, we can see that the liquidity available for a swap does not change inside a position, but when crossing into the next position. This is what the **Initialized Ticks** of a Pool represent - they are a representation of the start or end of one or more positions.

![LiquidityNet1](https://docs.uniswap.org/assets/images/liquidityNetComparison-78ca8c6429f5794274f7ed80323a5db7.png)

When entering or leaving a position, its liquidity is added or removed from the **active liquidity available** for a Swap. The initialized Ticks store this **change in available liquidity** in the `liquidityNet` field. The change is always stored in relation to the currently active Tick - the current price. When the price crosses an initialized Tick, it gets updated and liqudity that was previously added when crossing the Tick would now be removed and vice versa.

The `liquidityGross` value represents the gross value of liquidity referencing the tick. This is important for the edge case that one position ends at a Tick and a second position with exactly the same liquidity value would start at the Tick. In this case `liquidityNet` would be **0** but `liquidityGross` would still have a value, which ensures that the Tick is not deleted from the Pool.

To visualize liquidity in a graph, we will only need to consider the changes, so it's sufficient to fetch the Ticks with `liquidityNet` not 0.

### Fetching initialized Ticks

To fetch all ticks of our Pool, we will use the [Uniswap V3 graph](https://docs.uniswap.org/api/subgraph/overview). To visualize active liquidity, we need the **tickIdx**, the **liquidityGross** and the **liquidityNet**.

We define our GraphQL query and [send a POST request](https://axios-http.com/docs/post_example) to the V3 subgraph API endpoint:

```typescript
axios.post(
        "https://gateway.thegraph.com/api/${api_key}/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
        {"query": `{ ticks(
              where: {poolAddress: "${poolAddress.toLowerCase()}", liquidityNet_not: "0"}
              first: 1000,
              skip: ${skip},
              orderBy: tickIdx,
              orderDirection: asc
            ) {
              tickIdx
              liquidityGross
              liquidityNet
            }
          }`
        },
        {
            headers: {
                "Content-Type": "application/json"
            }
        }
    )
```



We only fetch the ticks that **have liquidity**, and we convert the poolAddress to **lower case** for the subgraph to work with. To make sure the Ticks are ordered correctly, we also define the **order direction** in the query.

note

GraphQL is only able to fetch 1000 records at a time. If a pool has more than 1000 initialized ticks, multiple calls are necessary to get all of them.

The ticks we got from **theGraph** have this format:

```typescript
interface GraphTick {
    tickIdx: string
    liquidityGross: string
    liquidityNet: string
}
```



### Current Tick

The current Tick of the Pool represents the **current Price** after the last swap. Considering that the initialized Ticks only represent positions, we see that it is not necessarily one of the initialized Ticks but can be at any point in between them. The active liqudity at the current Price is also stored in the smart contract - we already fetched it with the `liquidity` function in the [previous guide](https://docs.uniswap.org/sdk/v3/guides/advanced/pool-data).

### Tickspacing

Only the Ticks with indices that are divisible with 0 remainder by the tickspacing of a Pool are initializable. This is a convention defined by the protocol to save gas. The Tickspacing of the Pool is dependent on the Fee Tier. Pools with lower fees are meant to be used for more stable Token Pairs and allow for more granularity in where LPs position their liquidity.

We can get the `tickSpacing` from the `TICK_SPACINGS` enum exposed by the `v3-sdk`:

```typescript
import { TICK_SPACINGS }

const tickSpacing = TICK_SPACINGS[fee]
```



Alternatively, if we have already constructed a `Pool` object, we could just call `Pool.tickSpacing()`.

### Putting it all together

For the purpose of visualizing the liquidity density of the Pool, it rarely makes sense to display the full Tick Range of the Pool, as the vast majority of liquidity will be focused in a narrow price range.

Instead, we will display a sensible number of Ticks around the current price.

## Calculating active liquidity

We know the spacing between Ticks and the Initialized Ticks where active liquidity changes. All we have to do is start calculating from the current Tick and iterate outwards.

The code mentioned in the following snippets can be found in [`active-liquidity.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

To draw our chart we want a data structure that looks something like this:

```typescript
interface TickProcessed {
    tickIdx: number,
    liquidityActive: JSBI,
    liquidityNet: JSBI,
    price0: string,
    price1: string,
    isCurrent: boolean
}
```



To access the initialized Ticks directly from their Tick Index, we store them in a [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type):

```typescript
const tickIdxToTickDictionary: Record<string, GraphTick> = Object.fromEntries(
    ticks.map((graphTick) => [graphTick.tickIdx, graphTick])
  ) 
```



The `ticks` variable in this code snippet is the result we got from the V3 Subgraph earlier.

We want to mark the Tick closest to the current Price and we want to be able to display the prices at a Tick to the user. We calculate the **initializable Tick** closest to the current price and create the active Tick that we start from:

```typescript
import { tickToPrice } from '@uniswap/v3-sdk'

const activeTickIdx = Math.floor(pool.tickCurrent / tickSpacing) * tickSpacing

const activeTickProcessed: TickProcessed = {
    tickIdx: activeTickIdx,
    liquidityActive: pool.liquidity,
    liquidityNet: JSBI.BigInt(0),
    price0: tickToPrice(tokenA, tokenB, activeTickIdx).toFixed(6),
    price1: tickToPrice(tokenB, tokenA, activeTickIdx).toFixed(6),
    isCurrent: true
}
```



Here we also calculate the price of the tokens from the tickIdx, the `v3-sdk` exports a handy utility function for that, `tickToPrice`. We store the Price as a string as we won't make any further calculations in this example. We will instead use it to display prices in the tooltip of our chart. Notice how the `price0` is the Price of tokenA in terms of tokenB and the `price1` is the Price of tokenB in terms of tokenA **at the specified Tick**.

If the **current Tick is initialized**, we also need to set the **liquidityNet** to correctly handle moving out of the position:

```typescript
const currentTickInitialized = tickIdxToTickDictionary[activeTickIdx]
if (currentTickInitialized !== undefined) {
    activeTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
}
```



We now start iterating outwards from the active Tick and compute the active liquidity for each Tick we want to display. The processed Tick is then saved in an Array of `TickProcessed`. We choose an arbitrary number of Ticks we want to display, for this example we calculate 100 Ticks in each direction.

```typescript
import { TickMath, tickToPrice } from '@uniswap/v3-sdk'

let previousTickProcessed = {
    ...activeTickProcessed
}

processedTicks: TickProcessed[] = []

for (let i = 0; i < 100; i++) {
    const currentTickIdx = previousTickProcessed.tickIdx + tickSpacing

    if (currentTickIdx > TickMath.MAX_TICK) {
        break
    }

    const currentTickProcessed = {
        liquidityActive: previousTickProcessed.liquidityActive,
        tickIdx: currentTickIdx,
        liquidityNet: JSBI.BigInt(0),
        price0: tickToPrice(token0, token1, currentTickIdx),
        price1: tickToPrice(token1, token0, currentTickIdx),
        isActive: false
    }
    
    ...
}
```



We calculate one Tick at a time, and we need to make sure our Tick stays inside the possible price range by checking against `TickMath.MAX_TICK`. Again, we check if our current Tick is initialized and if so, recalculate the active liquidity:

```typescript
for (let i = 0; i < 100; i++) {

    ...

    const currentTickInitialized = tickIdxToTickDictionary[currentTickIdx]

    if (currentTickInitialized !== undefined) {
        currentTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
        currentTickProcessed.liquidityActive = JSBI.add(
            previousTickProcessed.liquidityActive,
            JSBI.BigInt(currentTickInitialized.liquidityNet)
        )
    }

    processedTicks.push(currentTickProcessed)
    previousTickProcessed = currentTickProcessed
}
```



After we are done calculating the next 100 Ticks after the current Tick, we iterate in the opposite direction for the previous Ticks. Iterating downwards, we need to subtract the net liquidity where we added it when iterating upwards. You can find a full code example in the [Uniswap Example repository](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

We are finally able to combine the previous, active and subsequent Ticks:

```typescript
const allProcessedTicks = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)
```



## Drawing the Chart

We are done with our calculations and move on to displaying the data. **Recharts** is not able to handle JSBI, so we need to convert the Array we created to a format it can handle:

```typescript
const chartTicks: TicksChart[] = allProcessedTicks.map((tickProcessed) => {
    return {...processedTick, liquidityActiveChart: parseFloat(tickProcessed.liquidityActive.toString())}
})
```



The loss of precision will not be visually noticeable in the chart and we are still able to display the exact number in a Tooltip if we wish to. Liquidity is stored in a `uint128` format onchain, so the maximum loss of precision will be far smaller than the number of decimals of almost any ERC20 Token.

Finally, we draw the Chart:

```jsx
<ResponsiveContainer width="80%" height={400}>
    <BarChart>
        <XAxis />
        <YAxis />
        <Bar dataKey="liquidityActiveChart" fill="#2172E5">
            {chartTicks.map((entry, index) => {
                return (
                <Cell
                   key={`cell-${index}`}
                   fill={entry.isActive ? '#F51E87' : '#2172E5'}
                />
                )
            })}
        </Bar>
    </BarChart>
</ResponsiveContainer>
```



In a real application, you will probably want to format the chart properly and display additional information for users. Check out the full [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts) to this guide and the official recharts [documentation](https://recharts.org/).

You can also take a look at the [Uniswap Info](https://github.com/Uniswap/v3-info) repository to see a similar chart used in production.

## Locked Liquidity

If you run the example, you will notice that the chart also displays a custom tooltip with additional information that we didn't touch on in this example. The total locked liqudity in the tooltip represents the sum of positions in the currency locked at the selected Tick. It is calculated as the maximum token output of a swap when crossing to the next Tick. The V3 pool here is initialized with only the liquidity of the current Tick.

Depending on your use case, it may make sense to display this value. You can find the full code in the [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

## Next Steps

Now that you are familiar with liquidity data, consider checking out our [next guide](https://docs.uniswap.org/sdk/v3/guides/advanced/price-oracle) on using Uniswap as a Price Oracle.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKGuidesAdvanced[Active Liquidity](https://docs.uniswap.org/sdk/v3/guides/advanced/active-liquidity)

# Active Liquidity

## Introduction

This guide will cover how to fetch and compute the active liquidity in the specific Tick ranges of a pool. It is based on the [Liquidity Density example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data) and can be seen used in production, albeit in a more sophisticated way, in the [Uniswap Analytics](https://info.uniswap.org/#/pools) website.

info

If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](https://docs.uniswap.org/sdk/v3/guides/background) page!

In this guide, we will use the V3 subgraph to fetch all ticks from **theGraph** and compute the active liquidity our Pool can use at each Tick. We then use `recharts` to draw a chart that visualizes our Pool's liqudity density.

This guide will cover:

1. Getting the tickSpacing and currently active Tick from the Pool
2. Calculating active liquidity from net liquidity
3. Drawing a chart from the Tick data

This guide will not cover:

- Specifics of working with the recharts library. You can read more about that [here](https://recharts.org/en-US/).

At the end of the guide, we should be able to visualize the liquidity of any V3 Pool.

## Understanding Active Liquidity

To visualize the distribution of active liquidity in our Pool, we want to draw our Chart around the currently active Tick. For that we have to first understand:

- What is an initialized Tick?
- What is the current Tick?

### Initialized Ticks

When providing liquidity for a pool, the LP decides the **price range** in which the liquidity should be provided, and the amount of liquidity to be provided. The pool understands the position as **liquidity between the lower and upper Tick**. The Tick Index in this context is a representation of the price between the Pool's assets.

Looking at this [visualization](https://www.desmos.com/calculator/oduetjzfp4) of multiple positions in a V3 Pool, we can see that the liquidity available for a swap does not change inside a position, but when crossing into the next position. This is what the **Initialized Ticks** of a Pool represent - they are a representation of the start or end of one or more positions.

![LiquidityNet1](https://docs.uniswap.org/assets/images/liquidityNetComparison-78ca8c6429f5794274f7ed80323a5db7.png)

When entering or leaving a position, its liquidity is added or removed from the **active liquidity available** for a Swap. The initialized Ticks store this **change in available liquidity** in the `liquidityNet` field. The change is always stored in relation to the currently active Tick - the current price. When the price crosses an initialized Tick, it gets updated and liqudity that was previously added when crossing the Tick would now be removed and vice versa.

The `liquidityGross` value represents the gross value of liquidity referencing the tick. This is important for the edge case that one position ends at a Tick and a second position with exactly the same liquidity value would start at the Tick. In this case `liquidityNet` would be **0** but `liquidityGross` would still have a value, which ensures that the Tick is not deleted from the Pool.

To visualize liquidity in a graph, we will only need to consider the changes, so it's sufficient to fetch the Ticks with `liquidityNet` not 0.

### Fetching initialized Ticks

To fetch all ticks of our Pool, we will use the [Uniswap V3 graph](https://docs.uniswap.org/api/subgraph/overview). To visualize active liquidity, we need the **tickIdx**, the **liquidityGross** and the **liquidityNet**.

We define our GraphQL query and [send a POST request](https://axios-http.com/docs/post_example) to the V3 subgraph API endpoint:

```typescript
axios.post(
        "https://gateway.thegraph.com/api/${api_key}/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
        {"query": `{ ticks(
              where: {poolAddress: "${poolAddress.toLowerCase()}", liquidityNet_not: "0"}
              first: 1000,
              skip: ${skip},
              orderBy: tickIdx,
              orderDirection: asc
            ) {
              tickIdx
              liquidityGross
              liquidityNet
            }
          }`
        },
        {
            headers: {
                "Content-Type": "application/json"
            }
        }
    )
```



We only fetch the ticks that **have liquidity**, and we convert the poolAddress to **lower case** for the subgraph to work with. To make sure the Ticks are ordered correctly, we also define the **order direction** in the query.

note

GraphQL is only able to fetch 1000 records at a time. If a pool has more than 1000 initialized ticks, multiple calls are necessary to get all of them.

The ticks we got from **theGraph** have this format:

```typescript
interface GraphTick {
    tickIdx: string
    liquidityGross: string
    liquidityNet: string
}
```



### Current Tick

The current Tick of the Pool represents the **current Price** after the last swap. Considering that the initialized Ticks only represent positions, we see that it is not necessarily one of the initialized Ticks but can be at any point in between them. The active liqudity at the current Price is also stored in the smart contract - we already fetched it with the `liquidity` function in the [previous guide](https://docs.uniswap.org/sdk/v3/guides/advanced/pool-data).

### Tickspacing

Only the Ticks with indices that are divisible with 0 remainder by the tickspacing of a Pool are initializable. This is a convention defined by the protocol to save gas. The Tickspacing of the Pool is dependent on the Fee Tier. Pools with lower fees are meant to be used for more stable Token Pairs and allow for more granularity in where LPs position their liquidity.

We can get the `tickSpacing` from the `TICK_SPACINGS` enum exposed by the `v3-sdk`:

```typescript
import { TICK_SPACINGS }

const tickSpacing = TICK_SPACINGS[fee]
```



Alternatively, if we have already constructed a `Pool` object, we could just call `Pool.tickSpacing()`.

### Putting it all together

For the purpose of visualizing the liquidity density of the Pool, it rarely makes sense to display the full Tick Range of the Pool, as the vast majority of liquidity will be focused in a narrow price range.

Instead, we will display a sensible number of Ticks around the current price.

## Calculating active liquidity

We know the spacing between Ticks and the Initialized Ticks where active liquidity changes. All we have to do is start calculating from the current Tick and iterate outwards.

The code mentioned in the following snippets can be found in [`active-liquidity.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

To draw our chart we want a data structure that looks something like this:

```typescript
interface TickProcessed {
    tickIdx: number,
    liquidityActive: JSBI,
    liquidityNet: JSBI,
    price0: string,
    price1: string,
    isCurrent: boolean
}
```



To access the initialized Ticks directly from their Tick Index, we store them in a [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type):

```typescript
const tickIdxToTickDictionary: Record<string, GraphTick> = Object.fromEntries(
    ticks.map((graphTick) => [graphTick.tickIdx, graphTick])
  ) 
```



The `ticks` variable in this code snippet is the result we got from the V3 Subgraph earlier.

We want to mark the Tick closest to the current Price and we want to be able to display the prices at a Tick to the user. We calculate the **initializable Tick** closest to the current price and create the active Tick that we start from:

```typescript
import { tickToPrice } from '@uniswap/v3-sdk'

const activeTickIdx = Math.floor(pool.tickCurrent / tickSpacing) * tickSpacing

const activeTickProcessed: TickProcessed = {
    tickIdx: activeTickIdx,
    liquidityActive: pool.liquidity,
    liquidityNet: JSBI.BigInt(0),
    price0: tickToPrice(tokenA, tokenB, activeTickIdx).toFixed(6),
    price1: tickToPrice(tokenB, tokenA, activeTickIdx).toFixed(6),
    isCurrent: true
}
```



Here we also calculate the price of the tokens from the tickIdx, the `v3-sdk` exports a handy utility function for that, `tickToPrice`. We store the Price as a string as we won't make any further calculations in this example. We will instead use it to display prices in the tooltip of our chart. Notice how the `price0` is the Price of tokenA in terms of tokenB and the `price1` is the Price of tokenB in terms of tokenA **at the specified Tick**.

If the **current Tick is initialized**, we also need to set the **liquidityNet** to correctly handle moving out of the position:

```typescript
const currentTickInitialized = tickIdxToTickDictionary[activeTickIdx]
if (currentTickInitialized !== undefined) {
    activeTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
}
```



We now start iterating outwards from the active Tick and compute the active liquidity for each Tick we want to display. The processed Tick is then saved in an Array of `TickProcessed`. We choose an arbitrary number of Ticks we want to display, for this example we calculate 100 Ticks in each direction.

```typescript
import { TickMath, tickToPrice } from '@uniswap/v3-sdk'

let previousTickProcessed = {
    ...activeTickProcessed
}

processedTicks: TickProcessed[] = []

for (let i = 0; i < 100; i++) {
    const currentTickIdx = previousTickProcessed.tickIdx + tickSpacing

    if (currentTickIdx > TickMath.MAX_TICK) {
        break
    }

    const currentTickProcessed = {
        liquidityActive: previousTickProcessed.liquidityActive,
        tickIdx: currentTickIdx,
        liquidityNet: JSBI.BigInt(0),
        price0: tickToPrice(token0, token1, currentTickIdx),
        price1: tickToPrice(token1, token0, currentTickIdx),
        isActive: false
    }
    
    ...
}
```



We calculate one Tick at a time, and we need to make sure our Tick stays inside the possible price range by checking against `TickMath.MAX_TICK`. Again, we check if our current Tick is initialized and if so, recalculate the active liquidity:

```typescript
for (let i = 0; i < 100; i++) {

    ...

    const currentTickInitialized = tickIdxToTickDictionary[currentTickIdx]

    if (currentTickInitialized !== undefined) {
        currentTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
        currentTickProcessed.liquidityActive = JSBI.add(
            previousTickProcessed.liquidityActive,
            JSBI.BigInt(currentTickInitialized.liquidityNet)
        )
    }

    processedTicks.push(currentTickProcessed)
    previousTickProcessed = currentTickProcessed
}
```



After we are done calculating the next 100 Ticks after the current Tick, we iterate in the opposite direction for the previous Ticks. Iterating downwards, we need to subtract the net liquidity where we added it when iterating upwards. You can find a full code example in the [Uniswap Example repository](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

We are finally able to combine the previous, active and subsequent Ticks:

```typescript
const allProcessedTicks = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)
```



## Drawing the Chart

We are done with our calculations and move on to displaying the data. **Recharts** is not able to handle JSBI, so we need to convert the Array we created to a format it can handle:

```typescript
const chartTicks: TicksChart[] = allProcessedTicks.map((tickProcessed) => {
    return {...processedTick, liquidityActiveChart: parseFloat(tickProcessed.liquidityActive.toString())}
})
```



The loss of precision will not be visually noticeable in the chart and we are still able to display the exact number in a Tooltip if we wish to. Liquidity is stored in a `uint128` format onchain, so the maximum loss of precision will be far smaller than the number of decimals of almost any ERC20 Token.

Finally, we draw the Chart:

```jsx
<ResponsiveContainer width="80%" height={400}>
    <BarChart>
        <XAxis />
        <YAxis />
        <Bar dataKey="liquidityActiveChart" fill="#2172E5">
            {chartTicks.map((entry, index) => {
                return (
                <Cell
                   key={`cell-${index}`}
                   fill={entry.isActive ? '#F51E87' : '#2172E5'}
                />
                )
            })}
        </Bar>
    </BarChart>
</ResponsiveContainer>
```



In a real application, you will probably want to format the chart properly and display additional information for users. Check out the full [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts) to this guide and the official recharts [documentation](https://recharts.org/).

You can also take a look at the [Uniswap Info](https://github.com/Uniswap/v3-info) repository to see a similar chart used in production.

## Locked Liquidity

If you run the example, you will notice that the chart also displays a custom tooltip with additional information that we didn't touch on in this example. The total locked liqudity in the tooltip represents the sum of positions in the currency locked at the selected Tick. It is calculated as the maximum token output of a swap when crossing to the next Tick. The V3 pool here is initialized with only the liquidity of the current Tick.

Depending on your use case, it may make sense to display this value. You can find the full code in the [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

## Next Steps

Now that you are familiar with liquidity data, consider checking out our [next guide](https://docs.uniswap.org/sdk/v3/guides/advanced/price-oracle) on using Uniswap as a Price Oracle.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Reference[Overview](https://docs.uniswap.org/sdk/v3/reference/overview)

# Overview

## Table of contents

### Enumerations

- [FeeAmount](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount)

### Classes

- [FullMath](https://docs.uniswap.org/sdk/v3/reference/classes/FullMath)
- [LiquidityMath](https://docs.uniswap.org/sdk/v3/reference/classes/LiquidityMath)
- [Multicall](https://docs.uniswap.org/sdk/v3/reference/classes/Multicall)
- [NoTickDataProvider](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider)
- [NonfungiblePositionManager](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager)
- [Payments](https://docs.uniswap.org/sdk/v3/reference/classes/Payments)
- [Pool](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)
- [Position](https://docs.uniswap.org/sdk/v3/reference/classes/Position)
- [PositionLibrary](https://docs.uniswap.org/sdk/v3/reference/classes/PositionLibrary)
- [Route](https://docs.uniswap.org/sdk/v3/reference/classes/Route)
- [SelfPermit](https://docs.uniswap.org/sdk/v3/reference/classes/SelfPermit)
- [SqrtPriceMath](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath)
- [Staker](https://docs.uniswap.org/sdk/v3/reference/classes/Staker)
- [SwapMath](https://docs.uniswap.org/sdk/v3/reference/classes/SwapMath)
- [SwapQuoter](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter)
- [SwapRouter](https://docs.uniswap.org/sdk/v3/reference/classes/SwapRouter)
- [Tick](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)
- [TickLibrary](https://docs.uniswap.org/sdk/v3/reference/classes/TickLibrary)
- [TickList](https://docs.uniswap.org/sdk/v3/reference/classes/TickList)
- [TickListDataProvider](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider)
- [TickMath](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath)
- [Trade](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)

### Interfaces

- [AllowedPermitArguments](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments)
- [BestTradeOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions)
- [ClaimOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions)
- [CollectOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions)
- [CommonAddLiquidityOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions)
- [FeeOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions)
- [IncentiveKey](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey)
- [IncreaseSpecificOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncreaseSpecificOptions)
- [MethodParameters](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)
- [MintSpecificOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/MintSpecificOptions)
- [NFTPermitOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions)
- [QuoteOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/QuoteOptions)
- [RemoveLiquidityOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions)
- [SafeTransferOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions)
- [StandardPermitArguments](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments)
- [SwapOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions)
- [TickConstructorArgs](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs)
- [TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider)
- [WithdrawOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/WithdrawOptions)

### Type Aliases

- [AddLiquidityOptions](https://docs.uniswap.org/sdk/v3/reference/modules.md#addliquidityoptions)
- [FullWithdrawOptions](https://docs.uniswap.org/sdk/v3/reference/modules.md#fullwithdrawoptions)
- [IncreaseOptions](https://docs.uniswap.org/sdk/v3/reference/modules.md#increaseoptions)
- [MintOptions](https://docs.uniswap.org/sdk/v3/reference/modules.md#mintoptions)
- [PermitOptions](https://docs.uniswap.org/sdk/v3/reference/modules.md#permitoptions)

### Variables

- [ADDRESS_ZERO](https://docs.uniswap.org/sdk/v3/reference/modules.md#address_zero)
- [FACTORY_ADDRESS](https://docs.uniswap.org/sdk/v3/reference/modules.md#factory_address)
- [POOL_INIT_CODE_HASH](https://docs.uniswap.org/sdk/v3/reference/modules.md#pool_init_code_hash)
- [TICK_SPACINGS](https://docs.uniswap.org/sdk/v3/reference/modules.md#tick_spacings)

### Functions

- [computePoolAddress](https://docs.uniswap.org/sdk/v3/reference/modules.md#computepooladdress)
- [encodeRouteToPath](https://docs.uniswap.org/sdk/v3/reference/modules.md#encoderoutetopath)
- [encodeSqrtRatioX96](https://docs.uniswap.org/sdk/v3/reference/modules.md#encodesqrtratiox96)
- [isSorted](https://docs.uniswap.org/sdk/v3/reference/modules.md#issorted)
- [maxLiquidityForAmounts](https://docs.uniswap.org/sdk/v3/reference/modules.md#maxliquidityforamounts)
- [mostSignificantBit](https://docs.uniswap.org/sdk/v3/reference/modules.md#mostsignificantbit)
- [nearestUsableTick](https://docs.uniswap.org/sdk/v3/reference/modules.md#nearestusabletick)
- [priceToClosestTick](https://docs.uniswap.org/sdk/v3/reference/modules.md#pricetoclosesttick)
- [subIn256](https://docs.uniswap.org/sdk/v3/reference/modules.md#subin256)
- [tickToPrice](https://docs.uniswap.org/sdk/v3/reference/modules.md#ticktoprice)
- [toHex](https://docs.uniswap.org/sdk/v3/reference/modules.md#tohex)
- [tradeComparator](https://docs.uniswap.org/sdk/v3/reference/modules.md#tradecomparator)

## Type Aliases

### AddLiquidityOptions

Ƭ **AddLiquidityOptions**: [`MintOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#mintoptions) | [`IncreaseOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#increaseoptions)

#### Defined in

[nonfungiblePositionManager.ts:77](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L77)

------

### FullWithdrawOptions

Ƭ **FullWithdrawOptions**: [`ClaimOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions) & [`WithdrawOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/WithdrawOptions)

#### Defined in

[staker.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L8)

------

### IncreaseOptions

Ƭ **IncreaseOptions**: [`CommonAddLiquidityOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions) & [`IncreaseSpecificOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncreaseSpecificOptions)

#### Defined in

[nonfungiblePositionManager.ts:75](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L75)

------

### MintOptions

Ƭ **MintOptions**: [`CommonAddLiquidityOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions) & [`MintSpecificOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MintSpecificOptions)

#### Defined in

[nonfungiblePositionManager.ts:74](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L74)

------

### PermitOptions

Ƭ **PermitOptions**: [`StandardPermitArguments`](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments) | [`AllowedPermitArguments`](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments)

#### Defined in

[selfPermit.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L22)

## Variables

### ADDRESS_ZERO

• `Const` **ADDRESS_ZERO**: `"0x0000000000000000000000000000000000000000"`

#### Defined in

[constants.ts:3](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L3)

------

### FACTORY_ADDRESS

• `Const` **FACTORY_ADDRESS**: `"0x1F98431c8aD98523631AE4a59f267346ea31F984"`

#### Defined in

[constants.ts:1](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L1)

------

### POOL_INIT_CODE_HASH

• `Const` **POOL_INIT_CODE_HASH**: `"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54"`

#### Defined in

[constants.ts:5](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L5)

------

### TICK_SPACINGS

• `Const` **TICK_SPACINGS**: { [amount in FeeAmount]: number }

The default factory tick spacings by fee amount.

#### Defined in

[constants.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L20)

## Functions

### computePoolAddress

▸ **computePoolAddress**(`__namedParameters`): `string`

Computes a pool address

#### Parameters

| Name                                            | Type                                                         |
| :---------------------------------------------- | :----------------------------------------------------------- |
| `__namedParameters`                             | `Object`                                                     |
| `__namedParameters.factoryAddress`              | `string`                                                     |
| `__namedParameters.fee`                         | [`FeeAmount`](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount) |
| `__namedParameters.initCodeHashManualOverride?` | `string`                                                     |
| `__namedParameters.tokenA`                      | `Token`                                                      |
| `__namedParameters.tokenB`                      | `Token`                                                      |

#### Returns

```
string
```

The pool address

#### Defined in

[utils/computePoolAddress.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/computePoolAddress.ts#L16)

------

### encodeRouteToPath

▸ **encodeRouteToPath**(`route`, `exactOutput`): `string`

Converts a route to a hex encoded path

#### Parameters

| Name          | Type                                                         | Description                                                  |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `route`       | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`Currency`, `Currency`> | the v3 path to convert to an encoded path                    |
| `exactOutput` | `boolean`                                                    | whether the route should be encoded in reverse, for making exact output swaps |

#### Returns

```
string
```

#### Defined in

[utils/encodeRouteToPath.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/encodeRouteToPath.ts#L11)

------

### encodeSqrtRatioX96

▸ **encodeSqrtRatioX96**(`amount1`, `amount0`): `JSBI`

Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0

#### Parameters

| Name      | Type        | Description                                       |
| :-------- | :---------- | :------------------------------------------------ |
| `amount1` | `BigintIsh` | The numerator amount i.e., the amount of token1   |
| `amount0` | `BigintIsh` | The denominator amount i.e., the amount of token0 |

#### Returns

```
JSBI
```

The sqrt ratio

#### Defined in

[utils/encodeSqrtRatioX96.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/encodeSqrtRatioX96.ts#L11)

------

### isSorted

▸ **isSorted**<`T`>(`list`, `comparator`): `boolean`

Determines if a tick list is sorted

#### Type parameters

| Name |
| :--- |
| `T`  |

#### Parameters

| Name         | Type                             | Description    |
| :----------- | :------------------------------- | :------------- |
| `list`       | `T`[]                            | The tick list  |
| `comparator` | (`a`: `T`, `b`: `T`) => `number` | The comparator |

#### Returns

```
boolean
```

true if sorted

#### Defined in

[utils/isSorted.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/isSorted.ts#L7)

------

### maxLiquidityForAmounts

▸ **maxLiquidityForAmounts**(`sqrtRatioCurrentX96`, `sqrtRatioAX96`, `sqrtRatioBX96`, `amount0`, `amount1`, `useFullPrecision`): `JSBI`

Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries.

#### Parameters

| Name                  | Type        | Description                                                  |
| :-------------------- | :---------- | :----------------------------------------------------------- |
| `sqrtRatioCurrentX96` | `default`   | the current price                                            |
| `sqrtRatioAX96`       | `default`   | price at lower boundary                                      |
| `sqrtRatioBX96`       | `default`   | price at upper boundary                                      |
| `amount0`             | `BigintIsh` | token0 amount                                                |
| `amount1`             | `BigintIsh` | token1 amount                                                |
| `useFullPrecision`    | `boolean`   | if false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support |

#### Returns

```
JSBI
```

#### Defined in

[utils/maxLiquidityForAmounts.ts:68](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/maxLiquidityForAmounts.ts#L68)

------

### mostSignificantBit

▸ **mostSignificantBit**(`x`): `number`

#### Parameters

| Name | Type      |
| :--- | :-------- |
| `x`  | `default` |

#### Returns

```
number
```

#### Defined in

[utils/mostSignificantBit.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/mostSignificantBit.ts#L12)

------

### nearestUsableTick

▸ **nearestUsableTick**(`tick`, `tickSpacing`): `number`

Returns the closest tick that is nearest a given tick and usable for the given tick spacing

#### Parameters

| Name          | Type     | Description             |
| :------------ | :------- | :---------------------- |
| `tick`        | `number` | the target tick         |
| `tickSpacing` | `number` | the spacing of the pool |

#### Returns

```
number
```

#### Defined in

[utils/nearestUsableTick.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/nearestUsableTick.ts#L9)

------

### priceToClosestTick

▸ **priceToClosestTick**(`price`): `number`

Returns the first tick for which the given price is greater than or equal to the tick price

#### Parameters

| Name    | Type                      | Description                                                  |
| :------ | :------------------------ | :----------------------------------------------------------- |
| `price` | `Price`<`Token`, `Token`> | for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price |

#### Returns

```
number
```

#### Defined in

[utils/priceTickConversions.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/priceTickConversions.ts#L29)

------

### subIn256

▸ **subIn256**(`x`, `y`): `JSBI`

#### Parameters

| Name | Type      |
| :--- | :-------- |
| `x`  | `default` |
| `y`  | `default` |

#### Returns

```
JSBI
```

#### Defined in

[utils/tickLibrary.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L11)

------

### tickToPrice

▸ **tickToPrice**(`baseToken`, `quoteToken`, `tick`): `Price`<`Token`, `Token`>

Returns a price object corresponding to the input tick and the base/quote token Inputs must be tokens because the address order is used to interpret the price represented by the tick

#### Parameters

| Name         | Type     | Description                            |
| :----------- | :------- | :------------------------------------- |
| `baseToken`  | `Token`  | the base token of the price            |
| `quoteToken` | `Token`  | the quote token of the price           |
| `tick`       | `number` | the tick for which to return the price |

#### Returns

`Price`<`Token`, `Token`>

#### Defined in

[utils/priceTickConversions.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/priceTickConversions.ts#L14)

------

### toHex

▸ **toHex**(`bigintIsh`): `string`

Converts a big int to a hex string

#### Parameters

| Name        | Type        |
| :---------- | :---------- |
| `bigintIsh` | `BigintIsh` |

#### Returns

```
string
```

The hex encoded calldata

#### Defined in

[utils/calldata.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L23)

------

### tradeComparator

▸ **tradeComparator**<`TInput`, `TOutput`, `TTradeType`>(`a`, `b`): `number`

Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them

#### Type parameters

| Name         | Type                | Description                                        |
| :----------- | :------------------ | :------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20         |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20        |
| `TTradeType` | extends `TradeType` | The trade type, either exact input or exact output |

#### Parameters

| Name | Type                                                         | Description                 |
| :--- | :----------------------------------------------------------- | :-------------------------- |
| `a`  | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`> | The first trade to compare  |
| `b`  | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`> | The second trade to compare |

#### Returns

```
number
```

A sorted ordering for two neighboring elements in a trade array

#### Defined in

[entities/trade.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L16)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[FullMath](https://docs.uniswap.org/sdk/v3/reference/classes/FullMath)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / FullMath

# Class: FullMath

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/FullMath#constructor)

### Methods

- [mulDivRoundingUp](https://docs.uniswap.org/sdk/v3/reference/classes/FullMath#muldivroundingup)

## Constructors

### constructor

• `Private` **new FullMath**()

Cannot be constructed.

#### Defined in

[utils/fullMath.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/fullMath.ts#L8)

## Methods

### mulDivRoundingUp

▸ `Static` **mulDivRoundingUp**(`a`, `b`, `denominator`): `default`

#### Parameters

| Name          | Type      |
| :------------ | :-------- |
| `a`           | `default` |
| `b`           | `default` |
| `denominator` | `default` |

#### Returns

```
default
```

#### Defined in

[utils/fullMath.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/fullMath.ts#L10)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[LiquidityMath](https://docs.uniswap.org/sdk/v3/reference/classes/LiquidityMath)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / LiquidityMath

# Class: LiquidityMath

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/LiquidityMath#constructor)

### Methods

- [addDelta](https://docs.uniswap.org/sdk/v3/reference/classes/LiquidityMath#adddelta)

## Constructors

### constructor

• `Private` **new LiquidityMath**()

Cannot be constructed.

#### Defined in

[utils/liquidityMath.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/liquidityMath.ts#L8)

## Methods

### addDelta

▸ `Static` **addDelta**(`x`, `y`): `default`

#### Parameters

| Name | Type      |
| :--- | :-------- |
| `x`  | `default` |
| `y`  | `default` |

#### Returns

```
default
```

#### Defined in

[utils/liquidityMath.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/liquidityMath.ts#L10)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Multicall](https://docs.uniswap.org/sdk/v3/reference/classes/Multicall)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Multicall

# Class: Multicall

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Multicall#constructor)

### Properties

- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/Multicall#interface)

### Methods

- [encodeMulticall](https://docs.uniswap.org/sdk/v3/reference/classes/Multicall#encodemulticall)

## Constructors

### constructor

• `Private` **new Multicall**()

Cannot be constructed.

#### Defined in

[multicall.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L10)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[multicall.ts:5](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L5)

## Methods

### encodeMulticall

▸ `Static` **encodeMulticall**(`calldatas`): `string`

#### Parameters

| Name        | Type                  |
| :---------- | :-------------------- |
| `calldatas` | `string` | `string`[] |

#### Returns

```
string
```

#### Defined in

[multicall.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L12)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[NoTickDataProvider](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / NoTickDataProvider

# Class: NoTickDataProvider

This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you do not need to load tick data for your use case.

## Implements

- [`TickDataProvider`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider)

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider#constructor)

### Properties

- [ERROR_MESSAGE](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider#error_message)

### Methods

- [getTick](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider#gettick)
- [nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider#nextinitializedtickwithinoneword)

## Constructors

### constructor

• **new NoTickDataProvider**()

## Properties

### ERROR_MESSAGE

▪ `Static` `Private` **ERROR_MESSAGE**: `string` = `'No tick data provider was given'`

#### Defined in

[entities/tickDataProvider.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L27)

## Methods

### getTick

▸ **getTick**(`_tick`): `Promise`<{ `liquidityNet`: `BigintIsh` \}>

Return information corresponding to a specific tick

#### Parameters

| Name    | Type     | Description      |
| :------ | :------- | :--------------- |
| `_tick` | `number` | the tick to load |

#### Returns

`Promise`<{ `liquidityNet`: `BigintIsh` }>

#### Implementation of

[TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider).[getTick](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#gettick)

#### Defined in

[entities/tickDataProvider.ts:28](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L28)

------

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`_tick`, `_lte`, `_tickSpacing`): `Promise`<[`number`, `boolean`]>

Return the next tick that is initialized within a single word

#### Parameters

| Name           | Type      | Description                                          |
| :------------- | :-------- | :--------------------------------------------------- |
| `_tick`        | `number`  | The current tick                                     |
| `_lte`         | `boolean` | Whether the next tick should be lte the current tick |
| `_tickSpacing` | `number`  | The tick spacing of the pool                         |

#### Returns

`Promise`<[`number`, `boolean`]>

#### Implementation of

[TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider).[nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#nextinitializedtickwithinoneword)

#### Defined in

[entities/tickDataProvider.ts:32](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L32)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[NonfungiblePositionManager](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / NonfungiblePositionManager

# Class: NonfungiblePositionManager

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#constructor)

### Properties

- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#interface)

### Methods

- [addCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#addcallparameters)
- [collectCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#collectcallparameters)
- [createCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#createcallparameters)
- [encodeCollect](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#encodecollect)
- [encodeCreate](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#encodecreate)
- [removeCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#removecallparameters)
- [safeTransferFromParameters](https://docs.uniswap.org/sdk/v3/reference/classes/NonfungiblePositionManager#safetransferfromparameters)

## Constructors

### constructor

• `Private` **new NonfungiblePositionManager**()

Cannot be constructed.

#### Defined in

[nonfungiblePositionManager.ts:181](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L181)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[nonfungiblePositionManager.ts:176](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L176)

## Methods

### addCallParameters

▸ `Static` **addCallParameters**(`position`, `options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Parameters

| Name       | Type                                                         |
| :--------- | :----------------------------------------------------------- |
| `position` | [`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position) |
| `options`  | [`AddLiquidityOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#addliquidityoptions) |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[nonfungiblePositionManager.ts:199](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L199)

------

### collectCallParameters

▸ `Static` **collectCallParameters**(`options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Parameters

| Name      | Type                                                         |
| :-------- | :----------------------------------------------------------- |
| `options` | [`CollectOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions) |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[nonfungiblePositionManager.ts:326](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L326)

------

### createCallParameters

▸ `Static` **createCallParameters**(`pool`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Parameters

| Name   | Type                                                         |
| :----- | :----------------------------------------------------------- |
| `pool` | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool) |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[nonfungiblePositionManager.ts:192](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L192)

------

### encodeCollect

▸ `Static` `Private` **encodeCollect**(`options`): `string`[]

#### Parameters

| Name      | Type                                                         |
| :-------- | :----------------------------------------------------------- |
| `options` | [`CollectOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions) |

#### Returns

`string`[]

#### Defined in

[nonfungiblePositionManager.ts:286](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L286)

------

### encodeCreate

▸ `Static` `Private` **encodeCreate**(`pool`): `string`

#### Parameters

| Name   | Type                                                         |
| :----- | :----------------------------------------------------------- |
| `pool` | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool) |

#### Returns

```
string
```

#### Defined in

[nonfungiblePositionManager.ts:183](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L183)

------

### removeCallParameters

▸ `Static` **removeCallParameters**(`position`, `options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

Produces the calldata for completely or partially exiting a position

#### Parameters

| Name       | Type                                                         | Description                                                  |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `position` | [`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position) | The position to exit                                         |
| `options`  | [`RemoveLiquidityOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions) | Additional information necessary for generating the calldata |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

The call parameters

#### Defined in

[nonfungiblePositionManager.ts:341](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L341)

------

### safeTransferFromParameters

▸ `Static` **safeTransferFromParameters**(`options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Parameters

| Name      | Type                                                         |
| :-------- | :----------------------------------------------------------- |
| `options` | [`SafeTransferOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions) |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[nonfungiblePositionManager.ts:416](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L416)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Payments](https://docs.uniswap.org/sdk/v3/reference/classes/Payments)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Payments

# Class: Payments

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#constructor)

### Properties

- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#interface)

### Methods

- [encodeFeeBips](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#encodefeebips)
- [encodeRefundETH](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#encoderefundeth)
- [encodeSweepToken](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#encodesweeptoken)
- [encodeUnwrapWETH9](https://docs.uniswap.org/sdk/v3/reference/classes/Payments#encodeunwrapweth9)

## Constructors

### constructor

• `Private` **new Payments**()

Cannot be constructed.

#### Defined in

[payments.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L25)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[payments.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L20)

## Methods

### encodeFeeBips

▸ `Static` `Private` **encodeFeeBips**(`fee`): `string`

#### Parameters

| Name  | Type      |
| :---- | :-------- |
| `fee` | `Percent` |

#### Returns

```
string
```

#### Defined in

[payments.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L27)

------

### encodeRefundETH

▸ `Static` **encodeRefundETH**(): `string`

#### Returns

```
string
```

#### Defined in

[payments.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L73)

------

### encodeSweepToken

▸ `Static` **encodeSweepToken**(`token`, `amountMinimum`, `recipient`, `feeOptions?`): `string`

#### Parameters

| Name            | Type                                                         |
| :-------------- | :----------------------------------------------------------- |
| `token`         | `Token`                                                      |
| `amountMinimum` | `default`                                                    |
| `recipient`     | `string`                                                     |
| `feeOptions?`   | [`FeeOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions) |

#### Returns

```
string
```

#### Defined in

[payments.ts:49](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L49)

------

### encodeUnwrapWETH9

▸ `Static` **encodeUnwrapWETH9**(`amountMinimum`, `recipient`, `feeOptions?`): `string`

#### Parameters

| Name            | Type                                                         |
| :-------------- | :----------------------------------------------------------- |
| `amountMinimum` | `default`                                                    |
| `recipient`     | `string`                                                     |
| `feeOptions?`   | [`FeeOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions) |

#### Returns

```
string
```

#### Defined in

[payments.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L31)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Pool](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Pool

# Class: Pool

Represents a V3 pool

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#constructor)

### Properties

- [_token0Price](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#_token0price)
- [_token1Price](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#_token1price)
- [fee](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#fee)
- [liquidity](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#liquidity)
- [sqrtRatioX96](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#sqrtratiox96)
- [tickCurrent](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#tickcurrent)
- [tickDataProvider](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#tickdataprovider)
- [token0](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#token0)
- [token1](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#token1)

### Accessors

- [chainId](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#chainid)
- [tickSpacing](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#tickspacing)
- [token0Price](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#token0price)
- [token1Price](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#token1price)

### Methods

- [getInputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#getinputamount)
- [getOutputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#getoutputamount)
- [involvesToken](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#involvestoken)
- [priceOf](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#priceof)
- [swap](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#swap)
- [getAddress](https://docs.uniswap.org/sdk/v3/reference/classes/Pool#getaddress)

## Constructors

### constructor

• **new Pool**(`tokenA`, `tokenB`, `fee`, `sqrtRatioX96`, `liquidity`, `tickCurrent`, `ticks?`)

Construct a pool

#### Parameters

| Name           | Type                                                         | Default value                   | Description                                                  |
| :------------- | :----------------------------------------------------------- | :------------------------------ | :----------------------------------------------------------- |
| `tokenA`       | `Token`                                                      | `undefined`                     | One of the tokens in the pool                                |
| `tokenB`       | `Token`                                                      | `undefined`                     | The other token in the pool                                  |
| `fee`          | [`FeeAmount`](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount) | `undefined`                     | The fee in hundredths of a bips of the input amount of every swap that is collected by the pool |
| `sqrtRatioX96` | `BigintIsh`                                                  | `undefined`                     | The sqrt of the current ratio of amounts of token1 to token0 |
| `liquidity`    | `BigintIsh`                                                  | `undefined`                     | The current value of in range liquidity                      |
| `tickCurrent`  | `number`                                                     | `undefined`                     | The current tick of the pool                                 |
| `ticks`        | [`TickDataProvider`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider) | ([`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick) | [`TickConstructorArgs`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs))[] | `NO_TICK_DATA_PROVIDER_DEFAULT` | The current state of the pool ticks or a data provider that can return tick data |

#### Defined in

[entities/pool.ts:70](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L70)

## Properties

### _token0Price

• `Private` `Optional` **_token0Price**: `Price`<`Token`, `Token`>

#### Defined in

[entities/pool.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L41)

------

### _token1Price

• `Private` `Optional` **_token1Price**: `Price`<`Token`, `Token`>

#### Defined in

[entities/pool.ts:42](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L42)

------

### fee

• `Readonly` **fee**: [`FeeAmount`](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount)

#### Defined in

[entities/pool.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L35)

------

### liquidity

• `Readonly` **liquidity**: `default`

#### Defined in

[entities/pool.ts:37](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L37)

------

### sqrtRatioX96

• `Readonly` **sqrtRatioX96**: `default`

#### Defined in

[entities/pool.ts:36](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L36)

------

### tickCurrent

• `Readonly` **tickCurrent**: `number`

#### Defined in

[entities/pool.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L38)

------

### tickDataProvider

• `Readonly` **tickDataProvider**: [`TickDataProvider`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider)

#### Defined in

[entities/pool.ts:39](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L39)

------

### token0

• `Readonly` **token0**: `Token`

#### Defined in

[entities/pool.ts:33](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L33)

------

### token1

• `Readonly` **token1**: `Token`

#### Defined in

[entities/pool.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L34)

## Accessors

### chainId

• `get` **chainId**(): `number`

Returns the chain ID of the tokens in the pool.

#### Returns

```
number
```

#### Defined in

[entities/pool.ts:149](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L149)

------

### tickSpacing

• `get` **tickSpacing**(): `number`

#### Returns

```
number
```

#### Defined in

[entities/pool.ts:317](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L317)

------

### token0Price

• `get` **token0Price**(): `Price`<`Token`, `Token`>

Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0

#### Returns

`Price`<`Token`, `Token`>

#### Defined in

[entities/pool.ts:109](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L109)

------

### token1Price

• `get` **token1Price**(): `Price`<`Token`, `Token`>

Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1

#### Returns

`Price`<`Token`, `Token`>

#### Defined in

[entities/pool.ts:124](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L124)

## Methods

### getInputAmount

▸ **getInputAmount**(`outputAmount`, `sqrtPriceLimitX96?`): `Promise`<[`CurrencyAmount`<`Token`>, [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)]>

Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade

#### Parameters

| Name                 | Type                      | Description                                                  |
| :------------------- | :------------------------ | :----------------------------------------------------------- |
| `outputAmount`       | `CurrencyAmount`<`Token`> | the output amount for which to quote the input amount        |
| `sqrtPriceLimitX96?` | `default`                 | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

#### Returns

`Promise`<[`CurrencyAmount`<`Token`>, [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)]>

The input amount and the pool with updated state

#### Defined in

[entities/pool.ts:185](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L185)

------

### getOutputAmount

▸ **getOutputAmount**(`inputAmount`, `sqrtPriceLimitX96?`): `Promise`<[`CurrencyAmount`<`Token`>, [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)]>

Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade

#### Parameters

| Name                 | Type                      | Description                                           |
| :------------------- | :------------------------ | :---------------------------------------------------- |
| `inputAmount`        | `CurrencyAmount`<`Token`> | The input amount for which to quote the output amount |
| `sqrtPriceLimitX96?` | `default`                 | The Q64.96 sqrt price limit                           |

#### Returns

`Promise`<[`CurrencyAmount`<`Token`>, [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)]>

The output amount and the pool with updated state

#### Defined in

[entities/pool.ts:159](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L159)

------

### involvesToken

▸ **involvesToken**(`token`): `boolean`

Returns true if the token is either token0 or token1

#### Parameters

| Name    | Type    | Description        |
| :------ | :------ | :----------------- |
| `token` | `Token` | The token to check |

#### Returns

```
boolean
```

True if token is either token0 or token

#### Defined in

[entities/pool.ts:102](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L102)

------

### priceOf

▸ **priceOf**(`token`): `Price`<`Token`, `Token`>

Return the price of the given token in terms of the other token in the pool.

#### Parameters

| Name    | Type    | Description                  |
| :------ | :------ | :--------------------------- |
| `token` | `Token` | The token to return price of |

#### Returns

`Price`<`Token`, `Token`>

The price of the given token, in terms of the other.

#### Defined in

[entities/pool.ts:141](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L141)

------

### swap

▸ `Private` **swap**(`zeroForOne`, `amountSpecified`, `sqrtPriceLimitX96?`): `Promise`<{ `amountCalculated`: `default` ; `liquidity`: `default` ; `sqrtRatioX96`: `default` ; `tickCurrent`: `number` \}>

Executes a swap

#### Parameters

| Name                 | Type      | Description                                                  |
| :------------------- | :-------- | :----------------------------------------------------------- |
| `zeroForOne`         | `boolean` | Whether the amount in is token0 or token1                    |
| `amountSpecified`    | `default` | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) |
| `sqrtPriceLimitX96?` | `default` | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

#### Returns

`Promise`<{ `amountCalculated`: `default` ; `liquidity`: `default` ; `sqrtRatioX96`: `default` ; `tickCurrent`: `number` }>

amountCalculated

sqrtRatioX96

liquidity

tickCurrent

#### Defined in

[entities/pool.ts:215](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L215)

------

### getAddress

▸ `Static` **getAddress**(`tokenA`, `tokenB`, `fee`, `initCodeHashManualOverride?`, `factoryAddressOverride?`): `string`

#### Parameters

| Name                          | Type                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| `tokenA`                      | `Token`                                                      |
| `tokenB`                      | `Token`                                                      |
| `fee`                         | [`FeeAmount`](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount) |
| `initCodeHashManualOverride?` | `string`                                                     |
| `factoryAddressOverride?`     | `string`                                                     |

#### Returns

```
string
```

#### Defined in

[entities/pool.ts:44](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L44)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Position](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Position

# Class: Position

Represents a position on a Uniswap V3 Pool

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Position#constructor)

### Properties

- [_mintAmounts](https://docs.uniswap.org/sdk/v3/reference/classes/Position#_mintamounts)
- [_token0Amount](https://docs.uniswap.org/sdk/v3/reference/classes/Position#_token0amount)
- [_token1Amount](https://docs.uniswap.org/sdk/v3/reference/classes/Position#_token1amount)
- [liquidity](https://docs.uniswap.org/sdk/v3/reference/classes/Position#liquidity)
- [pool](https://docs.uniswap.org/sdk/v3/reference/classes/Position#pool)
- [tickLower](https://docs.uniswap.org/sdk/v3/reference/classes/Position#ticklower)
- [tickUpper](https://docs.uniswap.org/sdk/v3/reference/classes/Position#tickupper)

### Accessors

- [amount0](https://docs.uniswap.org/sdk/v3/reference/classes/Position#amount0)
- [amount1](https://docs.uniswap.org/sdk/v3/reference/classes/Position#amount1)
- [mintAmounts](https://docs.uniswap.org/sdk/v3/reference/classes/Position#mintamounts)
- [token0PriceLower](https://docs.uniswap.org/sdk/v3/reference/classes/Position#token0pricelower)
- [token0PriceUpper](https://docs.uniswap.org/sdk/v3/reference/classes/Position#token0priceupper)

### Methods

- [burnAmountsWithSlippage](https://docs.uniswap.org/sdk/v3/reference/classes/Position#burnamountswithslippage)
- [mintAmountsWithSlippage](https://docs.uniswap.org/sdk/v3/reference/classes/Position#mintamountswithslippage)
- [ratiosAfterSlippage](https://docs.uniswap.org/sdk/v3/reference/classes/Position#ratiosafterslippage)
- [fromAmount0](https://docs.uniswap.org/sdk/v3/reference/classes/Position#fromamount0)
- [fromAmount1](https://docs.uniswap.org/sdk/v3/reference/classes/Position#fromamount1)
- [fromAmounts](https://docs.uniswap.org/sdk/v3/reference/classes/Position#fromamounts)

## Constructors

### constructor

• **new Position**(`__namedParameters`)

Constructs a position for a given pool with the given liquidity

#### Parameters

| Name                | Type                      |
| :------------------ | :------------------------ |
| `__namedParameters` | `PositionConstructorArgs` |

#### Defined in

[entities/position.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L40)

## Properties

### _mintAmounts

• `Private` **_mintAmounts**: `null` | `Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}> = `null`

#### Defined in

[entities/position.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L31)

------

### _token0Amount

• `Private` **_token0Amount**: `null` | `CurrencyAmount`<`Token`> = `null`

#### Defined in

[entities/position.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L29)

------

### _token1Amount

• `Private` **_token1Amount**: `null` | `CurrencyAmount`<`Token`> = `null`

#### Defined in

[entities/position.ts:30](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L30)

------

### liquidity

• `Readonly` **liquidity**: `default`

#### Defined in

[entities/position.ts:26](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L26)

------

### pool

• `Readonly` **pool**: [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)

#### Defined in

[entities/position.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L23)

------

### tickLower

• `Readonly` **tickLower**: `number`

#### Defined in

[entities/position.ts:24](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L24)

------

### tickUpper

• `Readonly` **tickUpper**: `number`

#### Defined in

[entities/position.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L25)

## Accessors

### amount0

• `get` **amount0**(): `CurrencyAmount`<`Token`>

Returns the amount of token0 that this position's liquidity could be burned for at the current pool price

#### Returns

`CurrencyAmount`<`Token`>

#### Defined in

[entities/position.ts:68](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L68)

------

### amount1

• `get` **amount1**(): `CurrencyAmount`<`Token`>

Returns the amount of token1 that this position's liquidity could be burned for at the current pool price

#### Returns

`CurrencyAmount`<`Token`>

#### Defined in

[entities/position.ts:100](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L100)

------

### mintAmounts

• `get` **mintAmounts**(): `Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool

#### Returns

`Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

#### Defined in

[entities/position.ts:258](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L258)

------

### token0PriceLower

• `get` **token0PriceLower**(): `Price`<`Token`, `Token`>

Returns the price of token0 at the lower tick

#### Returns

`Price`<`Token`, `Token`>

#### Defined in

[entities/position.ts:54](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L54)

------

### token0PriceUpper

• `get` **token0PriceUpper**(): `Price`<`Token`, `Token`>

Returns the price of token0 at the upper tick

#### Returns

`Price`<`Token`, `Token`>

#### Defined in

[entities/position.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L61)

## Methods

### burnAmountsWithSlippage

▸ **burnAmountsWithSlippage**(`slippageTolerance`): `Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance

#### Parameters

| Name                | Type      | Description                                              |
| :------------------ | :-------- | :------------------------------------------------------- |
| `slippageTolerance` | `Percent` | tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

The amounts, with slippage

#### Defined in

[entities/position.ts:213](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L213)

------

### mintAmountsWithSlippage

▸ **mintAmountsWithSlippage**(`slippageTolerance`): `Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance

#### Parameters

| Name                | Type      | Description                                              |
| :------------------ | :-------- | :------------------------------------------------------- |
| `slippageTolerance` | `Percent` | Tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`<{ `amount0`: `default` ; `amount1`: `default` \}>

The amounts, with slippage

#### Defined in

[entities/position.ts:157](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L157)

------

### ratiosAfterSlippage

▸ `Private` **ratiosAfterSlippage**(`slippageTolerance`): `Object`

Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage

#### Parameters

| Name                | Type      | Description                                                  |
| :------------------ | :-------- | :----------------------------------------------------------- |
| `slippageTolerance` | `Percent` | The amount by which the price can 'slip' before the transaction will revert |

#### Returns

```
Object
```

The sqrt ratios after slippage

| Name                | Type      |
| :------------------ | :-------- |
| `sqrtRatioX96Lower` | `default` |
| `sqrtRatioX96Upper` | `default` |

#### Defined in

[entities/position.ts:134](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L134)

------

### fromAmount0

▸ `Static` **fromAmount0**(`__namedParameters`): [`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1

#### Parameters

| Name                                 | Type                                                         |
| :----------------------------------- | :----------------------------------------------------------- |
| `__namedParameters`                  | `Object`                                                     |
| `__namedParameters.amount0`          | `BigintIsh`                                                  |
| `__namedParameters.pool`             | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool) |
| `__namedParameters.tickLower`        | `number`                                                     |
| `__namedParameters.tickUpper`        | `number`                                                     |
| `__namedParameters.useFullPrecision` | `boolean`                                                    |

#### Returns

[`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

The position

#### Defined in

[entities/position.ts:354](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L354)

------

### fromAmount1

▸ `Static` **fromAmount1**(`__namedParameters`): [`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0

#### Parameters

| Name                          | Type                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| `__namedParameters`           | `Object`                                                     |
| `__namedParameters.amount1`   | `BigintIsh`                                                  |
| `__namedParameters.pool`      | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool) |
| `__namedParameters.tickLower` | `number`                                                     |
| `__namedParameters.tickUpper` | `number`                                                     |

#### Returns

[`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

The position

#### Defined in

[entities/position.ts:378](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L378)

------

### fromAmounts

▸ `Static` **fromAmounts**(`__namedParameters`): [`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries.

#### Parameters

| Name                                 | Type                                                         |
| :----------------------------------- | :----------------------------------------------------------- |
| `__namedParameters`                  | `Object`                                                     |
| `__namedParameters.amount0`          | `BigintIsh`                                                  |
| `__namedParameters.amount1`          | `BigintIsh`                                                  |
| `__namedParameters.pool`             | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool) |
| `__namedParameters.tickLower`        | `number`                                                     |
| `__namedParameters.tickUpper`        | `number`                                                     |
| `__namedParameters.useFullPrecision` | `boolean`                                                    |

#### Returns

[`Position`](https://docs.uniswap.org/sdk/v3/reference/classes/Position)

The amount of liquidity for the position

#### Defined in

[entities/position.ts:312](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L312)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[PositionLibrary](https://docs.uniswap.org/sdk/v3/reference/classes/PositionLibrary)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / PositionLibrary

# Class: PositionLibrary

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/PositionLibrary#constructor)

### Methods

- [getTokensOwed](https://docs.uniswap.org/sdk/v3/reference/classes/PositionLibrary#gettokensowed)

## Constructors

### constructor

• `Private` **new PositionLibrary**()

Cannot be constructed.

#### Defined in

[utils/position.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/position.ts#L10)

## Methods

### getTokensOwed

▸ `Static` **getTokensOwed**(`feeGrowthInside0LastX128`, `feeGrowthInside1LastX128`, `liquidity`, `feeGrowthInside0X128`, `feeGrowthInside1X128`): `default`[]

#### Parameters

| Name                       | Type      |
| :------------------------- | :-------- |
| `feeGrowthInside0LastX128` | `default` |
| `feeGrowthInside1LastX128` | `default` |
| `liquidity`                | `default` |
| `feeGrowthInside0X128`     | `default` |
| `feeGrowthInside1X128`     | `default` |

#### Returns

`default`[]

#### Defined in

[utils/position.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/position.ts#L13)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Route](https://docs.uniswap.org/sdk/v3/reference/classes/Route)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Route

# Class: Route<TInput, TOutput>

Represents a list of pools through which a swap can occur

## Type parameters

| Name      | Type               | Description      |
| :-------- | :----------------- | :--------------- |
| `TInput`  | extends `Currency` | The input token  |
| `TOutput` | extends `Currency` | The output token |

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Route#constructor)

### Properties

- [_midPrice](https://docs.uniswap.org/sdk/v3/reference/classes/Route#_midprice)
- [input](https://docs.uniswap.org/sdk/v3/reference/classes/Route#input)
- [output](https://docs.uniswap.org/sdk/v3/reference/classes/Route#output)
- [pools](https://docs.uniswap.org/sdk/v3/reference/classes/Route#pools)
- [tokenPath](https://docs.uniswap.org/sdk/v3/reference/classes/Route#tokenpath)

### Accessors

- [chainId](https://docs.uniswap.org/sdk/v3/reference/classes/Route#chainid)
- [midPrice](https://docs.uniswap.org/sdk/v3/reference/classes/Route#midprice)

## Constructors

### constructor

• **new Route**<`TInput`, `TOutput`>(`pools`, `input`, `output`)

Creates an instance of route.

#### Type parameters

| Name      | Type               |
| :-------- | :----------------- |
| `TInput`  | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name     | Type                                                         | Description                                                  |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `pools`  | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[] | An array of `Pool` objects, ordered by the route the swap will take |
| `input`  | `TInput`                                                     | The input token                                              |
| `output` | `TOutput`                                                    | The output token                                             |

#### Defined in

[entities/route.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L25)

## Properties

### _midPrice

• `Private` **_midPrice**: `null` | `Price`<`TInput`, `TOutput`> = `null`

#### Defined in

[entities/route.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L17)

------

### input

• `Readonly` **input**: `TInput`

#### Defined in

[entities/route.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L14)

------

### output

• `Readonly` **output**: `TOutput`

#### Defined in

[entities/route.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L15)

------

### pools

• `Readonly` **pools**: [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[]

#### Defined in

[entities/route.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L12)

------

### tokenPath

• `Readonly` **tokenPath**: `Token`[]

#### Defined in

[entities/route.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L13)

## Accessors

### chainId

• `get` **chainId**(): `number`

#### Returns

```
number
```

#### Defined in

[entities/route.ts:54](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L54)

------

### midPrice

• `get` **midPrice**(): `Price`<`TInput`, `TOutput`>

Returns the mid price of the route

#### Returns

`Price`<`TInput`, `TOutput`>

#### Defined in

[entities/route.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L61)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[SelfPermit](https://docs.uniswap.org/sdk/v3/reference/classes/SelfPermit)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SelfPermit

# Class: SelfPermit

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/SelfPermit#constructor)

### Properties

- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/SelfPermit#interface)

### Methods

- [encodePermit](https://docs.uniswap.org/sdk/v3/reference/classes/SelfPermit#encodepermit)

## Constructors

### constructor

• `Private` **new SelfPermit**()

Cannot be constructed.

#### Defined in

[selfPermit.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L34)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[selfPermit.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L29)

## Methods

### encodePermit

▸ `Static` **encodePermit**(`token`, `options`): `string`

#### Parameters

| Name      | Type                                                         |
| :-------- | :----------------------------------------------------------- |
| `token`   | `Token`                                                      |
| `options` | [`PermitOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#permitoptions) |

#### Returns

```
string
```

#### Defined in

[selfPermit.ts:36](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L36)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[SqrtPriceMath](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SqrtPriceMath

# Class: SqrtPriceMath

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#constructor)

### Methods

- [getAmount0Delta](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getamount0delta)
- [getAmount1Delta](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getamount1delta)
- [getNextSqrtPriceFromAmount0RoundingUp](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getnextsqrtpricefromamount0roundingup)
- [getNextSqrtPriceFromAmount1RoundingDown](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getnextsqrtpricefromamount1roundingdown)
- [getNextSqrtPriceFromInput](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getnextsqrtpricefrominput)
- [getNextSqrtPriceFromOutput](https://docs.uniswap.org/sdk/v3/reference/classes/SqrtPriceMath#getnextsqrtpricefromoutput)

## Constructors

### constructor

• `Private` **new SqrtPriceMath**()

Cannot be constructed.

#### Defined in

[utils/sqrtPriceMath.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L23)

## Methods

### getAmount0Delta

▸ `Static` **getAmount0Delta**(`sqrtRatioAX96`, `sqrtRatioBX96`, `liquidity`, `roundUp`): `default`

#### Parameters

| Name            | Type      |
| :-------------- | :-------- |
| `sqrtRatioAX96` | `default` |
| `sqrtRatioBX96` | `default` |
| `liquidity`     | `default` |
| `roundUp`       | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L25)

------

### getAmount1Delta

▸ `Static` **getAmount1Delta**(`sqrtRatioAX96`, `sqrtRatioBX96`, `liquidity`, `roundUp`): `default`

#### Parameters

| Name            | Type      |
| :-------------- | :-------- |
| `sqrtRatioAX96` | `default` |
| `sqrtRatioBX96` | `default` |
| `liquidity`     | `default` |
| `roundUp`       | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L38)

------

### getNextSqrtPriceFromAmount0RoundingUp

▸ `Static` `Private` **getNextSqrtPriceFromAmount0RoundingUp**(`sqrtPX96`, `liquidity`, `amount`, `add`): `default`

#### Parameters

| Name        | Type      |
| :---------- | :-------- |
| `sqrtPX96`  | `default` |
| `liquidity` | `default` |
| `amount`    | `default` |
| `add`       | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:71](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L71)

------

### getNextSqrtPriceFromAmount1RoundingDown

▸ `Static` `Private` **getNextSqrtPriceFromAmount1RoundingDown**(`sqrtPX96`, `liquidity`, `amount`, `add`): `default`

#### Parameters

| Name        | Type      |
| :---------- | :-------- |
| `sqrtPX96`  | `default` |
| `liquidity` | `default` |
| `amount`    | `default` |
| `add`       | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:100](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L100)

------

### getNextSqrtPriceFromInput

▸ `Static` **getNextSqrtPriceFromInput**(`sqrtPX96`, `liquidity`, `amountIn`, `zeroForOne`): `default`

#### Parameters

| Name         | Type      |
| :----------- | :-------- |
| `sqrtPX96`   | `default` |
| `liquidity`  | `default` |
| `amountIn`   | `default` |
| `zeroForOne` | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:48](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L48)

------

### getNextSqrtPriceFromOutput

▸ `Static` **getNextSqrtPriceFromOutput**(`sqrtPX96`, `liquidity`, `amountOut`, `zeroForOne`): `default`

#### Parameters

| Name         | Type      |
| :----------- | :-------- |
| `sqrtPX96`   | `default` |
| `liquidity`  | `default` |
| `amountOut`  | `default` |
| `zeroForOne` | `boolean` |

#### Returns

```
default
```

#### Defined in

[utils/sqrtPriceMath.ts:57](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L57)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Staker](https://docs.uniswap.org/sdk/v3/reference/classes/Staker)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Staker

# Class: Staker

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#constructor)

### Properties

- [INCENTIVE_KEY_ABI](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#incentive_key_abi)
- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#interface)

### Methods

- [_encodeIncentiveKey](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#_encodeincentivekey)
- [collectRewards](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#collectrewards)
- [encodeClaim](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#encodeclaim)
- [encodeDeposit](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#encodedeposit)
- [withdrawToken](https://docs.uniswap.org/sdk/v3/reference/classes/Staker#withdrawtoken)

## Constructors

### constructor

• `Protected` **new Staker**()

#### Defined in

[staker.ts:72](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L72)

## Properties

### INCENTIVE_KEY_ABI

▪ `Static` `Private` **INCENTIVE_KEY_ABI**: `string` = `'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)'`

#### Defined in

[staker.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L73)

------

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[staker.ts:70](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L70)

## Methods

### _encodeIncentiveKey

▸ `Static` `Private` **_encodeIncentiveKey**(`incentiveKey`): `Object`

#### Parameters

| Name           | Type                                                         | Description                                                  |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `incentiveKey` | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey) | An `IncentiveKey` which represents a unique staking program. |

#### Returns

```
Object
```

An encoded IncentiveKey to be read by ethers

#### Defined in

[staker.ts:194](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L194)

------

### collectRewards

▸ `Static` **collectRewards**(`incentiveKeys`, `options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

Note: A `tokenId` can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake.

#### Parameters

| Name            | Type                                                         | Description                                                  |
| :-------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `incentiveKeys` | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey) | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey)[] | An IncentiveKey or array of IncentiveKeys that `tokenId` is staked in. Input an array of IncentiveKeys to claim rewards for each program. |
| `options`       | [`ClaimOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions) | ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once. |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[staker.ts:107](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L107)

------

### encodeClaim

▸ `Static` `Private` **encodeClaim**(`incentiveKey`, `options`): `string`[]

To claim rewards, must unstake and then claim.

#### Parameters

| Name           | Type                                                         | Description                                                  |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `incentiveKey` | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey) | The unique identifier of a staking program.                  |
| `options`      | [`ClaimOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions) | Options for producing the calldata to claim. Can't claim unless you unstake. |

#### Returns

`string`[]

The calldatas for 'unstakeToken' and 'claimReward'.

#### Defined in

[staker.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L82)

------

### encodeDeposit

▸ `Static` **encodeDeposit**(`incentiveKeys`): `string`

#### Parameters

| Name            | Type                                                         | Description                                                  |
| :-------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `incentiveKeys` | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey) | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey)[] | A single IncentiveKey or array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom` |

#### Returns

```
string
```

An IncentiveKey as a string

#### Defined in

[staker.ts:173](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L173)

------

### withdrawToken

▸ `Static` **withdrawToken**(`incentiveKeys`, `withdrawOptions`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Parameters

| Name              | Type                                                         | Description                                                  |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `incentiveKeys`   | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey) | [`IncentiveKey`](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey)[] | A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in. |
| `withdrawOptions` | [`FullWithdrawOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#fullwithdrawoptions) | Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`. |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

Calldata for unstaking, claiming, and withdrawing.

#### Defined in

[staker.ts:136](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L136)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[SwapMath](https://docs.uniswap.org/sdk/v3/reference/classes/SwapMath)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SwapMath

# Class: SwapMath

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/SwapMath#constructor)

### Methods

- [computeSwapStep](https://docs.uniswap.org/sdk/v3/reference/classes/SwapMath#computeswapstep)

## Constructors

### constructor

• `Private` **new SwapMath**()

Cannot be constructed.

#### Defined in

[utils/swapMath.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/swapMath.ts#L13)

## Methods

### computeSwapStep

▸ `Static` **computeSwapStep**(`sqrtRatioCurrentX96`, `sqrtRatioTargetX96`, `liquidity`, `amountRemaining`, `feePips`): [`default`, `default`, `default`, `default`]

#### Parameters

| Name                  | Type                                                         |
| :-------------------- | :----------------------------------------------------------- |
| `sqrtRatioCurrentX96` | `default`                                                    |
| `sqrtRatioTargetX96`  | `default`                                                    |
| `liquidity`           | `default`                                                    |
| `amountRemaining`     | `default`                                                    |
| `feePips`             | [`FeeAmount`](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount) |

#### Returns

[`default`, `default`, `default`, `default`]

#### Defined in

[utils/swapMath.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/swapMath.ts#L15)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[SwapQuoter](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SwapQuoter

# Class: SwapQuoter

Represents the Uniswap V3 QuoterV1 contract with a method for returning the formatted calldata needed to call the quoter contract.

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter#constructor)

### Properties

- [V1INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter#v1interface)
- [V2INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter#v2interface)

### Methods

- [quoteCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/SwapQuoter#quotecallparameters)

## Constructors

### constructor

• **new SwapQuoter**()

## Properties

### V1INTERFACE

▪ `Static` **V1INTERFACE**: `Interface`

#### Defined in

[quoter.ts:37](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L37)

------

### V2INTERFACE

▪ `Static` **V2INTERFACE**: `Interface`

#### Defined in

[quoter.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L38)

## Methods

### quoteCallParameters

▸ `Static` **quoteCallParameters**<`TInput`, `TOutput`>(`route`, `amount`, `tradeType`, `options?`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters.

#### Type parameters

| Name      | Type               | Description                                 |
| :-------- | :----------------- | :------------------------------------------ |
| `TInput`  | extends `Currency` | The input token, either Ether or an ERC-20  |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name        | Type                                                         | Description                                                  |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `route`     | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> | The swap route, a list of pools through which a swap can occur |
| `amount`    | `CurrencyAmount`<`TInput` | `TOutput`>                       | The amount of the quote, either an amount in, or an amount out |
| `tradeType` | `TradeType`                                                  | The trade type, either exact input or exact output           |
| `options`   | [`QuoteOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/QuoteOptions) | The optional params including price limit and Quoter contract switch |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

The formatted calldata

#### Defined in

[quoter.ts:51](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L51)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[SwapRouter](https://docs.uniswap.org/sdk/v3/reference/classes/SwapRouter)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SwapRouter

# Class: SwapRouter

Represents the Uniswap V3 SwapRouter, and has static methods for helping execute trades.

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/SwapRouter#constructor)

### Properties

- [INTERFACE](https://docs.uniswap.org/sdk/v3/reference/classes/SwapRouter#interface)

### Methods

- [swapCallParameters](https://docs.uniswap.org/sdk/v3/reference/classes/SwapRouter#swapcallparameters)

## Constructors

### constructor

• `Private` **new SwapRouter**()

Cannot be constructed.

#### Defined in

[swapRouter.ts:57](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L57)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[swapRouter.ts:52](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L52)

## Methods

### swapCallParameters

▸ `Static` **swapCallParameters**(`trades`, `options`): [`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.

#### Parameters

| Name      | Type                                                         | Description                     |
| :-------- | :----------------------------------------------------------- | :------------------------------ |
| `trades`  | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`Currency`, `Currency`, `TradeType`> | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`Currency`, `Currency`, `TradeType`>[] | -                               |
| `options` | [`SwapOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions) | options for the call parameters |

#### Returns

[`MethodParameters`](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

#### Defined in

[swapRouter.ts:64](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L64)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Tick](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Tick

# Class: Tick

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Tick#constructor)

### Properties

- [index](https://docs.uniswap.org/sdk/v3/reference/classes/Tick#index)
- [liquidityGross](https://docs.uniswap.org/sdk/v3/reference/classes/Tick#liquiditygross)
- [liquidityNet](https://docs.uniswap.org/sdk/v3/reference/classes/Tick#liquiditynet)

## Constructors

### constructor

• **new Tick**(`__namedParameters`)

#### Parameters

| Name                | Type                                                         |
| :------------------ | :----------------------------------------------------------- |
| `__namedParameters` | [`TickConstructorArgs`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs) |

#### Defined in

[entities/tick.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L17)

## Properties

### index

• `Readonly` **index**: `number`

#### Defined in

[entities/tick.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L13)

------

### liquidityGross

• `Readonly` **liquidityGross**: `default`

#### Defined in

[entities/tick.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L14)

------

### liquidityNet

• `Readonly` **liquidityNet**: `default`

#### Defined in

[entities/tick.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L15)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[TickLibrary](https://docs.uniswap.org/sdk/v3/reference/classes/TickLibrary)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickLibrary

# Class: TickLibrary

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/TickLibrary#constructor)

### Methods

- [getFeeGrowthInside](https://docs.uniswap.org/sdk/v3/reference/classes/TickLibrary#getfeegrowthinside)

## Constructors

### constructor

• `Private` **new TickLibrary**()

Cannot be constructed.

#### Defined in

[utils/tickLibrary.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L25)

## Methods

### getFeeGrowthInside

▸ `Static` **getFeeGrowthInside**(`feeGrowthOutsideLower`, `feeGrowthOutsideUpper`, `tickLower`, `tickUpper`, `tickCurrent`, `feeGrowthGlobal0X128`, `feeGrowthGlobal1X128`): `default`[]

#### Parameters

| Name                    | Type               |
| :---------------------- | :----------------- |
| `feeGrowthOutsideLower` | `FeeGrowthOutside` |
| `feeGrowthOutsideUpper` | `FeeGrowthOutside` |
| `tickLower`             | `number`           |
| `tickUpper`             | `number`           |
| `tickCurrent`           | `number`           |
| `feeGrowthGlobal0X128`  | `default`          |
| `feeGrowthGlobal1X128`  | `default`          |

#### Returns

`default`[]

#### Defined in

[utils/tickLibrary.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L27)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[TickList](https://docs.uniswap.org/sdk/v3/reference/classes/TickList)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickList

# Class: TickList

Utility methods for interacting with sorted lists of ticks

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#constructor)

### Methods

- [binarySearch](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#binarysearch)
- [getTick](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#gettick)
- [isAtOrAboveLargest](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#isatorabovelargest)
- [isBelowSmallest](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#isbelowsmallest)
- [nextInitializedTick](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#nextinitializedtick)
- [nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#nextinitializedtickwithinoneword)
- [validateList](https://docs.uniswap.org/sdk/v3/reference/classes/TickList#validatelist)

## Constructors

### constructor

• `Private` **new TickList**()

Cannot be constructed

#### Defined in

[utils/tickList.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L18)

## Methods

### binarySearch

▸ `Static` `Private` **binarySearch**(`ticks`, `tick`): `number`

Finds the largest tick in the list of ticks that is less than or equal to tick

#### Parameters

| Name    | Type                                                         | Description                                                  |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `ticks` | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] | list of ticks                                                |
| `tick`  | `number`                                                     | tick to find the largest tick that is less than or equal to tick |

#### Returns

```
number
```

#### Defined in

[utils/tickList.ts:62](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L62)

------

### getTick

▸ `Static` **getTick**(`ticks`, `index`): [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `ticks` | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `index` | `number`                                                     |

#### Returns

[`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)

#### Defined in

[utils/tickList.ts:50](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L50)

------

### isAtOrAboveLargest

▸ `Static` **isAtOrAboveLargest**(`ticks`, `tick`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `ticks` | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `tick`  | `number`                                                     |

#### Returns

```
boolean
```

#### Defined in

[utils/tickList.ts:45](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L45)

------

### isBelowSmallest

▸ `Static` **isBelowSmallest**(`ticks`, `tick`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `ticks` | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `tick`  | `number`                                                     |

#### Returns

```
boolean
```

#### Defined in

[utils/tickList.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L40)

------

### nextInitializedTick

▸ `Static` **nextInitializedTick**(`ticks`, `tick`, `lte`): [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `ticks` | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `tick`  | `number`                                                     |
| `lte`   | `boolean`                                                    |

#### Returns

[`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)

#### Defined in

[utils/tickList.ts:83](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L83)

------

### nextInitializedTickWithinOneWord

▸ `Static` **nextInitializedTickWithinOneWord**(`ticks`, `tick`, `lte`, `tickSpacing`): [`number`, `boolean`]

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `ticks`       | readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `tick`        | `number`                                                     |
| `lte`         | `boolean`                                                    |
| `tickSpacing` | `number`                                                     |

#### Returns

[`number`, `boolean`]

#### Defined in

[utils/tickList.ts:101](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L101)

------

### validateList

▸ `Static` **validateList**(`ticks`, `tickSpacing`): `void`

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `ticks`       | [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[] |
| `tickSpacing` | `number`                                                     |

#### Returns

```
void
```

#### Defined in

[utils/tickList.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L20)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[TickListDataProvider](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickListDataProvider

# Class: TickListDataProvider

A data provider for ticks that is backed by an in-memory array of ticks.

## Implements

- [`TickDataProvider`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider)

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider#constructor)

### Properties

- [ticks](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider#ticks)

### Methods

- [getTick](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider#gettick)
- [nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider#nextinitializedtickwithinoneword)

## Constructors

### constructor

• **new TickListDataProvider**(`ticks`, `tickSpacing`)

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `ticks`       | ([`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick) | [`TickConstructorArgs`](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs))[] |
| `tickSpacing` | `number`                                                     |

#### Defined in

[entities/tickListDataProvider.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L12)

## Properties

### ticks

• `Private` **ticks**: readonly [`Tick`](https://docs.uniswap.org/sdk/v3/reference/classes/Tick)[]

#### Defined in

[entities/tickListDataProvider.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L10)

## Methods

### getTick

▸ **getTick**(`tick`): `Promise`<{ `liquidityGross`: `BigintIsh` ; `liquidityNet`: `BigintIsh` }>

Return information corresponding to a specific tick

#### Parameters

| Name   | Type     | Description      |
| :----- | :------- | :--------------- |
| `tick` | `number` | the tick to load |

#### Returns

`Promise`<{ `liquidityGross`: `BigintIsh` ; `liquidityNet`: `BigintIsh` }>

#### Implementation of

[TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider).[getTick](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#gettick)

#### Defined in

[entities/tickListDataProvider.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L18)

------

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`tick`, `lte`, `tickSpacing`): `Promise`<[`number`, `boolean`]>

Return the next tick that is initialized within a single word

#### Parameters

| Name          | Type      | Description                                          |
| :------------ | :-------- | :--------------------------------------------------- |
| `tick`        | `number`  | The current tick                                     |
| `lte`         | `boolean` | Whether the next tick should be lte the current tick |
| `tickSpacing` | `number`  | The tick spacing of the pool                         |

#### Returns

`Promise`<[`number`, `boolean`]>

#### Implementation of

[TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider).[nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#nextinitializedtickwithinoneword)

#### Defined in

[entities/tickListDataProvider.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L22)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[TickMath](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickMath

# Class: TickMath

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#constructor)

### Properties

- [MAX_SQRT_RATIO](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#max_sqrt_ratio)
- [MAX_TICK](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#max_tick)
- [MIN_SQRT_RATIO](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#min_sqrt_ratio)
- [MIN_TICK](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#min_tick)

### Methods

- [getSqrtRatioAtTick](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#getsqrtratioattick)
- [getTickAtSqrtRatio](https://docs.uniswap.org/sdk/v3/reference/classes/TickMath#gettickatsqrtratio)

## Constructors

### constructor

• `Private` **new TickMath**()

Cannot be constructed.

#### Defined in

[utils/tickMath.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L17)

## Properties

### MAX_SQRT_RATIO

▪ `Static` **MAX_SQRT_RATIO**: `default`

The sqrt ratio corresponding to the maximum tick that could be used on any pool.

#### Defined in

[utils/tickMath.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L35)

------

### MAX_TICK

▪ `Static` **MAX_TICK**: `number` = `-TickMath.MIN_TICK`

The maximum tick that can be used on any pool.

#### Defined in

[utils/tickMath.ts:26](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L26)

------

### MIN_SQRT_RATIO

▪ `Static` **MIN_SQRT_RATIO**: `default`

The sqrt ratio corresponding to the minimum tick that could be used on any pool.

#### Defined in

[utils/tickMath.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L31)

------

### MIN_TICK

▪ `Static` **MIN_TICK**: `number` = `-887272`

The minimum tick that can be used on any pool.

#### Defined in

[utils/tickMath.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L22)

## Methods

### getSqrtRatioAtTick

▸ `Static` **getSqrtRatioAtTick**(`tick`): `default`

Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick

#### Parameters

| Name   | Type     | Description                                  |
| :----- | :------- | :------------------------------------------- |
| `tick` | `number` | the tick for which to compute the sqrt ratio |

#### Returns

```
default
```

#### Defined in

[utils/tickMath.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L41)

------

### getTickAtSqrtRatio

▸ `Static` **getTickAtSqrtRatio**(`sqrtRatioX96`): `number`

Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96 and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96

#### Parameters

| Name           | Type      | Description                                              |
| :------------- | :-------- | :------------------------------------------------------- |
| `sqrtRatioX96` | `default` | the sqrt ratio as a Q64.96 for which to compute the tick |

#### Returns

```
number
```

#### Defined in

[utils/tickMath.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L82)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceclasses[Trade](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / Trade

# Class: Trade<TInput, TOutput, TTradeType>

Represents a trade executed against a set of routes where some percentage of the input is split across each route.

Each route has its own set of pools. Pools can not be re-used across routes.

Does not account for slippage, i.e., changes in price environment that can occur between the time the trade is submitted and when it is executed.

## Type parameters

| Name         | Type                | Description                                        |
| :----------- | :------------------ | :------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20         |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20        |
| `TTradeType` | extends `TradeType` | The trade type, either exact input or exact output |

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#constructor)

### Properties

- [_executionPrice](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#_executionprice)
- [_inputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#_inputamount)
- [_outputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#_outputamount)
- [_priceImpact](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#_priceimpact)
- [swaps](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#swaps)
- [tradeType](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#tradetype)

### Accessors

- [executionPrice](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#executionprice)
- [inputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#inputamount)
- [outputAmount](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#outputamount)
- [priceImpact](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#priceimpact)
- [route](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#route)

### Methods

- [maximumAmountIn](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#maximumamountin)
- [minimumAmountOut](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#minimumamountout)
- [worstExecutionPrice](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#worstexecutionprice)
- [bestTradeExactIn](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#besttradeexactin)
- [bestTradeExactOut](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#besttradeexactout)
- [createUncheckedTrade](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#createuncheckedtrade)
- [createUncheckedTradeWithMultipleRoutes](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#createuncheckedtradewithmultipleroutes)
- [exactIn](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#exactin)
- [exactOut](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#exactout)
- [fromRoute](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#fromroute)
- [fromRoutes](https://docs.uniswap.org/sdk/v3/reference/classes/Trade#fromroutes)

## Constructors

### constructor

• `Private` **new Trade**<`TInput`, `TOutput`, `TTradeType`>(`__namedParameters`)

Construct a trade by passing in the pre-computed property values

#### Type parameters

| Name         | Type                |
| :----------- | :------------------ |
| `TInput`     | extends `Currency`  |
| `TOutput`    | extends `Currency`  |
| `TTradeType` | extends `TradeType` |

#### Parameters

| Name                          | Type                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| `__namedParameters`           | `Object`                                                     |
| `__namedParameters.routes`    | { `inputAmount`: `CurrencyAmount`<`TInput`> ; `outputAmount`: `CurrencyAmount`<`TOutput`> ; `route`: [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> }[] |
| `__namedParameters.tradeType` | `TTradeType`                                                 |

#### Defined in

[entities/trade.ts:397](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L397)

## Properties

### _executionPrice

• `Private` **_executionPrice**: `undefined` | `Price`<`TInput`, `TOutput`>

The cached result of the computed execution price

#### Defined in

[entities/trade.ts:143](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L143)

------

### _inputAmount

• `Private` **_inputAmount**: `undefined` | `CurrencyAmount`<`TInput`>

The cached result of the input amount computation

#### Defined in

[entities/trade.ts:97](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L97)

------

### _outputAmount

• `Private` **_outputAmount**: `undefined` | `CurrencyAmount`<`TOutput`>

The cached result of the output amount computation

#### Defined in

[entities/trade.ts:120](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L120)

------

### _priceImpact

• `Private` **_priceImpact**: `undefined` | `Percent`

The cached result of the price impact computation

#### Defined in

[entities/trade.ts:164](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L164)

------

### swaps

• `Readonly` **swaps**: { `inputAmount`: `CurrencyAmount`<`TInput`> ; `outputAmount`: `CurrencyAmount`<`TOutput`> ; `route`: [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> }[]

The swaps of the trade, i.e. which routes and how much is swapped in each that make up the trade.

#### Defined in

[entities/trade.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L82)

------

### tradeType

• `Readonly` **tradeType**: `TTradeType`

The type of the trade, either exact in or exact out.

#### Defined in

[entities/trade.ts:91](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L91)

## Accessors

### executionPrice

• `get` **executionPrice**(): `Price`<`TInput`, `TOutput`>

The price expressed in terms of output amount/input amount.

#### Returns

`Price`<`TInput`, `TOutput`>

#### Defined in

[entities/trade.ts:148](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L148)

------

### inputAmount

• `get` **inputAmount**(): `CurrencyAmount`<`TInput`>

The input amount for the trade assuming no slippage.

#### Returns

`CurrencyAmount`<`TInput`>

#### Defined in

[entities/trade.ts:102](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L102)

------

### outputAmount

• `get` **outputAmount**(): `CurrencyAmount`<`TOutput`>

The output amount for the trade assuming no slippage.

#### Returns

`CurrencyAmount`<`TOutput`>

#### Defined in

[entities/trade.ts:125](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L125)

------

### priceImpact

• `get` **priceImpact**(): `Percent`

Returns the percent difference between the route's mid price and the price impact

#### Returns

```
Percent
```

#### Defined in

[entities/trade.ts:169](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L169)

------

### route

• `get` **route**(): [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`>

**`Deprecated`**

Deprecated in favor of 'swaps' property. If the trade consists of multiple routes this will return an error.

When the trade consists of just a single route, this returns the route of the trade, i.e. which pools the trade goes through.

#### Returns

[`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`>

#### Defined in

[entities/trade.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L73)

## Methods

### maximumAmountIn

▸ **maximumAmountIn**(`slippageTolerance`, `amountIn?`): `CurrencyAmount`<`TInput`>

Get the maximum amount in that can be spent via this trade for the given slippage tolerance

#### Parameters

| Name                | Type                       | Description                                                  |
| :------------------ | :------------------------- | :----------------------------------------------------------- |
| `slippageTolerance` | `Percent`                  | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountIn`          | `CurrencyAmount`<`TInput`> | -                                                            |

#### Returns

`CurrencyAmount`<`TInput`>

The amount in

#### Defined in

[entities/trade.ts:456](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L456)

------

### minimumAmountOut

▸ **minimumAmountOut**(`slippageTolerance`, `amountOut?`): `CurrencyAmount`<`TOutput`>

Get the minimum amount that must be received from this trade for the given slippage tolerance

#### Parameters

| Name                | Type                        | Description                                                  |
| :------------------ | :-------------------------- | :----------------------------------------------------------- |
| `slippageTolerance` | `Percent`                   | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountOut`         | `CurrencyAmount`<`TOutput`> | -                                                            |

#### Returns

`CurrencyAmount`<`TOutput`>

The amount out

#### Defined in

[entities/trade.ts:438](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L438)

------

### worstExecutionPrice

▸ **worstExecutionPrice**(`slippageTolerance`): `Price`<`TInput`, `TOutput`>

Return the execution price after accounting for slippage tolerance

#### Parameters

| Name                | Type      | Description                    |
| :------------------ | :-------- | :----------------------------- |
| `slippageTolerance` | `Percent` | the allowed tolerated slippage |

#### Returns

`Price`<`TInput`, `TOutput`>

The execution price

#### Defined in

[entities/trade.ts:471](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L471)

------

### bestTradeExactIn

▸ `Static` **bestTradeExactIn**<`TInput`, `TOutput`>(`pools`, `currencyAmountIn`, `currencyOut`, `__namedParameters?`, `currentPools?`, `nextAmountIn?`, `bestTrades?`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_INPUT`>[]>

Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token amount to an output token, making at most `maxHops` hops. Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting the amount in among multiple routes.

#### Type parameters

| Name      | Type               |
| :-------- | :----------------- |
| `TInput`  | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name                | Type                                                         | Default value      | Description                                                  |
| :------------------ | :----------------------------------------------------------- | :----------------- | :----------------------------------------------------------- |
| `pools`             | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[] | `undefined`        | the pools to consider in finding the best trade              |
| `currencyAmountIn`  | `CurrencyAmount`<`TInput`>                                   | `undefined`        | used in recursion; the original value of the currencyAmountIn parameter |
| `currencyOut`       | `TOutput`                                                    | `undefined`        | the desired currency out                                     |
| `__namedParameters` | [`BestTradeOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions) | `{}`               | -                                                            |
| `currentPools`      | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[] | `[]`               | used in recursion; the current list of pools                 |
| `nextAmountIn`      | `CurrencyAmount`<`Currency`>                                 | `currencyAmountIn` | exact amount of input currency to spend                      |
| `bestTrades`        | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_INPUT`>[] | `[]`               | used in recursion; the current list of best trades           |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_INPUT`>[]>

The exact in trade

#### Defined in

[entities/trade.ts:495](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L495)

------

### bestTradeExactOut

▸ `Static` **bestTradeExactOut**<`TInput`, `TOutput`>(`pools`, `currencyIn`, `currencyAmountOut`, `__namedParameters?`, `currentPools?`, `nextAmountOut?`, `bestTrades?`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_OUTPUT`>[]>

similar to the above method but instead targets a fixed output amount given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token to an output token amount, making at most `maxHops` hops note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting the amount in among multiple routes.

#### Type parameters

| Name      | Type               |
| :-------- | :----------------- |
| `TInput`  | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name                | Type                                                         | Default value       | Description                                        |
| :------------------ | :----------------------------------------------------------- | :------------------ | :------------------------------------------------- |
| `pools`             | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[] | `undefined`         | the pools to consider in finding the best trade    |
| `currencyIn`        | `TInput`                                                     | `undefined`         | the currency to spend                              |
| `currencyAmountOut` | `CurrencyAmount`<`TOutput`>                                  | `undefined`         | the desired currency amount out                    |
| `__namedParameters` | [`BestTradeOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions) | `{}`                | -                                                  |
| `currentPools`      | [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)[] | `[]`                | used in recursion; the current list of pools       |
| `nextAmountOut`     | `CurrencyAmount`<`Currency`>                                 | `currencyAmountOut` | the exact amount of currency out                   |
| `bestTrades`        | [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_OUTPUT`>[] | `[]`                | used in recursion; the current list of best trades |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_OUTPUT`>[]>

The exact out trade

#### Defined in

[entities/trade.ts:576](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L576)

------

### createUncheckedTrade

▸ `Static` **createUncheckedTrade**<`TInput`, `TOutput`, `TTradeType`>(`constructorArguments`): [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>

Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data

#### Type parameters

| Name         | Type                | Description                                         |
| :----------- | :------------------ | :-------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20          |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20         |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Name                                | Type                                                         | Description                                   |
| :---------------------------------- | :----------------------------------------------------------- | :-------------------------------------------- |
| `constructorArguments`              | `Object`                                                     | The arguments passed to the trade constructor |
| `constructorArguments.inputAmount`  | `CurrencyAmount`<`TInput`>                                   | -                                             |
| `constructorArguments.outputAmount` | `CurrencyAmount`<`TOutput`>                                  | -                                             |
| `constructorArguments.route`        | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> | -                                             |
| `constructorArguments.tradeType`    | `TTradeType`                                                 | -                                             |

#### Returns

[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>

The unchecked trade

#### Defined in

[entities/trade.ts:346](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L346)

------

### createUncheckedTradeWithMultipleRoutes

▸ `Static` **createUncheckedTradeWithMultipleRoutes**<`TInput`, `TOutput`, `TTradeType`>(`constructorArguments`): [`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>

Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data

#### Type parameters

| Name         | Type                | Description                                         |
| :----------- | :------------------ | :-------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20          |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20         |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Name                             | Type                                                         | Description                                   |
| :------------------------------- | :----------------------------------------------------------- | :-------------------------------------------- |
| `constructorArguments`           | `Object`                                                     | The arguments passed to the trade constructor |
| `constructorArguments.routes`    | { `inputAmount`: `CurrencyAmount`<`TInput`> ; `outputAmount`: `CurrencyAmount`<`TOutput`> ; `route`: [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> }[] | -                                             |
| `constructorArguments.tradeType` | `TTradeType`                                                 | -                                             |

#### Returns

[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>

The unchecked trade

#### Defined in

[entities/trade.ts:377](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L377)

------

### exactIn

▸ `Static` **exactIn**<`TInput`, `TOutput`>(`route`, `amountIn`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_INPUT`>>

Constructs an exact in trade with the given amount in and route

#### Type parameters

| Name      | Type               | Description                                 |
| :-------- | :----------------- | :------------------------------------------ |
| `TInput`  | extends `Currency` | The input token, either Ether or an ERC-20  |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name       | Type                                                         | Description                     |
| :--------- | :----------------------------------------------------------- | :------------------------------ |
| `route`    | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> | The route of the exact in trade |
| `amountIn` | `CurrencyAmount`<`TInput`>                                   | The amount being passed in      |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_INPUT`>>

The exact in trade

#### Defined in

[entities/trade.ts:194](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L194)

------

### exactOut

▸ `Static` **exactOut**<`TInput`, `TOutput`>(`route`, `amountOut`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_OUTPUT`>>

Constructs an exact out trade with the given amount out and route

#### Type parameters

| Name      | Type               | Description                                 |
| :-------- | :----------------- | :------------------------------------------ |
| `TInput`  | extends `Currency` | The input token, either Ether or an ERC-20  |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name        | Type                                                         | Description                      |
| :---------- | :----------------------------------------------------------- | :------------------------------- |
| `route`     | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> | The route of the exact out trade |
| `amountOut` | `CurrencyAmount`<`TOutput`>                                  | The amount returned by the trade |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `EXACT_OUTPUT`>>

The exact out trade

#### Defined in

[entities/trade.ts:209](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L209)

------

### fromRoute

▸ `Static` **fromRoute**<`TInput`, `TOutput`, `TTradeType`>(`route`, `amount`, `tradeType`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>>

Constructs a trade by simulating swaps through the given route

#### Type parameters

| Name         | Type                | Description                                          |
| :----------- | :------------------ | :--------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20.          |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20.         |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Name        | Type                                                         | Description                                                  |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `route`     | [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> | route to swap through                                        |
| `amount`    | `TTradeType` extends `EXACT_INPUT` ? `CurrencyAmount`<`TInput`> : `CurrencyAmount`<`TOutput`> | the amount specified, either input or output, depending on tradeType |
| `tradeType` | `TTradeType`                                                 | whether the trade is an exact input or exact output swap     |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>>

The route

#### Defined in

[entities/trade.ts:226](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L226)

------

### fromRoutes

▸ `Static` **fromRoutes**<`TInput`, `TOutput`, `TTradeType`>(`routes`, `tradeType`): `Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>>

Constructs a trade from routes by simulating swaps

#### Type parameters

| Name         | Type                | Description                                          |
| :----------- | :------------------ | :--------------------------------------------------- |
| `TInput`     | extends `Currency`  | The input token, either Ether or an ERC-20.          |
| `TOutput`    | extends `Currency`  | The output token, either Ether or an ERC-20.         |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Name        | Type                                                         | Description                                                  |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `routes`    | { `amount`: `TTradeType` extends `EXACT_INPUT` ? `CurrencyAmount`<`TInput`> : `CurrencyAmount`<`TOutput`> ; `route`: [`Route`](https://docs.uniswap.org/sdk/v3/reference/classes/Route)<`TInput`, `TOutput`> }[] | the routes to swap through and how much of the amount should be routed through each |
| `tradeType` | `TTradeType`                                                 | whether the trade is an exact input or exact output swap     |

#### Returns

`Promise`<[`Trade`](https://docs.uniswap.org/sdk/v3/reference/classes/Trade)<`TInput`, `TOutput`, `TTradeType`>>

The trade

#### Defined in

[entities/trade.ts:276](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L276)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceenums[FeeAmount](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / FeeAmount

# Enumeration: FeeAmount

The default factory enabled fee amounts, denominated in hundredths of bips.

## Table of contents

### Enumeration Members

- [HIGH](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount#high)
- [LOW](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount#low)
- [LOWEST](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount#lowest)
- [MEDIUM](https://docs.uniswap.org/sdk/v3/reference/enums/FeeAmount#medium)

## Enumeration Members

### HIGH

• **HIGH** = `10000`

#### Defined in

[constants.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L14)

------

### LOW

• **LOW** = `500`

#### Defined in

[constants.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L12)

------

### LOWEST

• **LOWEST** = `100`

#### Defined in

[constants.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L11)

------

### MEDIUM

• **MEDIUM** = `3000`

#### Defined in

[constants.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L13)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[AllowedPermitArguments](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / AllowedPermitArguments

# Interface: AllowedPermitArguments

## Table of contents

### Properties

- [expiry](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments#expiry)
- [nonce](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments#nonce)
- [r](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments#r)
- [s](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments#s)
- [v](https://docs.uniswap.org/sdk/v3/reference/interfaces/AllowedPermitArguments#v)

## Properties

### expiry

• **expiry**: `BigintIsh`

#### Defined in

[selfPermit.ts:19](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L19)

------

### nonce

• **nonce**: `BigintIsh`

#### Defined in

[selfPermit.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L18)

------

### r

• **r**: `string`

#### Defined in

[selfPermit.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L16)

------

### s

• **s**: `string`

#### Defined in

[selfPermit.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L17)

------

### v

• **v**: `0` | `1` | `27` | `28`

#### Defined in

[selfPermit.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L15)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[BestTradeOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / BestTradeOptions

# Interface: BestTradeOptions

## Table of contents

### Properties

- [maxHops](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions#maxhops)
- [maxNumResults](https://docs.uniswap.org/sdk/v3/reference/interfaces/BestTradeOptions#maxnumresults)

## Properties

### maxHops

• `Optional` **maxHops**: `number`

#### Defined in

[entities/trade.ts:50](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L50)

------

### maxNumResults

• `Optional` **maxNumResults**: `number`

#### Defined in

[entities/trade.ts:48](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L48)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[ClaimOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / ClaimOptions

# Interface: ClaimOptions

Options to specify when claiming rewards.

## Table of contents

### Properties

- [amount](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions#amount)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions#recipient)
- [tokenId](https://docs.uniswap.org/sdk/v3/reference/interfaces/ClaimOptions#tokenid)

## Properties

### amount

• `Optional` **amount**: `BigintIsh`

The amount of `rewardToken` to claim. 0 claims all.

#### Defined in

[staker.ts:52](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L52)

------

### recipient

• **recipient**: `string`

Address to send rewards to.

#### Defined in

[staker.ts:47](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L47)

------

### tokenId

• **tokenId**: `BigintIsh`

The id of the NFT

#### Defined in

[staker.ts:42](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L42)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[CollectOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / CollectOptions

# Interface: CollectOptions

## Table of contents

### Properties

- [expectedCurrencyOwed0](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions#expectedcurrencyowed0)
- [expectedCurrencyOwed1](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions#expectedcurrencyowed1)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions#recipient)
- [tokenId](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions#tokenid)

## Properties

### expectedCurrencyOwed0

• **expectedCurrencyOwed0**: `CurrencyAmount`<`Currency`>

Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned

#### Defined in

[nonfungiblePositionManager.ts:114](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L114)

------

### expectedCurrencyOwed1

• **expectedCurrencyOwed1**: `CurrencyAmount`<`Currency`>

Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned

#### Defined in

[nonfungiblePositionManager.ts:119](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L119)

------

### recipient

• **recipient**: `string`

The account that should receive the tokens.

#### Defined in

[nonfungiblePositionManager.ts:124](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L124)

------

### tokenId

• **tokenId**: `BigintIsh`

Indicates the ID of the position to collect for.

#### Defined in

[nonfungiblePositionManager.ts:109](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L109)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[CommonAddLiquidityOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / CommonAddLiquidityOptions

# Interface: CommonAddLiquidityOptions

Options for producing the calldata to add liquidity.

## Table of contents

### Properties

- [deadline](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions#deadline)
- [slippageTolerance](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions#slippagetolerance)
- [token0Permit](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions#token0permit)
- [token1Permit](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions#token1permit)
- [useNative](https://docs.uniswap.org/sdk/v3/reference/interfaces/CommonAddLiquidityOptions#usenative)

## Properties

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[nonfungiblePositionManager.ts:56](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L56)

------

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the pool price is allowed to move.

#### Defined in

[nonfungiblePositionManager.ts:51](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L51)

------

### token0Permit

• `Optional` **token0Permit**: [`PermitOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#permitoptions)

The optional permit parameters for spending token0

#### Defined in

[nonfungiblePositionManager.ts:66](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L66)

------

### token1Permit

• `Optional` **token1Permit**: [`PermitOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#permitoptions)

The optional permit parameters for spending token1

#### Defined in

[nonfungiblePositionManager.ts:71](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L71)

------

### useNative

• `Optional` **useNative**: `NativeCurrency`

Whether to spend ether. If true, one of the pool tokens must be WETH, by default false

#### Defined in

[nonfungiblePositionManager.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L61)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[FeeOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / FeeOptions

# Interface: FeeOptions

## Table of contents

### Properties

- [fee](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions#fee)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions#recipient)

## Properties

### fee

• **fee**: `Percent`

The percent of the output that will be taken as a fee.

#### Defined in

[payments.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L11)

------

### recipient

• **recipient**: `string`

The recipient of the fee.

#### Defined in

[payments.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L16)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[IncentiveKey](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / IncentiveKey

# Interface: IncentiveKey

Represents a unique staking program.

## Table of contents

### Properties

- [endTime](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey#endtime)
- [pool](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey#pool)
- [refundee](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey#refundee)
- [rewardToken](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey#rewardtoken)
- [startTime](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncentiveKey#starttime)

## Properties

### endTime

• **endTime**: `BigintIsh`

The time that the incentive program ends.

#### Defined in

[staker.ts:28](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L28)

------

### pool

• **pool**: [`Pool`](https://docs.uniswap.org/sdk/v3/reference/classes/Pool)

The pool that the staked positions must provide in.

#### Defined in

[staker.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L20)

------

### refundee

• **refundee**: `string`

The address which receives any remaining reward tokens at `endTime`.

#### Defined in

[staker.ts:32](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L32)

------

### rewardToken

• **rewardToken**: `Token`

The token rewarded for participating in the staking program.

#### Defined in

[staker.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L16)

------

### startTime

• **startTime**: `BigintIsh`

The time when the incentive program begins.

#### Defined in

[staker.ts:24](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L24)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[IncreaseSpecificOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncreaseSpecificOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / IncreaseSpecificOptions

# Interface: IncreaseSpecificOptions

## Table of contents

### Properties

- [tokenId](https://docs.uniswap.org/sdk/v3/reference/interfaces/IncreaseSpecificOptions#tokenid)

## Properties

### tokenId

• **tokenId**: `BigintIsh`

Indicates the ID of the position to increase liquidity for.

#### Defined in

[nonfungiblePositionManager.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L41)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[MethodParameters](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / MethodParameters

# Interface: MethodParameters

Generated method parameters for executing a call.

## Table of contents

### Properties

- [calldata](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters#calldata)
- [value](https://docs.uniswap.org/sdk/v3/reference/interfaces/MethodParameters#value)

## Properties

### calldata

• **calldata**: `string`

The hex encoded calldata to perform the given operation

#### Defined in

[utils/calldata.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L11)

------

### value

• **value**: `string`

The amount of ether (wei) to send in hex.

#### Defined in

[utils/calldata.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L15)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[MintSpecificOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/MintSpecificOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / MintSpecificOptions

# Interface: MintSpecificOptions

## Table of contents

### Properties

- [createPool](https://docs.uniswap.org/sdk/v3/reference/interfaces/MintSpecificOptions#createpool)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/MintSpecificOptions#recipient)

## Properties

### createPool

• `Optional` **createPool**: `boolean`

Creates pool if not initialized before mint.

#### Defined in

[nonfungiblePositionManager.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L34)

------

### recipient

• **recipient**: `string`

The account that should receive the minted NFT.

#### Defined in

[nonfungiblePositionManager.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L29)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[NFTPermitOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / NFTPermitOptions

# Interface: NFTPermitOptions

## Table of contents

### Properties

- [deadline](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions#deadline)
- [r](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions#r)
- [s](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions#s)
- [spender](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions#spender)
- [v](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions#v)

## Properties

### deadline

• **deadline**: `BigintIsh`

#### Defined in

[nonfungiblePositionManager.ts:131](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L131)

------

### r

• **r**: `string`

#### Defined in

[nonfungiblePositionManager.ts:129](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L129)

------

### s

• **s**: `string`

#### Defined in

[nonfungiblePositionManager.ts:130](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L130)

------

### spender

• **spender**: `string`

#### Defined in

[nonfungiblePositionManager.ts:132](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L132)

------

### v

• **v**: `0` | `1` | `27` | `28`

#### Defined in

[nonfungiblePositionManager.ts:128](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L128)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[QuoteOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/QuoteOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / QuoteOptions

# Interface: QuoteOptions

Optional arguments to send to the quoter.

## Table of contents

### Properties

- [sqrtPriceLimitX96](https://docs.uniswap.org/sdk/v3/reference/interfaces/QuoteOptions#sqrtpricelimitx96)
- [useQuoterV2](https://docs.uniswap.org/sdk/v3/reference/interfaces/QuoteOptions#usequoterv2)

## Properties

### sqrtPriceLimitX96

• `Optional` **sqrtPriceLimitX96**: `BigintIsh`

The optional price limit for the trade.

#### Defined in

[quoter.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L17)

------

### useQuoterV2

• `Optional` **useQuoterV2**: `boolean`

The optional quoter interface to use

#### Defined in

[quoter.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L22)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[RemoveLiquidityOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / RemoveLiquidityOptions

# Interface: RemoveLiquidityOptions

Options for producing the calldata to exit a position.

## Table of contents

### Properties

- [burnToken](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#burntoken)
- [collectOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#collectoptions)
- [deadline](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#deadline)
- [liquidityPercentage](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#liquiditypercentage)
- [permit](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#permit)
- [slippageTolerance](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#slippagetolerance)
- [tokenId](https://docs.uniswap.org/sdk/v3/reference/interfaces/RemoveLiquidityOptions#tokenid)

## Properties

### burnToken

• `Optional` **burnToken**: `boolean`

Whether the NFT should be burned if the entire position is being exited, by default false.

#### Defined in

[nonfungiblePositionManager.ts:162](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L162)

------

### collectOptions

• **collectOptions**: `Omit`<[`CollectOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/CollectOptions), `"tokenId"`>

Parameters to be passed on to collect

#### Defined in

[nonfungiblePositionManager.ts:172](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L172)

------

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[nonfungiblePositionManager.ts:157](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L157)

------

### liquidityPercentage

• **liquidityPercentage**: `Percent`

The percentage of position liquidity to exit.

#### Defined in

[nonfungiblePositionManager.ts:147](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L147)

------

### permit

• `Optional` **permit**: [`NFTPermitOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/NFTPermitOptions)

The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT

#### Defined in

[nonfungiblePositionManager.ts:167](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L167)

------

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the pool price is allowed to move.

#### Defined in

[nonfungiblePositionManager.ts:152](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L152)

------

### tokenId

• **tokenId**: `BigintIsh`

The ID of the token to exit

#### Defined in

[nonfungiblePositionManager.ts:142](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L142)





[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[SafeTransferOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SafeTransferOptions

# Interface: SafeTransferOptions

## Table of contents

### Properties

- [data](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions#data)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions#recipient)
- [sender](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions#sender)
- [tokenId](https://docs.uniswap.org/sdk/v3/reference/interfaces/SafeTransferOptions#tokenid)

## Properties

### data

• `Optional` **data**: `string`

The optional parameter that passes data to the `onERC721Received` call for the staker

#### Defined in

[nonfungiblePositionManager.ts:97](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L97)

------

### recipient

• **recipient**: `string`

The account that should receive the NFT.

#### Defined in

[nonfungiblePositionManager.ts:88](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L88)

------

### sender

• **sender**: `string`

The account sending the NFT.

#### Defined in

[nonfungiblePositionManager.ts:83](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L83)

------

### tokenId

• **tokenId**: `BigintIsh`

The id of the token being sent.

#### Defined in

[nonfungiblePositionManager.ts:93](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L93)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[StandardPermitArguments](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / StandardPermitArguments

# Interface: StandardPermitArguments

## Table of contents

### Properties

- [amount](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments#amount)
- [deadline](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments#deadline)
- [r](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments#r)
- [s](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments#s)
- [v](https://docs.uniswap.org/sdk/v3/reference/interfaces/StandardPermitArguments#v)

## Properties

### amount

• **amount**: `BigintIsh`

#### Defined in

[selfPermit.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L10)

------

### deadline

• **deadline**: `BigintIsh`

#### Defined in

[selfPermit.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L11)

------

### r

• **r**: `string`

#### Defined in

[selfPermit.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L8)

------

### s

• **s**: `string`

#### Defined in

[selfPermit.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L9)

------

### v

• **v**: `0` | `1` | `27` | `28`

#### Defined in

[selfPermit.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L7)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[SwapOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / SwapOptions

# Interface: SwapOptions

Options for producing the arguments to send calls to the router.

## Table of contents

### Properties

- [deadline](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#deadline)
- [fee](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#fee)
- [inputTokenPermit](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#inputtokenpermit)
- [recipient](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#recipient)
- [slippageTolerance](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#slippagetolerance)
- [sqrtPriceLimitX96](https://docs.uniswap.org/sdk/v3/reference/interfaces/SwapOptions#sqrtpricelimitx96)

## Properties

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[swapRouter.ts:30](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L30)

------

### fee

• `Optional` **fee**: [`FeeOptions`](https://docs.uniswap.org/sdk/v3/reference/interfaces/FeeOptions)

Optional information for taking a fee on output.

#### Defined in

[swapRouter.ts:45](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L45)

------

### inputTokenPermit

• `Optional` **inputTokenPermit**: [`PermitOptions`](https://docs.uniswap.org/sdk/v3/reference/modules.md#permitoptions)

The optional permit parameters for spending the input.

#### Defined in

[swapRouter.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L35)

------

### recipient

• **recipient**: `string`

The account that should receive the output.

#### Defined in

[swapRouter.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L25)

------

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the execution price is allowed to move unfavorably from the trade execution price.

#### Defined in

[swapRouter.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L20)

------

### sqrtPriceLimitX96

• `Optional` **sqrtPriceLimitX96**: `BigintIsh`

The optional price limit for the trade.

#### Defined in

[swapRouter.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L40)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[TickConstructorArgs](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickConstructorArgs

# Interface: TickConstructorArgs

## Table of contents

### Properties

- [index](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs#index)
- [liquidityGross](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs#liquiditygross)
- [liquidityNet](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickConstructorArgs#liquiditynet)

## Properties

### index

• **index**: `number`

#### Defined in

[entities/tick.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L7)

------

### liquidityGross

• **liquidityGross**: `BigintIsh`

#### Defined in

[entities/tick.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L8)

------

### liquidityNet

• **liquidityNet**: `BigintIsh`

#### Defined in

[entities/tick.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L9)

[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[TickDataProvider](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / TickDataProvider

# Interface: TickDataProvider

Provides information about ticks

## Implemented by

- [`NoTickDataProvider`](https://docs.uniswap.org/sdk/v3/reference/classes/NoTickDataProvider)
- [`TickListDataProvider`](https://docs.uniswap.org/sdk/v3/reference/classes/TickListDataProvider)

## Table of contents

### Methods

- [getTick](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#gettick)
- [nextInitializedTickWithinOneWord](https://docs.uniswap.org/sdk/v3/reference/interfaces/TickDataProvider#nextinitializedtickwithinoneword)

## Methods

### getTick

▸ **getTick**(`tick`): `Promise`<{ `liquidityNet`: `BigintIsh` }>

Return information corresponding to a specific tick

#### Parameters

| Name   | Type     | Description      |
| :----- | :------- | :--------------- |
| `tick` | `number` | the tick to load |

#### Returns

`Promise`<{ `liquidityNet`: `BigintIsh` }>

#### Defined in

[entities/tickDataProvider.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L11)

------

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`tick`, `lte`, `tickSpacing`): `Promise`<[`number`, `boolean`]>

Return the next tick that is initialized within a single word

#### Parameters

| Name          | Type      | Description                                          |
| :------------ | :-------- | :--------------------------------------------------- |
| `tick`        | `number`  | The current tick                                     |
| `lte`         | `boolean` | Whether the next tick should be lte the current tick |
| `tickSpacing` | `number`  | The tick spacing of the pool                         |

#### Returns

`Promise`<[`number`, `boolean`]>

#### Defined in

[entities/tickDataProvider.ts:19](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L19)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)v3 SDKTechnical Referenceinterfaces[WithdrawOptions](https://docs.uniswap.org/sdk/v3/reference/interfaces/WithdrawOptions)

[@uniswap/v3-sdk](https://docs.uniswap.org/sdk/v3/reference/README.md) / [Exports](https://docs.uniswap.org/sdk/v3/reference/modules.md) / WithdrawOptions

# Interface: WithdrawOptions

Options to specify when withdrawing a position.

## Table of contents

### Properties

- [data](https://docs.uniswap.org/sdk/v3/reference/interfaces/WithdrawOptions#data)
- [owner](https://docs.uniswap.org/sdk/v3/reference/interfaces/WithdrawOptions#owner)

## Properties

### data

• `Optional` **data**: `string`

Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.

#### Defined in

[staker.ts:66](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L66)

------

### owner

• **owner**: `string`

Set when withdrawing. The position will be sent to `owner` on withdraw.

#### Defined in

[staker.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L61)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)web3-react[Overview](https://docs.uniswap.org/sdk/web3-react/overview)

# `web3-react`

> **Welcome to `web3-react`!**

`web3-react` provides abstractions to assist you with connecting your dApp to web3 connectors and exposes methods to interact with those connections. It currently supports connecting to the following wallets:

- Network
- Injected wallets (eg MetaMask)
- Gnosis safe
- Coinbase wallet
- WalletConnect wallet

To begin, we recommend looking at our [guides](https://docs.uniswap.org/sdk/web3-react/guides/01-connect-wallet.md) which include [runnable examples](https://github.com/Uniswap/examples/tree/main/web3-react) and walkthroughs of core usages. These guides will help you better understand how to use `web3-react` and integrate it into your application.

info

This guide uses `web3-react` version 8, which is a beta version.

## Installation

`web3-react` consists of many packages, each providing different functionalities. The [core](https://www.npmjs.com/package/@web3-react/core) package exposes the methods used to interact with web3 connectors, the [types](https://www.npmjs.com/package/@web3-react/types) package declares useful types, while the others are installed to enable interactions with different connectors.

To interact with `web3-react` we recommend installing though npm:

```bash
npm install --save @web3-react/core
```



or yarn:

```bash
yarn add @web3-react/core
```



## Developer Links

- [**`web3-react` on GitHub**](https://github.com/Uniswap/web3-react)

[![npm version](https://img.shields.io/npm/v/@web3-react/core/latest.svg)](https://www.npmjs.com/package/@web3-react/core/v/latest)[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@web3-react/core/latest.svg)](https://bundlephobia.com/result?p=@web3-react/core@latest)[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)web3-reactGuides[Connecting to Wallets](https://docs.uniswap.org/sdk/web3-react/guides/connect-wallet)

# Connecting to Wallets

## Introduction

This guide will cover how to connect wallets with `web3-react`. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react) found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.

In this example we will walk through setting up `web3-react` and connecting the most popular browser-injected connector, [MetaMask](https://metamask.io/), using [@web3-react/metamask](https://www.npmjs.com/package/@web3-react/metamask).

The input parameters to this guide are the chains that we want our app to be able to connect to and their RPC URLs.

The guide will **cover**:

1. Creating a `web3-react` `Web3ReactProvider`
2. Building a `web3-react` `InjectedConnector`
3. Connecting and disconnecting the application to the connector

At the end of the guide, we should be able to connect and disconnect your dApp to a MetaMask connector.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)
- [`@web3-react/types`](https://www.npmjs.com/package/@web3-react/types)
- [`@web3-react/metamask`](https://www.npmjs.com/package/@web3-react/metamask)

info

This guide uses `web3-react` version 8, which is a beta version.

These will be automatically installed by following the example's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md).

The core code of this guide can be found in [Web3ContextProvider](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/components/Web3ContextProvider.tsx) and [InjectedConnector](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/injected.ts).

## Creating a `Web3ReactProvider`

To be able to interact with the methods that `web3-react` offers, we first need to setup a `Web3ReactProvider` and wrap our application in it. `web3-react` uses a [React `Context`](https://reactjs.org/docs/context.html) to allow us to use the exposed hooks without additional configuration.

To start, we create a React component called `Web3ContextProvider` in order to wrap the logic of configuring the `Web3ReactProvider`. In this component, we first import `Web3ReactProvider` from [@web3-react/core](https://www.npmjs.com/package/@web3-react/core).

The component receives just one prop which is the `children` to which it will be providing the `Context`:

Defining the Web3React component

```typescript
export const Web3ContextProvider = ({ children }: { children: ReactNode }) => {
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L24)

We then implement the component by rendering the imported `Web3ReactProvider` with the `children` within that:

Implementing the component

```typescript
<Web3ReactProvider
  connectors={Object.values(PRIORITIZED_CONNECTORS).map((connector) => [connector.connector, connector.hooks])}
>
  {children}
</Web3ReactProvider>
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L30-L34)

Note that we map our list of [`Connections`](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/connections.ts#L10) to a *tuple* of the `connector` and `hooks` of the connection. The third element of a `Connection` refers to the [type](https://github.com/Uniswap/examples/blob/06980acc8f6d484b719d2c60f5bfe9d766cb95d6/web3-react/src/libs/connections.ts#L16) of `Connection` being established, which we will later use to keep track of the actively connected wallet.

Finally, having created the `Web3ContextProvider` component, we can navigate to our [index file](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/index.tsx) and wrap the whole application with it:

Wrapping our app with the web3 context

```typescript
root.render(
  <React.StrictMode>
    <Web3Provider>
      <Example />
    </Web3Provider>
  </React.StrictMode>
)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/7ac3853bc465aecc428a32be584bbeb833b0a63c/web3-react/src/index.tsx#L16-L22)

## Building an Injected Connector

The only parameter that we provided to the `Web3ReactProvider` component is a list of prioritized connectors, declared as `PRIORITIZED_CONNECTORS`. The prioritization ordering is with regards to which connector we want to be active when more than one connector is connected to our application. The list is defined inside our connectors module:

Creating the prioritized Connectors list

```typescript
export const PRIORITIZED_CONNECTORS: { [key in ConnectionType]: Connection } = {
  [ConnectionType.INJECTED]: buildInjectedConnector(),
  [ConnectionType.COINBASE_WALLET]: buildCoinbaseWalletConnector(),
  [ConnectionType.WALLET_CONNECT]: buildWalletConnectConnector(),
  [ConnectionType.GNOSIS_SAFE]: buildGnosisSafeConnector(),
  [ConnectionType.NETWORK]: buildNetworkConnector(),
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L33-L39)

Each one of those connectors lives within its own file, and they all follow a similar setup pattern.

An example of a connector in the list is the `InjectedConnector`, which supports wallets that inject an *Ethereum Provider* into the browser window. The most popular example of an injected connector is the *MetaMask* browser extension. To set it up, we import `initializeConnector` function from [core](https://www.npmjs.com/package/@web3-react/core) and the `MetaMask` type from [metamask](https://www.npmjs.com/package/@web3-react/core):

Importing Connector dependencies

```typescript
import { initializeConnector } from '@web3-react/core'
import { MetaMask } from '@web3-react/metamask'
```



[View on GitHub](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/injected.ts#L1-L2)

We then utilize the templated `initializeConnector` function with `MetaMask` as the type argument:

Initializing the MetaMask connector

```typescript
const [web3MetamaskWallet, web3MetamaskWalletHooks] = initializeConnector<MetaMask>(
  (actions) => new MetaMask({ actions, onError: onConnectionError })
)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/injected.ts#L7-L9)

By passing in `MetaMask` as the type argument, we define the function's required input parameters. In this case, the only parameter we need to pass is an instance of `Metamask`, which receives the `actions` and `onError` parameters. The first parameter defines the actions that `web3-react` performs on its local store for the connector (this usually can be passed through without modification), while the second parameter is the callback invoked when an error occurs.

The return type of the function is a tuple of the initialized `Connector` and the `Hooks` that we can use on it. Using this tuple, we create an instance of a [`Connection`](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/connections.ts#L10) type, by setting the `type` property to `INJECTED`:

Creating a connection instance

```typescript
const injectedConnection: Connection = {
  connector: web3MetamaskWallet,
  hooks: web3MetamaskWalletHooks,
  type: ConnectionType.INJECTED,
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/injected.ts#L16-L20)

Finally, we return the instance of `Connection` we created, which is added to the list of prioritized connectors.

info

For help on creating the rest of the supported connectors of this examples, please visit our [connectors](https://docs.uniswap.org/sdk/web3-react/guides/connectors) page!

## Connecting and disconnecting the application to the connector

Having built our `InjectedConnector`, we can now use it in the Context that allows our application to use that connector:

Creating the Option component

```typescript
export const Option = ({
  isEnabled,
  isConnected,
  connectionType,
  onActivate,
  onDeactivate,
}: {
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Option.tsx#L5-L11)

The component receives 5 parameters:

- `isEnabled` determines whether the connector is eligible to be activated
- `isConnected` determines whether the connector is currently active
- `connectionType` determines the `ConnectionType`
- `onActivate` is called once the component has established a connection
- `onDeactivate` is called once the component has disconnected

In the case of *MetaMask*, when declaring the `InjectedConnector` we pass the connector-specific arguments:

Creating an injected connector

```typescript
<Option
  isEnabled={isNoOptionActive || activeConnectionType === ConnectionType.INJECTED}
  isConnected={activeConnectionType === ConnectionType.INJECTED}
  connectionType={ConnectionType.INJECTED}
  onActivate={onActivate}
  onDeactivate={onDeactivate}
/>
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L26-L32)

Then, in the `html` portion of the `Option`, we can figure out whether we want the current `Option`'s action button to be disabled, and whether clicking the button would result in the connector being connected or disconnected:

The component user interface

```typescript
<div>
  <button onClick={onClick} disabled={!isEnabled}>{`${
    isConnected ? 'Disconnect' : 'Connect'
  } ${connectionType}`}</button>
</div>
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Option.tsx#L38-L42)

Finally, we also have enough information to figure out what action to take when the button is clicked. In the case that the click triggers a connection:

On connecting to a Connector

```typescript
const activation = await tryActivateConnector(getConnection(connectionType).connector)
if (!activation) {
  return
}
onActivate(activation)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/components/Option.tsx#L38-L42)

To connect our wallet, all we need to do is to call the `tryActivateConnector` function and pass it the `InjectedConnector`. We then call the `onActivate` callback, which makes the `InjectedConnector` the active connector in our application's state.

`tryActivateConnector` takes as its argument the connector that we want to activate, and attempts to call `activate` on it. If this activation succeeds, it returns the new `ConnectionType`:

The implementation of tryActivateConnector

```typescript
await connector.activate()
const connectionType = getConnection(connector).type
return connectionType
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L90-L92)

In the case that the click triggers a disconnection:

On disconnecting from a Connector

```typescript
if (isOptionActive) {
  const deactivation = await tryDeactivateConnector(getConnection(connectionType).connector)
  if (deactivation === undefined) {
    return
  }
  onDeactivate(deactivation)
  return
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/components/Option.tsx#L29-L36)

To disconnect, all we need to do is to call `tryDeactivateConnector` and pass in it the `InjectedConnector` we created before. We then call the `onDeactivate` callback, which removes the `InjectedConnector` as the currently active connector from our application's state.

`tryDeactivateConnector` takes as its argument the connector that we want to deactivate, and attempts to call `deactivate` on it. If this deactivation succeeds, it resets the connector's state by calling `resetState` and returns `null`:

The implementation of tryDeactivateConnector

```typescript
connector.deactivate?.()
connector.resetState()
return null
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/connections.ts#L98-L100)

## Next Steps

Now that we have gone through connecting and disconnecting from an `InjectedConnector`, we will learn how to [connect and disconnect](https://docs.uniswap.org/sdk/web3-react/guides/02-connectors.md) from all the different types of connectors that `web3-react` supports.

[SDKs](https://docs.uniswap.org/sdk/v4/overview)web3-reactGuides[Supported Connectors](https://docs.uniswap.org/sdk/web3-react/guides/connectors)

# Supported Connectors

## Introduction

This guide will cover how to connect our dApp to all the different connectors that `web3-react` supports. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.

In this example we will cover connecting our dApp to the following connectors:

- Coinbase wallet
- WalletConnect wallet
- Network
- Gnosis safe

info

For help on setting up `web3-react` and interacting with a MetaMask wallet, please visit our [connecting to wallets](https://docs.uniswap.org/sdk/web3-react/guides/01-connect-wallet.md) page!

The input parameters to this guide are the chains that we want our dApp to be able to connect to and their RPC URLs.

The guide will **cover**:

1. Building a Coinbase Wallet connector
2. Building a WalletConnect Wallet connector
3. Building a Network connector
4. Building a Gnosis Safe connector

At the end of the guide, we should be able to connect and disconnect the application to the different connectors listed above.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)
- [`@web3-react/types`](https://www.npmjs.com/package/@web3-react/types)
- [`@web3-react/coinbase-wallet`](https://www.npmjs.com/package/@web3-react/coinbase-wallet)
- [`@web3-react/walletconnect`](https://www.npmjs.com/package/@web3-react/walletconnect)
- [`@web3-react/network`](https://www.npmjs.com/package/@web3-react/network)
- [`@web3-react/gnosis-safe`](https://www.npmjs.com/package/@web3-react/gnosis-safe)

info

This guide uses `web3-react` version 8, which is a beta version.

The core code of this guide can be found in the top level of our [examples repository](https://github.com/Uniswap/examples/tree/main/web3-react), under each connectors' name. For example, the code for the Coinbase Wallet connector can be found in the [coinbase file](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/coinbase.ts).

## Building a Coinbase Wallet connector

The second connector in the list of prioritized connectors that [we provided](https://docs.uniswap.org/sdk/web3-react/guides/01-connect-wallet.md/#building-an-injected-connector) as a parameter to [`Web3ReactProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) is the *Coinbase Wallet* connector:

Creating the prioritized Connectors list

```typescript
export const PRIORITIZED_CONNECTORS: { [key in ConnectionType]: Connection } = {
  [ConnectionType.INJECTED]: buildInjectedConnector(),
  [ConnectionType.COINBASE_WALLET]: buildCoinbaseWalletConnector(),
  [ConnectionType.WALLET_CONNECT]: buildWalletConnectConnector(),
  [ConnectionType.GNOSIS_SAFE]: buildGnosisSafeConnector(),
  [ConnectionType.NETWORK]: buildNetworkConnector(),
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L33-L39)

To connect to a *Coinbase Wallet* connector, we first need to install [`@web3-react/coinbase-wallet`](https://www.npmjs.com/package/@web3-react/coinbase-wallet), as well as [`@coinbase/wallet-sdk`](https://github.com/coinbase/coinbase-wallet-sdk). Having installed the packages, we can import the `CoinbaseWallet` class from `@web3-react/coinbase-wallet`, as well as the `initializeConnector` function from the `@web3-react/core` package:

Importing the Coinbase Wallet connector

```typescript
import { CoinbaseWallet } from '@web3-react/coinbase-wallet'
import { initializeConnector } from '@web3-react/core'
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L1-L2)

We can now build our connector, supplying the required arguments:

Initializing the Coinbase Wallet Connector

```typescript
const [web3CoinbaseWallet, web3CoinbaseWalletHooks] = initializeConnector<CoinbaseWallet>(
  (actions) =>
    new CoinbaseWallet({
      actions,
      options: {
        url: INPUT_CHAIN_URL,
        appName: 'Uniswap Example',
        reloadOnDisconnect: false,
      },
      onError: onConnectionError,
    })
)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L8-L19)

We pass `CoinbaseWallet` as the type argument to `initializeConnector`'s templated parameter. Similar to the case of the `InjectedConnector`, the `CoinbaseWallet` class is a class that extends the `AbstractConnector` class, which is part of the `@web3-react/core` package. The parameter provided to `initializeConnector` is a function that receives an `actions` object, and expects an instance of `CoinbaseWallet` (to match the type argument) to be returned.

We build the new `CoinbaseWallet` instance by passing the `actions` object, an `options` object, and an `onError` callback. `onError` handles errors that occur during interaction with the connector, and `options` is used to configure the connector. In our case, we pass the `url`, `appName` and `reloadOnDisconnect` options: `url` is the *RPC URL* to connect to that was provided as an argument to the example application, `appName` is the name of our application, and `reloadOnDisconnect` is a `boolean` that indicates whether the application should reload when the user disconnects from the wallet.

After building the connector, we use its two return types, the `Connector` and it's respective hooks, and build a `Connection` object by setting the connection's type as the Coinbase wallet:

Building the Coinbase Wallet Connection

```typescript
const coinbaseWalletConnection: Connection = {
  connector: web3CoinbaseWallet,
  hooks: web3CoinbaseWalletHooks,
  type: ConnectionType.COINBASE_WALLET,
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L20-L24)

Having built the connector, all that remains is to build the user interface and supply it to our [`ConnectionOptions`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/ConnectionOptions.tsx) component, just as we did with the `InjectedConnector`:

Building the Coinbase Wallet component

```typescript
const coinbaseWalletOption = (
  <Option
    isEnabled={isNoOptionActive || activeConnectionType === ConnectionType.COINBASE_WALLET}
    isConnected={activeConnectionType === ConnectionType.COINBASE_WALLET}
    connectionType={ConnectionType.COINBASE_WALLET}
    onActivate={onActivate}
    onDeactivate={onDeactivate}
  />
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L39-L46)

## Building a WalletConnect Wallet connector

The third connector in the list of prioritized connectors that we provided to [`Web3ReactProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) is the WalletConnect Wallet connector.

To connect to a WalletConnect Wallet connector, we first need to install [`@web3-react/walletconnect`](https://www.npmjs.com/package/@web3-react/walletconnect), as well as [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/@walletconnect/ethereum-provider). Having installed the packages, we can import the `WalletConnect` class from `@web3-react/walletconnect`, as well as the `initializeConnector` function from`@web3-react/core` package:

Importing the WalletConnect Wallet Connector

```typescript
import { initializeConnector } from '@web3-react/core'
import { WalletConnect } from '@web3-react/walletconnect'
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/wallet-connect.ts#L1-L2)

We can now build our connector, supplying the required arguments:

Initializing the WalletConnect Wallet Connector

```typescript
const [web3WalletConnect, web3WalletConnectHooks] = initializeConnector<WalletConnect>((actions) => {
  return new WalletConnect({
    actions,
    options: {
      rpc: CHAIN_TO_URL_MAP,
      qrcode: true,
    },
    onError: onConnectionError,
  })
})
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/wallet-connect.ts#L8-L17)

The main difference from the Coinbase Wallet connector lies in the arguments that the `WalletConnect` class requires to be instantiated. `web3-react` knows about this difference, as we passed the type argument `WalletConnect` to `initializeConnector`, thus specializing the type of `AbstractConnector`. In this case, the class receives three arguments, including `actions` and `onError`, identical to those supplied in the Coinbase Wallet connector case.

The difference lies in the second argument, which is an `options` object. In this case, we are passing the `rpc` parameter, which is an object that maps the chain ID to the RPC URL to connect to. We have already created this [map](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/constants.ts#L11) in our [`constants`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/constants.ts) file using our example's parameters. The other option that we are passing is the `qrcode`, which is a `boolean` that indicates whether the QR code should be displayed in the browser. In our case, we are passing `true` as we want to show the QR code.

Having built the connector, we just need to build the user interface to enable user interaction with the connector, and supply it to our `ConnectionOptions`:

Building the WalletConnect Wallet component

```typescript
const walletConnectOption = (
  <Option
    isEnabled={isNoOptionActive || activeConnectionType === ConnectionType.WALLET_CONNECT}
    isConnected={activeConnectionType === ConnectionType.WALLET_CONNECT}
    connectionType={ConnectionType.WALLET_CONNECT}
    onActivate={onActivate}
    onDeactivate={onDeactivate}
  />
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L49-L56)

## Building a Network connector

The *Network connector*, alongside the *Gnosis Safe connector*, are two of the connectors that we do not surface through our user interface, but instead we connect to them programmatically. In contrast to the previous *Connectors*, these do not come with any pre-built user interface for the user to interact with. We attempt to connect to them **eagerly** in our [`Web3ContextProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) component through a hook:

Hook to connect eagerly

```typescript
if (connector.connectEagerly) {
  await connector.connectEagerly()
} else {
  await connector.activate()
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L9-L13)

The `useEagerlyConnect` hook is called in the `Web3ContextProvider` component and attempts to connect to the Network Connector and the Gnosis Safe Connector. The hook is named **eagerly** as it is called in the component's body as [React effect](https://reactjs.org/docs/hooks-effect.html) when the component is first rendered. In the hook implementation we attempt to call `web3-react`'s `connectEagerly` function if it exists on the connector, otherwise we call `activate` otherwise. The `connectEagerly` function attempts to connect our application to the connector, and **fails silently** if it does not succeed:

Connecting eagerly

```typescript
if (connector.connectEagerly) {
  await connector.connectEagerly()
} else {
  await connector.activate()
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/hooks.ts#L15-L19)

Before eagerly connecting, we first need to initialize the connectors. We start by building the Network connector, and we first need to install [`@web3-react/network`](https://www.npmjs.com/package/@web3-react/network), and import the `Network` class from it. Note how this Connect does not require any package besides its `web3-react` package to function. We also need to import the `initializeConnector` function from `@web3-react/core`:

Importing the Network Connector

```typescript
import { initializeConnector } from '@web3-react/core'
import { Network } from '@web3-react/network'
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L1-L2)

We can now build our connector, supplying the required arguments:

Initializing the Network Connector

```typescript
const [web3Network, web3NetworkHooks] = initializeConnector<Network>(
  (actions) =>
    new Network({
      actions,
      urlMap: CHAIN_TO_URL_MAP,
      defaultChainId: INPUT_CHAIN_ID,
    })
)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L8-L15)

The main difference from the other connectors lies in the arguments that the `Network` class requires to be instantiated. `web3-react` knows about this difference, as we passed the type argument `Network` to `initializeConnector`, thus specializing the type of `AbstractConnector`. In this case, the class receives `actions`, which is identical to that supplied in the rest of the connectors; `urlMap`, which is an object that maps the chain ID to the RPC URL to connect to, which we have already created in our [`constants`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/constants.ts) file; and `defaultChainId` which is the chain ID to connect to by default.

After building, the connector, we can create a `Connection` instance by supplying it the return value of the `initializeConnector` function, and the `Network` class:

Creating a Network connection

```typescript
const networkConnection: Connection = {
  connector: web3Network,
  hooks: web3NetworkHooks,
  type: ConnectionType.NETWORK,
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L16-L20)

All that remains is to return the constructed `Connection` instance.

## Building a Gnosis Safe connector

Similar to the Network connector, we build the Gnosis Safe connector. We start by first installing [`@web3-react/gnosis-safe`](https://www.npmjs.com/package/@web3-react/gnosis-safe), and import the `GnosisSafe` class from it. We also need to import the `initializeConnector` function from `@web3-react/core`:

Importing the Gnosis Safe connector

```typescript
import { initializeConnector } from '@web3-react/core'
import { GnosisSafe } from '@web3-react/gnosis-safe'
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L1-L2)

The Gnosis Safe connector is the simplest of them all, as it does not require any additional parameterization other than `actions`:

Initializing a Gnosis Safe Connector

```typescript
export function buildGnosisSafeConnector() {
  const [web3GnosisSafe, web3GnosisSafeHooks] = initializeConnector<GnosisSafe>(
    (actions) => new GnosisSafe({ actions })
  )
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L6-L9)

Having initialized the connector, we can now build the `Connection` instance and return it:

Creating a Gnosis Safe Connection

```typescript
const gnosisSafeConnection: Connection = {
  connector: web3GnosisSafe,
  hooks: web3GnosisSafeHooks,
  type: ConnectionType.GNOSIS_SAFE,
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L10-L14)

## Next steps

Now that we have gone through building all of the different types of supported connectors, we will learn how to [switch chains](https://docs.uniswap.org/sdk/web3-react/guides/03-switch-chains.md).



[SDKs](https://docs.uniswap.org/sdk/v4/overview)web3-reactGuides[Switching Chains](https://docs.uniswap.org/sdk/web3-react/guides/switch-chains)

# Switching Chains

## Introduction

This guide will cover how to prompt a wallet that has connected to our dApp to switch chains using `web3-react`. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.

info

For help on setting up `web3-react` and interacting with a MetaMask wallet, please visit our [connecting to wallets](https://docs.uniswap.org/sdk/web3-react/guides/01-connect-wallet.md) page!

The input parameters to this guide are the chains that we want our dApp to be able to connect to and their RPC URLs.

At the end of the guide, we should be able to switch chains on the connected wallet.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)

info

This guide uses `web3-react` version 8, which is a beta version.

The core code of this guide can be found in [connections](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/connections.ts).

## Switching Chains

Having [setup our application](https://docs.uniswap.org/sdk/web3-react/guides/01-connect-wallet.md) to use `web3-react` and having built out the ability to [connect and disconnect wallets](https://docs.uniswap.org/sdk/web3-react/guides/02-connectors.md), we can now move on to switching chains.

Switching chains requires two parameters, the `chainId` we want to switch to, and the current `connectionType`:

Defining the function

```typescript
export const switchNetwork = async (chainId: number, connectionType: ConnectionType | null) => {
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L64)

Given the `ConnectionType`, we can retrieve the actual connector:

Retrieving the connector

```typescript
const { connector } = getConnection(connectionType)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L69)

Then, depending on the `ConnectionType`, we determine how to switch chains. For the `Network` or `WalletConnect` cases, we call `web3-react`'s `activate` function with the supplied `chainId`:

Switching chains for Network and WalletConnect

```typescript
if (connectionType === ConnectionType.WALLET_CONNECT || connectionType === ConnectionType.NETWORK) {
  await connector.activate(chainId)
  return
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L71-L74)

The rest of the connectors require us to build an `AddEthereumChainParameter` object and pass it to the `web3-react`'s `activate` function:

Switching chains the other Connectors

```typescript
const addChainParameter: AddEthereumChainParameter = {
  chainId,
  chainName: chainInfo.label,
  rpcUrls: [chainInfo.rpcUrl],
  nativeCurrency: chainInfo.nativeCurrency,
  blockExplorerUrls: [chainInfo.explorer],
}
await connector.activate(addChainParameter)
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L77-L84)

The metadata required to build `AddEthereumChainParameter` are defined in our constants file:

Defining the chain parameters

```typescript
export const CHAIN_INFO: { [key: string]: ChainInfo } = {
  [MAINNET_CHAIN_ID]: {
    explorer: 'https://etherscan.io/',
    label: 'Ethereum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrl: CurrentConfig.rpc.mainnet,
  },
  [POLYGON_CHAIN_ID]: {
    explorer: 'https://polygonscan.com/',
    label: 'Polygon',
    nativeCurrency: { name: 'Polygon Matic', symbol: 'MATIC', decimals: 18 },
    rpcUrl: CurrentConfig.rpc.polygon,
  },
}
```



[View on GitHub](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/constants.ts#L27-L40)

## Next steps

Now you know how to support `web3-react`'s most common use cases! Stay tuned for follow up guides.



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Overview](https://docs.uniswap.org/sdk/core/overview)

# Overview

## The Uniswap Core SDK

The Uniswap Core SDK provides abstractions for other SDKs to use in a Typescript/Javascript environment. It is used throughout the Uniswap SDKs, such as the [v3 SDK](https://docs.uniswap.org/sdk/v3/overview).

This SDK is not expected to be used in isolation, but only as part of other SDKs.

We recommend taking a look at the [**Technical Reference**](https://docs.uniswap.org/sdk/core/reference/overview).

## Resources

- [**SDK Core GitHub Repo**](https://github.com/Uniswap/sdk-core)
- [**Core SDK NPM Package**](https://www.npmjs.com/package/@uniswap/sdk-core)

[![Unit Tests](https://github.com/Uniswap/uniswap-sdk-core/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/uniswap-sdk-core/actions?query=workflow%3A"Unit+Tests")[![Lint](https://github.com/Uniswap/uniswap-sdk-core/workflows/Lint/badge.svg)](https://github.com/Uniswap/uniswap-sdk-core/actions?query=workflow%3ALint)[![npm version](https://img.shields.io/npm/v/@uniswap/sdk-core/latest.svg)](https://www.npmjs.com/package/@uniswap/sdk-core/v/latest)[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/sdk-core/latest.svg)](https://bundlephobia.com/result?p=@uniswap/sdk-core@latest)[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)[Overview](https://docs.uniswap.org/sdk/core/reference/overview)

# Overview

## Table of contents

### Enumerations

- [Rounding](https://docs.uniswap.org/sdk/core/reference/enums/Rounding)
- [ChainId](https://docs.uniswap.org/sdk/core/reference/enums/ChainId)
- [NativeCurrencyName](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName)
- [TradeType](https://docs.uniswap.org/sdk/core/reference/enums/TradeType)

### Classes

- [CurrencyAmount](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)
- [Ether](https://docs.uniswap.org/sdk/core/reference/classes/Ether)
- [Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)
- [NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency)
- [Percent](https://docs.uniswap.org/sdk/core/reference/classes/Percent)
- [Price](https://docs.uniswap.org/sdk/core/reference/classes/Price)
- [Token](https://docs.uniswap.org/sdk/core/reference/classes/Token)

### Type Aliases

- [BigintIsh](https://docs.uniswap.org/sdk/core/reference/overview#bigintish)
- [Currency](https://docs.uniswap.org/sdk/core/reference/overview#currency)

### Variables

- [MaxUint256](https://docs.uniswap.org/sdk/core/reference/overview#maxuint256)
- [WETH9](https://docs.uniswap.org/sdk/core/reference/overview#weth9)

### Functions

- [computePriceImpact](https://docs.uniswap.org/sdk/core/reference/overview#computepriceimpact)
- [sortedInsert](https://docs.uniswap.org/sdk/core/reference/overview#sortedinsert)
- [sqrt](https://docs.uniswap.org/sdk/core/reference/overview#sqrt)
- [validateAndParseAddress](https://docs.uniswap.org/sdk/core/reference/overview#validateandparseaddress)

## Type Aliases

### BigintIsh

Ƭ **BigintIsh**: `JSBI` | `string` | `number`

#### Defined in

[constants.ts:24](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L24)

------

### Currency

Ƭ **Currency**: [`NativeCurrency`](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency) | [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

#### Defined in

[entities/currency.ts:4](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/currency.ts#L4)

## Variables

### MaxUint256

• `Const` **MaxUint256**: `default`

#### Defined in

[constants.ts:37](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L37)

------

### WETH9

• `Const` **WETH9**: `Object`

Known WETH9 implementation addresses, used in our implementation of Ether#wrapped

#### Index signature

▪ [chainId: `number`]: [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

#### Defined in

[entities/weth9.ts:6](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/weth9.ts#L6)

## Functions

### computePriceImpact

▸ **computePriceImpact**<`TBase`, `TQuote`>(`midPrice`, `inputAmount`, `outputAmount`): [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

Returns the percent difference between the mid price and the execution price, i.e. price impact.

#### Type parameters

| Name     | Type                                                         |
| :------- | :----------------------------------------------------------- |
| `TBase`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |
| `TQuote` | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name           | Type                                                         | Description                    |
| :------------- | :----------------------------------------------------------- | :----------------------------- |
| `midPrice`     | [`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TBase`, `TQuote`> | mid price before the trade     |
| `inputAmount`  | [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TBase`> | the input amount of the trade  |
| `outputAmount` | [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TQuote`> | the output amount of the trade |

#### Returns

[`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Defined in

[utils/computePriceImpact.ts:9](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/computePriceImpact.ts#L9)

------

### sortedInsert

▸ **sortedInsert**<`T`>(`items`, `add`, `maxSize`, `comparator`): `T` | `null`

#### Type parameters

| Name |
| :--- |
| `T`  |

#### Parameters

| Name         | Type                             |
| :----------- | :------------------------------- |
| `items`      | `T`[]                            |
| `add`        | `T`                              |
| `maxSize`    | `number`                         |
| `comparator` | (`a`: `T`, `b`: `T`) => `number` |

#### Returns

```
T` | `null
```

#### Defined in

[utils/sortedInsert.ts:5](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/sortedInsert.ts#L5)

------

### sqrt

▸ **sqrt**(`value`): `JSBI`

Computes floor(sqrt(value))

#### Parameters

| Name    | Type      | Description                                                  |
| :------ | :-------- | :----------------------------------------------------------- |
| `value` | `default` | the value for which to compute the square root, rounded down |

#### Returns

```
JSBI
```

#### Defined in

[utils/sqrt.ts:14](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/sqrt.ts#L14)

------

### validateAndParseAddress

▸ **validateAndParseAddress**(`address`): `string`

Validates an address and returns the parsed (checksummed) version of that address

#### Parameters

| Name      | Type     | Description                   |
| :-------- | :------- | :---------------------------- |
| `address` | `string` | the unchecksummed hex address |

#### Returns

```
string
```

#### Defined in

[utils/validateAndParseAddress.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/validateAndParseAddress.ts#L7)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[CurrencyAmount](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / CurrencyAmount

# Class: CurrencyAmount<T>

## Type parameters

| Name | Type                                                         |
| :--- | :----------------------------------------------------------- |
| `T`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

## Hierarchy

- [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

  ↳ **`CurrencyAmount`**

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#constructor)

### Properties

- [currency](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#currency)
- [decimalScale](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#decimalscale)
- [denominator](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#denominator)
- [numerator](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#numerator)

### Accessors

- [asFraction](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#asfraction)
- [quotient](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#quotient)
- [remainder](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#remainder)
- [wrapped](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#wrapped)

### Methods

- [add](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#add)
- [divide](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#divide)
- [equalTo](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#equalto)
- [greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#greaterthan)
- [invert](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#invert)
- [lessThan](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#lessthan)
- [multiply](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#multiply)
- [subtract](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#subtract)
- [toExact](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#toexact)
- [toFixed](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#tofixed)
- [toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#tosignificant)
- [fromFractionalAmount](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#fromfractionalamount)
- [fromRawAmount](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount#fromrawamount)

## Constructors

### constructor

• `Protected` **new CurrencyAmount**<`T`>(`currency`, `numerator`, `denominator?`)

#### Type parameters

| Name | Type                                                         |
| :--- | :----------------------------------------------------------- |
| `T`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name           | Type                                                         |
| :------------- | :----------------------------------------------------------- |
| `currency`     | `T`                                                          |
| `numerator`    | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |
| `denominator?` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[constructor](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#constructor)

#### Defined in

[entities/fractions/currencyAmount.ts:40](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L40)

## Properties

### currency

• `Readonly` **currency**: `T`

#### Defined in

[entities/fractions/currencyAmount.ts:14](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L14)

------

### decimalScale

• `Readonly` **decimalScale**: `default`

#### Defined in

[entities/fractions/currencyAmount.ts:15](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L15)

------

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[denominator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

------

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[numerator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

------

### quotient

• `get` **quotient**(): `default`

#### Returns

```
default
```

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

------

### remainder

• `get` **remainder**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

------

### wrapped

• `get` **wrapped**(): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<[`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)>

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<[`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)>

#### Defined in

[entities/fractions/currencyAmount.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L91)

## Methods

### add

▸ **add**(`other`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`> |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[add](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#add)

#### Defined in

[entities/fractions/currencyAmount.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L47)

------

### divide

▸ **divide**(`other`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[divide](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#divide)

#### Defined in

[entities/fractions/currencyAmount.ts:64](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L64)

------

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

------

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

------

### invert

▸ **invert**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[invert](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#invert)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

------

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

------

### multiply

▸ **multiply**(`other`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[multiply](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#multiply)

#### Defined in

[entities/fractions/currencyAmount.ts:59](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L59)

------

### subtract

▸ **subtract**(`other`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`> |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[subtract](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#subtract)

#### Defined in

[entities/fractions/currencyAmount.ts:53](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L53)

------

### toExact

▸ **toExact**(`format?`): `string`

#### Parameters

| Name     | Type     |
| :------- | :------- |
| `format` | `object` |

#### Returns

```
string
```

#### Defined in

[entities/fractions/currencyAmount.ts:86](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L86)

------

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name            | Type                                                         | Default value         |
| :-------------- | :----------------------------------------------------------- | :-------------------- |
| `decimalPlaces` | `number`                                                     | `undefined`           |
| `format?`       | `object`                                                     | `undefined`           |
| `rounding`      | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `Rounding.ROUND_DOWN` |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tofixed)

#### Defined in

[entities/fractions/currencyAmount.ts:77](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L77)

------

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name                | Type                                                         | Default value         |
| :------------------ | :----------------------------------------------------------- | :-------------------- |
| `significantDigits` | `number`                                                     | `6`                   |
| `format?`           | `object`                                                     | `undefined`           |
| `rounding`          | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `Rounding.ROUND_DOWN` |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tosignificant)

#### Defined in

[entities/fractions/currencyAmount.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L69)

------

### fromFractionalAmount

▸ `Static` **fromFractionalAmount**<`T`>(`currency`, `numerator`, `denominator`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

Construct a currency amount with a denominator that is not equal to 1

#### Type parameters

| Name | Type                                                         |
| :--- | :----------------------------------------------------------- |
| `T`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name          | Type                                                         | Description                                    |
| :------------ | :----------------------------------------------------------- | :--------------------------------------------- |
| `currency`    | `T`                                                          | the currency                                   |
| `numerator`   | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | the numerator of the fractional token amount   |
| `denominator` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | the denominator of the fractional token amount |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Defined in

[entities/fractions/currencyAmount.ts:32](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L32)

------

### fromRawAmount

▸ `Static` **fromRawAmount**<`T`>(`currency`, `rawAmount`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount

#### Type parameters

| Name | Type                                                         |
| :--- | :----------------------------------------------------------- |
| `T`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name        | Type                                                         | Description                   |
| :---------- | :----------------------------------------------------------- | :---------------------------- |
| `currency`  | `T`                                                          | the currency in the amount    |
| `rawAmount` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | the raw token or ether amount |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`T`>

#### Defined in

[entities/fractions/currencyAmount.ts:22](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L22)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[Ether](https://docs.uniswap.org/sdk/core/reference/classes/Ether)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Ether

# Class: Ether

Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets

## Hierarchy

- [`NativeCurrency`](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency)

  ↳ **`Ether`**

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/Ether#constructor)

### Properties

- [chainId](https://docs.uniswap.org/sdk/core/reference/classes/Ether#chainid)
- [decimals](https://docs.uniswap.org/sdk/core/reference/classes/Ether#decimals)
- [isNative](https://docs.uniswap.org/sdk/core/reference/classes/Ether#isnative)
- [isToken](https://docs.uniswap.org/sdk/core/reference/classes/Ether#istoken)
- [name](https://docs.uniswap.org/sdk/core/reference/classes/Ether#name)
- [symbol](https://docs.uniswap.org/sdk/core/reference/classes/Ether#symbol)
- [_etherCache](https://docs.uniswap.org/sdk/core/reference/classes/Ether#_ethercache)

### Accessors

- [wrapped](https://docs.uniswap.org/sdk/core/reference/classes/Ether#wrapped)

### Methods

- [equals](https://docs.uniswap.org/sdk/core/reference/classes/Ether#equals)
- [onChain](https://docs.uniswap.org/sdk/core/reference/classes/Ether#onchain)

## Constructors

### constructor

• `Protected` **new Ether**(`chainId`)

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `chainId` | `number` |

#### Overrides

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[constructor](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#constructor)

#### Defined in

[entities/ether.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L11)

## Properties

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[chainId](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#chainid)

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

------

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[decimals](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#decimals)

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

------

### isNative

• `Readonly` **isNative**: `true`

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[isNative](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#isnative)

#### Defined in

[entities/nativeCurrency.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L7)

------

### isToken

• `Readonly` **isToken**: `false`

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[isToken](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#istoken)

#### Defined in

[entities/nativeCurrency.ts:8](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L8)

------

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[name](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#name)

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

------

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[symbol](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#symbol)

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

------

### _etherCache

▪ `Static` `Private` **_etherCache**: `Object` = `{}`

#### Index signature

▪ [chainId: `number`]: [`Ether`](https://docs.uniswap.org/sdk/core/reference/classes/Ether)

#### Defined in

[entities/ether.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L21)

## Accessors

### wrapped

• `get` **wrapped**(): [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

Return the wrapped version of this currency that can be used with the Uniswap contracts. Currencies must implement this to be used in Uniswap

#### Returns

[`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

#### Overrides

NativeCurrency.wrapped

#### Defined in

[entities/ether.ts:15](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L15)

## Methods

### equals

▸ **equals**(`other`): `boolean`

Returns whether this currency is functionally equivalent to the other currency

#### Parameters

| Name    | Type                                                         | Description        |
| :------ | :----------------------------------------------------------- | :----------------- |
| `other` | [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) | the other currency |

#### Returns

```
boolean
```

#### Overrides

[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency).[equals](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#equals)

#### Defined in

[entities/ether.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L27)

------

### onChain

▸ `Static` **onChain**(`chainId`): [`Ether`](https://docs.uniswap.org/sdk/core/reference/classes/Ether)

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `chainId` | `number` |

#### Returns

[`Ether`](https://docs.uniswap.org/sdk/core/reference/classes/Ether)

#### Defined in

[entities/ether.ts:23](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L23)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Fraction

# Class: Fraction

## Hierarchy

- **`Fraction`**

  ↳ [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)

  ↳ [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

  ↳ [`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#constructor)

### Properties

- [denominator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#denominator)
- [numerator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#numerator)

### Accessors

- [asFraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#asfraction)
- [quotient](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#quotient)
- [remainder](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#remainder)

### Methods

- [add](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#add)
- [divide](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#divide)
- [equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#equalto)
- [greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#greaterthan)
- [invert](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#invert)
- [lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#lessthan)
- [multiply](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#multiply)
- [subtract](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#subtract)
- [toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tofixed)
- [toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tosignificant)
- [tryParseFraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tryparsefraction)

## Constructors

### constructor

• **new Fraction**(`numerator`, `denominator?`)

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `numerator`   | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |
| `denominator` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |

#### Defined in

[entities/fractions/fraction.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L28)

## Properties

### denominator

• `Readonly` **denominator**: `default`

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

------

### numerator

• `Readonly` **numerator**: `default`

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

------

### quotient

• `get` **quotient**(): `default`

#### Returns

```
default
```

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

------

### remainder

• `get` **remainder**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:55](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L55)

------

### divide

▸ **divide**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:115](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L115)

------

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

------

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

------

### invert

▸ **invert**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

------

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

------

### multiply

▸ **multiply**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:107](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L107)

------

### subtract

▸ **subtract**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L69)

------

### toFixed

▸ **toFixed**(`decimalPlaces`, `format?`, `rounding?`): `string`

#### Parameters

| Name            | Type                                                         | Default value            |
| :-------------- | :----------------------------------------------------------- | :----------------------- |
| `decimalPlaces` | `number`                                                     | `undefined`              |
| `format`        | `object`                                                     | `undefined`              |
| `rounding`      | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `Rounding.ROUND_HALF_UP` |

#### Returns

```
string
```

#### Defined in

[entities/fractions/fraction.ts:138](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L138)

------

### toSignificant

▸ **toSignificant**(`significantDigits`, `format?`, `rounding?`): `string`

#### Parameters

| Name                | Type                                                         | Default value            |
| :------------------ | :----------------------------------------------------------- | :----------------------- |
| `significantDigits` | `number`                                                     | `undefined`              |
| `format`            | `object`                                                     | `undefined`              |
| `rounding`          | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `Rounding.ROUND_HALF_UP` |

#### Returns

```
string
```

#### Defined in

[entities/fractions/fraction.ts:123](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L123)

------

### tryParseFraction

▸ `Static` `Private` **tryParseFraction**(`fractionish`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `fractionish` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/fraction.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L33)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[NativeCurrency](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / NativeCurrency

# Class: NativeCurrency

Represents the native currency of the chain on which it resides, e.g.

## Hierarchy

- `BaseCurrency`

  ↳ **`NativeCurrency`**

  ↳↳ [`Ether`](https://docs.uniswap.org/sdk/core/reference/classes/Ether)

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#constructor)

### Properties

- [chainId](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#chainid)
- [decimals](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#decimals)
- [isNative](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#isnative)
- [isToken](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#istoken)
- [name](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#name)
- [symbol](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#symbol)

### Accessors

- [wrapped](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#wrapped)

### Methods

- [equals](https://docs.uniswap.org/sdk/core/reference/classes/NativeCurrency#equals)

## Constructors

### constructor

• `Protected` **new NativeCurrency**(`chainId`, `decimals`, `symbol?`, `name?`)

Constructs an instance of the base class `BaseCurrency`.

#### Parameters

| Name       | Type     | Description                                 |
| :--------- | :------- | :------------------------------------------ |
| `chainId`  | `number` | the chain ID on which this currency resides |
| `decimals` | `number` | decimals of the currency                    |
| `symbol?`  | `string` | symbol of the currency                      |
| `name?`    | `string` | of the currency                             |

#### Inherited from

BaseCurrency.constructor

#### Defined in

[entities/baseCurrency.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L42)

## Properties

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

BaseCurrency.chainId

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

------

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

BaseCurrency.decimals

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

------

### isNative

• `Readonly` **isNative**: `true`

#### Overrides

BaseCurrency.isNative

#### Defined in

[entities/nativeCurrency.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L7)

------

### isToken

• `Readonly` **isToken**: `false`

#### Overrides

BaseCurrency.isToken

#### Defined in

[entities/nativeCurrency.ts:8](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L8)

------

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

BaseCurrency.name

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

------

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

BaseCurrency.symbol

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

## Accessors

### wrapped

• `Abstract` `get` **wrapped**(): [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

Return the wrapped version of this currency that can be used with the Uniswap contracts. Currencies must implement this to be used in Uniswap

#### Returns

[`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

#### Inherited from

BaseCurrency.wrapped

#### Defined in

[entities/baseCurrency.ts:62](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L62)

## Methods

### equals

▸ `Abstract` **equals**(`other`): `boolean`

Returns whether this currency is functionally equivalent to the other currency

#### Parameters

| Name    | Type                                                         | Description        |
| :------ | :----------------------------------------------------------- | :----------------- |
| `other` | [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) | the other currency |

#### Returns

```
boolean
```

#### Inherited from

BaseCurrency.equals

#### Defined in

[entities/baseCurrency.ts:56](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L56)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[Percent](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Percent

# Class: Percent

## Hierarchy

- [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

  ↳ **`Percent`**

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/Percent#constructor)

### Properties

- [denominator](https://docs.uniswap.org/sdk/core/reference/classes/Percent#denominator)
- [isPercent](https://docs.uniswap.org/sdk/core/reference/classes/Percent#ispercent)
- [numerator](https://docs.uniswap.org/sdk/core/reference/classes/Percent#numerator)

### Accessors

- [asFraction](https://docs.uniswap.org/sdk/core/reference/classes/Percent#asfraction)
- [quotient](https://docs.uniswap.org/sdk/core/reference/classes/Percent#quotient)
- [remainder](https://docs.uniswap.org/sdk/core/reference/classes/Percent#remainder)

### Methods

- [add](https://docs.uniswap.org/sdk/core/reference/classes/Percent#add)
- [divide](https://docs.uniswap.org/sdk/core/reference/classes/Percent#divide)
- [equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Percent#equalto)
- [greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Percent#greaterthan)
- [invert](https://docs.uniswap.org/sdk/core/reference/classes/Percent#invert)
- [lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Percent#lessthan)
- [multiply](https://docs.uniswap.org/sdk/core/reference/classes/Percent#multiply)
- [subtract](https://docs.uniswap.org/sdk/core/reference/classes/Percent#subtract)
- [toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Percent#tofixed)
- [toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Percent#tosignificant)

## Constructors

### constructor

• **new Percent**(`numerator`, `denominator?`)

#### Parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `numerator`   | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |
| `denominator` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) |

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[constructor](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#constructor)

#### Defined in

[entities/fractions/fraction.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L28)

## Properties

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[denominator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

------

### isPercent

• `Readonly` **isPercent**: `true`

This boolean prevents a fraction from being interpreted as a Percent

#### Defined in

[entities/fractions/percent.ts:19](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L19)

------

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[numerator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

------

### quotient

• `get` **quotient**(): `default`

#### Returns

```
default
```

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

------

### remainder

• `get` **remainder**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[add](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#add)

#### Defined in

[entities/fractions/percent.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L21)

------

### divide

▸ **divide**(`other`): [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[divide](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#divide)

#### Defined in

[entities/fractions/percent.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L33)

------

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

------

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

------

### invert

▸ **invert**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[invert](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#invert)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

------

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

------

### multiply

▸ **multiply**(`other`): [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[multiply](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#multiply)

#### Defined in

[entities/fractions/percent.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L29)

------

### subtract

▸ **subtract**(`other`): [`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Percent`](https://docs.uniswap.org/sdk/core/reference/classes/Percent)

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[subtract](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#subtract)

#### Defined in

[entities/fractions/percent.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L25)

------

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name            | Type                                                         | Default value |
| :-------------- | :----------------------------------------------------------- | :------------ |
| `decimalPlaces` | `number`                                                     | `2`           |
| `format?`       | `object`                                                     | `undefined`   |
| `rounding?`     | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `undefined`   |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tofixed)

#### Defined in

[entities/fractions/percent.ts:41](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L41)

------

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name                | Type                                                         | Default value |
| :------------------ | :----------------------------------------------------------- | :------------ |
| `significantDigits` | `number`                                                     | `5`           |
| `format?`           | `object`                                                     | `undefined`   |
| `rounding?`         | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `undefined`   |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tosignificant)

#### Defined in

[entities/fractions/percent.ts:37](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L37)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[Price](https://docs.uniswap.org/sdk/core/reference/classes/Price)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Price

# Class: Price<TBase, TQuote>

## Type parameters

| Name     | Type                                                         |
| :------- | :----------------------------------------------------------- |
| `TBase`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |
| `TQuote` | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

## Hierarchy

- [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

  ↳ **`Price`**

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/Price#constructor)

### Properties

- [baseCurrency](https://docs.uniswap.org/sdk/core/reference/classes/Price#basecurrency)
- [denominator](https://docs.uniswap.org/sdk/core/reference/classes/Price#denominator)
- [numerator](https://docs.uniswap.org/sdk/core/reference/classes/Price#numerator)
- [quoteCurrency](https://docs.uniswap.org/sdk/core/reference/classes/Price#quotecurrency)
- [scalar](https://docs.uniswap.org/sdk/core/reference/classes/Price#scalar)

### Accessors

- [adjustedForDecimals](https://docs.uniswap.org/sdk/core/reference/classes/Price#adjustedfordecimals)
- [asFraction](https://docs.uniswap.org/sdk/core/reference/classes/Price#asfraction)
- [quotient](https://docs.uniswap.org/sdk/core/reference/classes/Price#quotient)
- [remainder](https://docs.uniswap.org/sdk/core/reference/classes/Price#remainder)

### Methods

- [add](https://docs.uniswap.org/sdk/core/reference/classes/Price#add)
- [divide](https://docs.uniswap.org/sdk/core/reference/classes/Price#divide)
- [equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Price#equalto)
- [greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Price#greaterthan)
- [invert](https://docs.uniswap.org/sdk/core/reference/classes/Price#invert)
- [lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Price#lessthan)
- [multiply](https://docs.uniswap.org/sdk/core/reference/classes/Price#multiply)
- [quote](https://docs.uniswap.org/sdk/core/reference/classes/Price#quote)
- [subtract](https://docs.uniswap.org/sdk/core/reference/classes/Price#subtract)
- [toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Price#tofixed)
- [toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Price#tosignificant)

## Constructors

### constructor

• **new Price**<`TBase`, `TQuote`>(...`args`)

Construct a price, either with the base and quote currency amount, or the

#### Type parameters

| Name     | Type                                                         |
| :------- | :----------------------------------------------------------- |
| `TBase`  | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |
| `TQuote` | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name      | Type                                                         |
| :-------- | :----------------------------------------------------------- |
| `...args` | [`TBase`, `TQuote`, [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish), [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish)] | [{ `baseAmount`: [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TBase`> ; `quoteAmount`: [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TQuote`> }] |

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[constructor](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#constructor)

#### Defined in

[entities/fractions/price.ts:18](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L18)

## Properties

### baseCurrency

• `Readonly` **baseCurrency**: `TBase`

#### Defined in

[entities/fractions/price.ts:10](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L10)

------

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[denominator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

------

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[numerator](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

------

### quoteCurrency

• `Readonly` **quoteCurrency**: `TQuote`

#### Defined in

[entities/fractions/price.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L11)

------

### scalar

• `Readonly` **scalar**: [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/price.ts:12](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L12)

## Accessors

### adjustedForDecimals

• `Private` `get` **adjustedForDecimals**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

Get the value scaled by decimals for formatting

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Defined in

[entities/fractions/price.ts:77](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L77)

------

### asFraction

• `get` **asFraction**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

------

### quotient

• `get` **quotient**(): `default`

#### Returns

```
default
```

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

------

### remainder

• `get` **remainder**(): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[add](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#add)

#### Defined in

[entities/fractions/fraction.ts:55](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L55)

------

### divide

▸ **divide**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[divide](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#divide)

#### Defined in

[entities/fractions/fraction.ts:115](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L115)

------

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[equalTo](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

------

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[greaterThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

------

### invert

▸ **invert**(): [`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TQuote`, `TBase`>

Flip the price, switching the base and quote currency

#### Returns

[`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TQuote`, `TBase`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[invert](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#invert)

#### Defined in

[entities/fractions/price.ts:49](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L49)

------

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

```
boolean
```

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[lessThan](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

------

### multiply

▸ **multiply**<`TOtherQuote`>(`other`): [`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TBase`, `TOtherQuote`>

Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency

#### Type parameters

| Name          | Type                                                         |
| :------------ | :----------------------------------------------------------- |
| `TOtherQuote` | extends [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) |

#### Parameters

| Name    | Type                                                         | Description     |
| :------ | :----------------------------------------------------------- | :-------------- |
| `other` | [`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TQuote`, `TOtherQuote`> | the other price |

#### Returns

[`Price`](https://docs.uniswap.org/sdk/core/reference/classes/Price)<`TBase`, `TOtherQuote`>

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[multiply](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#multiply)

#### Defined in

[entities/fractions/price.ts:57](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L57)

------

### quote

▸ **quote**(`currencyAmount`): [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TQuote`>

Return the amount of quote currency corresponding to a given amount of the base currency

#### Parameters

| Name             | Type                                                         | Description                                            |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------- |
| `currencyAmount` | [`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TBase`> | the amount of base currency to quote against the price |

#### Returns

[`CurrencyAmount`](https://docs.uniswap.org/sdk/core/reference/classes/CurrencyAmount)<`TQuote`>

#### Defined in

[entities/fractions/price.ts:67](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L67)

------

### subtract

▸ **subtract**(`other`): [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Parameters

| Name    | Type                                                         |
| :------ | :----------------------------------------------------------- |
| `other` | [`BigintIsh`](https://docs.uniswap.org/sdk/core/reference/modules#bigintish) | [`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction) |

#### Returns

[`Fraction`](https://docs.uniswap.org/sdk/core/reference/classes/Fraction)

#### Inherited from

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[subtract](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#subtract)

#### Defined in

[entities/fractions/fraction.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L69)

------

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name            | Type                                                         | Default value |
| :-------------- | :----------------------------------------------------------- | :------------ |
| `decimalPlaces` | `number`                                                     | `4`           |
| `format?`       | `object`                                                     | `undefined`   |
| `rounding?`     | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `undefined`   |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toFixed](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tofixed)

#### Defined in

[entities/fractions/price.ts:85](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L85)

------

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name                | Type                                                         | Default value |
| :------------------ | :----------------------------------------------------------- | :------------ |
| `significantDigits` | `number`                                                     | `6`           |
| `format?`           | `object`                                                     | `undefined`   |
| `rounding?`         | [`Rounding`](https://docs.uniswap.org/sdk/core/reference/enums/Rounding) | `undefined`   |

#### Returns

```
string
```

#### Overrides

[Fraction](https://docs.uniswap.org/sdk/core/reference/classes/Fraction).[toSignificant](https://docs.uniswap.org/sdk/core/reference/classes/Fraction#tosignificant)

#### Defined in

[entities/fractions/price.ts:81](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L81)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)classes[Token](https://docs.uniswap.org/sdk/core/reference/classes/Token)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Token

# Class: Token

Represents an ERC20 token with a unique address and some metadata.

## Hierarchy

- `BaseCurrency`

  ↳ **`Token`**

## Table of contents

### Constructors

- [constructor](https://docs.uniswap.org/sdk/core/reference/classes/Token#constructor)

### Properties

- [address](https://docs.uniswap.org/sdk/core/reference/classes/Token#address)
- [chainId](https://docs.uniswap.org/sdk/core/reference/classes/Token#chainid)
- [decimals](https://docs.uniswap.org/sdk/core/reference/classes/Token#decimals)
- [isNative](https://docs.uniswap.org/sdk/core/reference/classes/Token#isnative)
- [isToken](https://docs.uniswap.org/sdk/core/reference/classes/Token#istoken)
- [name](https://docs.uniswap.org/sdk/core/reference/classes/Token#name)
- [symbol](https://docs.uniswap.org/sdk/core/reference/classes/Token#symbol)

### Accessors

- [wrapped](https://docs.uniswap.org/sdk/core/reference/classes/Token#wrapped)

### Methods

- [equals](https://docs.uniswap.org/sdk/core/reference/classes/Token#equals)
- [sortsBefore](https://docs.uniswap.org/sdk/core/reference/classes/Token#sortsbefore)

## Constructors

### constructor

• **new Token**(`chainId`, `address`, `decimals`, `symbol?`, `name?`, `bypassChecksum?`)

#### Parameters

| Name              | Type      | Description                                                  |
| :---------------- | :-------- | :----------------------------------------------------------- |
| `chainId`         | `number`  | BaseCurrency#chainId                                         |
| `address`         | `string`  | The contract address on the chain on which this token lives  |
| `decimals`        | `number`  | BaseCurrency#decimals                                        |
| `symbol?`         | `string`  | BaseCurrency#symbol                                          |
| `name?`           | `string`  | BaseCurrency#name                                            |
| `bypassChecksum?` | `boolean` | If true it only checks for length === 42, startsWith 0x and contains only hex characters |

#### Overrides

BaseCurrency.constructor

#### Defined in

[entities/token.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L27)

## Properties

### address

• `Readonly` **address**: `string`

The contract address on the chain on which this token lives

#### Defined in

[entities/token.ts:16](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L16)

------

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

BaseCurrency.chainId

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

------

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

BaseCurrency.decimals

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

------

### isNative

• `Readonly` **isNative**: `false`

#### Overrides

BaseCurrency.isNative

#### Defined in

[entities/token.ts:10](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L10)

------

### isToken

• `Readonly` **isToken**: `true`

#### Overrides

BaseCurrency.isToken

#### Defined in

[entities/token.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L11)

------

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

BaseCurrency.name

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

------

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

BaseCurrency.symbol

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

## Accessors

### wrapped

• `get` **wrapped**(): [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

Return this token, which does not need to be wrapped

#### Returns

[`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token)

#### Overrides

BaseCurrency.wrapped

#### Defined in

[entities/token.ts:66](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L66)

## Methods

### equals

▸ **equals**(`other`): `boolean`

Returns true if the two tokens are equivalent, i.e. have the same chainId and address.

#### Parameters

| Name    | Type                                                         | Description            |
| :------ | :----------------------------------------------------------- | :--------------------- |
| `other` | [`Currency`](https://docs.uniswap.org/sdk/core/reference/modules#currency) | other token to compare |

#### Returns

```
boolean
```

#### Overrides

BaseCurrency.equals

#### Defined in

[entities/token.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L47)

------

### sortsBefore

▸ **sortsBefore**(`other`): `boolean`

Returns true if the address of this token sorts before the address of the other token

**`Throws`**

if the tokens have the same address

**`Throws`**

if the tokens are on different chains

#### Parameters

| Name    | Type                                                         | Description            |
| :------ | :----------------------------------------------------------- | :--------------------- |
| `other` | [`Token`](https://docs.uniswap.org/sdk/core/reference/classes/Token) | other token to compare |

#### Returns

```
boolean
```

#### Defined in

[entities/token.ts:57](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L57)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)enums[ChainId](https://docs.uniswap.org/sdk/core/reference/enums/ChainId)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / Exports / ChainId

# Enumeration: ChainId

## Table of contents

### Enumeration Members

- [ARBITRUM_ONE](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#arbitrum_one)
- [ARBITRUM_GOERLI](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#arbitrum_goerli)
- [CELO](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#celo)
- [CELO_ALFAJORES](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#celo_alfajores)
- [GOERLI](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#goerli)
- [MAINNET](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#mainnet)
- [OPTIMISM](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#optimism)
- [OPTIMISM_GOERLI](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#optimism_goerli)
- [POLYGON](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#polygon)
- [POLYGON_MUMBAI](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#polygon_mumbai)
- [SEPOLIA](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#sepolia)
- [GNOSIS](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#gnosis)
- [MOONBEAM](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#moonbeam)
- [BNB](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#bnb)
- [AVALANCHE](https://docs.uniswap.org/sdk/core/reference/enums/ChainId#avalanche)

## Enumeration Members

### ARBITRUM_ONE

• **ARBITRUM_ONE** = `42161`

#### Defined in

[chains.ts:7](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L7)

------

### ARBITRUM_GOERLI

• **ARBITRUM_GOERLI** = `421613`

#### Defined in

[chains.ts:8](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L8)

------

### CELO

• **CELO** = `42220`

#### Defined in

[chains.ts:11](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L11)

------

### CELO_ALFAJORES

• **CELO_ALFAJORES** = `44787`

#### Defined in

[chains.ts:12](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L12)

------

### GOERLI

• **GOERLI** = `5`

#### Defined in

[chains.ts:3](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L3)

------

### MAINNET

• **MAINNET** = `1`

#### Defined in

[chains.ts:2](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L2)

------

### OPTIMISM

• **OPTIMISM** = `10`

#### Defined in

[chains.ts:5](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L5)

------

### OPTIMISM_GOERLI

• **OPTIMISM_GOERLI** = `420`

#### Defined in

[chains.ts:6](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L6)

------

### POLYGON

• **POLYGON** = `137`

#### Defined in

[chains.ts:9](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L9)

------

### POLYGON_MUMBAI

• **POLYGON_MUMBAI** = `80001`

#### Defined in

[chains.ts:10](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L10)

------

### SEPOLIA

• **SEPOLIA** = `11155111`

#### Defined in

[chains.ts:4](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L4)

------

### GNOSIS

• **GNOSIS** = `100`

#### Defined in

[chains.ts:13](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L13)

------

### MOONBEAM

• **MOONBEAM** = `1284`

#### Defined in

[chains.ts:14](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L14)

------

### BNB

• **BNB** = `56`

#### Defined in

[chains.ts:15](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L15)

------

### AVALANCHE

• **AVALANCHE** = `43114`

#### Defined in

[chains.ts:16](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L16)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)enums[NativeCurrencyName](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / Exports / NativeCurrencyName

# Enumeration: NativeCurrencyName

## Table of Contents

### Enumeration Members

- [ETHER](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#ether)
- [MATIC](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#matic)
- [CELO](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#celo)
- [GNOSIS](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#gnosis)
- [MOONBEAM](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#moonbeam)
- [BNB](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#bnb)
- [AVAX](https://docs.uniswap.org/sdk/core/reference/enums/NativeCurrencyName#avax)

### ETHER

• **ETHER** = `ETH`

#### Defined in

[chains.ts:38](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L38)

------

### MATIC

• **MATIC** = `MATIC`

#### Defined in

[chains.ts:39](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L39)

------

### CELO

• **CELO** = `CELO`

#### Defined in

[chains.ts:40](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L40)

------

### GNOSIS

• **GNOSIS** = `XDAI`

#### Defined in

[chains.ts:41](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L41)

------

### MOONBEAM

• **MOONBEAM** = `GLMR`

#### Defined in

[chains.ts:42](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L42)

------

### BNB

• **BNB** = `BNB`

#### Defined in

[chains.ts:43](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L43)

------

### AVAX

• **AVAX** = `AVAX`

#### Defined in

[chains.ts:44](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L44)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)enums[Rounding](https://docs.uniswap.org/sdk/core/reference/enums/Rounding)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / Rounding

# Enumeration: Rounding

## Table of contents

### Enumeration Members

- [ROUND_DOWN](https://docs.uniswap.org/sdk/core/reference/enums/Rounding#round_down)
- [ROUND_HALF_UP](https://docs.uniswap.org/sdk/core/reference/enums/Rounding#round_half_up)
- [ROUND_UP](https://docs.uniswap.org/sdk/core/reference/enums/Rounding#round_up)

## Enumeration Members

### ROUND_DOWN

• **ROUND_DOWN** = `0`

#### Defined in

[constants.ts:32](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L32)

------

### ROUND_HALF_UP

• **ROUND_HALF_UP** = `1`

#### Defined in

[constants.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L33)

------

### ROUND_UP

• **ROUND_UP** = `2`

#### Defined in

[constants.ts:34](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L34)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)enums[TradeType](https://docs.uniswap.org/sdk/core/reference/enums/TradeType)

[@uniswap/sdk-core](https://docs.uniswap.org/sdk/core/reference/) / [Exports](https://docs.uniswap.org/sdk/core/reference/modules) / TradeType

# Enumeration: TradeType

## Table of contents

### Enumeration Members

- [EXACT_INPUT](https://docs.uniswap.org/sdk/core/reference/enums/TradeType#exact_input)
- [EXACT_OUTPUT](https://docs.uniswap.org/sdk/core/reference/enums/TradeType#exact_output)

## Enumeration Members

### EXACT_INPUT

• **EXACT_INPUT** = `0`

#### Defined in

[constants.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L27)

------

### EXACT_OUTPUT

• **EXACT_OUTPUT** = `1`

#### Defined in

[constants.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L28)



[SDKs](https://docs.uniswap.org/sdk/v4/overview)Core SDK[Technical Reference](https://docs.uniswap.org/sdk/core/reference/)[Type Definitions](https://docs.uniswap.org/sdk/core/reference/modules)

# Type Definitions

This page documents the core type definitions and interfaces used throughout the Uniswap SDK Core.

## Core Types

### Currency

Base interface for all currencies (tokens and native currencies).

```typescript
interface Currency {
  readonly isNative: boolean
  readonly isToken: boolean
  readonly chainId: number
  readonly decimals: number
  readonly symbol?: string
  readonly name?: string
}
```



### BigintIsh

Union type for values that can be converted to BigInt.

```typescript
type BigintIsh = JSBI | string | number
```



Used throughout the SDK for numeric inputs that need high precision.

## Utility Types

### TradeType

Enum for specifying trade direction:

```typescript
enum TradeType {
  EXACT_INPUT,
  EXACT_OUTPUT
}
```



### Rounding

Enum for mathematical rounding modes:

```typescript
enum Rounding {
  ROUND_DOWN,
  ROUND_HALF_UP,
  ROUND_UP
}
```



## Chain Support

### ChainId

Supported blockchain networks:

```typescript
enum ChainId {
  MAINNET = 1,
  GOERLI = 5,
  SEPOLIA = 11155111,
  OPTIMISM = 10,
  OPTIMISM_GOERLI = 420,
  ARBITRUM_ONE = 42161,
  ARBITRUM_GOERLI = 421613,
  POLYGON = 137,
  POLYGON_MUMBAI = 80001,
  CELO = 42220,
  CELO_ALFAJORES = 44787,
  GNOSIS = 100,
  MOONBEAM = 1284,
  BNB = 56,
  AVALANCHE = 43114,
  BASE_GOERLI = 84531,
  BASE = 8453
}
```



## Constants

Key constants used throughout the SDK:

- **`MaxUint256`** - Maximum uint256 value
- **`ZERO`** - BigInt zero value
- **`ONE`** - BigInt one value
- **`TWO`** - BigInt two value
- **`THREE`** - BigInt three value

## Usage Examples

### Working with Currencies

```typescript
import { Token, Ether } from '@uniswap/sdk-core'

// Native ETH
const ETH = Ether.onChain(1)

// ERC-20 Token
const USDC = new Token(
  1, // chainId
  '0xA0b86a33E6417c29C8F6e3b6E4E12A82aA4Ca8e9', // address
  6, // decimals
  'USDC', // symbol
  'USD Coin' // name
)
```



### Working with Amounts

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const amount = CurrencyAmount.fromRawAmount(USDC, '1000000') // 1 USDC
const readable = amount.toSignificant(6) // "1.000000"
```



For more detailed usage, see the individual class documentation and the [SDK Guides](https://docs.uniswap.org/sdk/v3/guides/background).



[APIs](https://docs.uniswap.org/api/subgraph/overview)

# Overview

## The Uniswap Subgraph

Uniswap uses multiple [subgraphs](https://thegraph.com/docs/about/introduction#what-the-graph-is) for indexing and organizing data from the Uniswap smart contracts. These subgraphs are hosted on The Graph and can be used to query Uniswap data.

### Versions and Production Endpoints

Each version of Uniswap for each chain has its own dedicated subgraph. As hosted subgraphs have been depreciated, you will now need to call through their decentralized subgraphs.

Each subgraph has a dedicated endpoint for querying data, as well as a page on [The Graph explorer](https://thegraph.com/explorer) that exposes the schema and available fields to query.

## Creating an API Key

API Keys can be created by users inside the [Studio](https://thegraph.com/studio/apikeys/). This key will be included into the endpoint to associate a consumers usage to their billing.

##### v4 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G?view=About&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G`
- Code: https://github.com/Uniswap/v4-subgraph

##### v3 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV`
- Code: https://github.com/Uniswap/v3-subgraph

##### v2 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/A3Np3RQbaBA6oKJgiwDJeo5T3zrYfGHPWFYayMwtNDum?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/A3Np3RQbaBA6oKJgiwDJeo5T3zrYfGHPWFYayMwtNDum`
- Code: https://github.com/Uniswap/v2-subgraph

##### v1 (Mainnet)

- [Explorer Page](https://thegraph.com/explorer/subgraphs/ESnjgAG9NjfmHypk4Huu4PVvz55fUwpyrRqHF21thoLJ?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/ESnjgAG9NjfmHypk4Huu4PVvz55fUwpyrRqHF21thoLJ`
- Code: https://github.com/graphprotocol/uniswap-subgraph

## v3 Subgraphs for other chains

| Chain     | V3                                                           |
| --------- | ------------------------------------------------------------ |
| Arbitrum  | [Subgraph](https://thegraph.com/explorer/subgraphs/FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM?view=Query&chain=arbitrum-one) |
| Base      | [Subgraph](https://thegraph.com/explorer/subgraphs/43Hwfi3dJSoGpyas9VwNoDAv55yjgGrPpNSmbQZArzMG?view=Query&chain=arbitrum-one) |
| Optimism  | [Subgraph](https://thegraph.com/explorer/subgraphs/Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj?view=Query&chain=arbitrum-one) |
| Polygon   | [Subgraph](https://thegraph.com/explorer/subgraphs/3hCPRGf4z88VC5rsBKU5AA9FBBq5nF3jbKJG7VZCbhjm?view=Query&chain=arbitrum-one) |
| BSC       | [Subgraph](https://thegraph.com/explorer/subgraphs/F85MNzUGYqgSHSHRGgeVMNsdnW1KtZSVgFULumXRZTw2?view=Query&chain=arbitrum-one) |
| Avalanche | [Subgraph](https://thegraph.com/explorer/subgraphs/GVH9h9KZ9CqheUEL93qMbq7QwgoBu32QXQDPR6bev4Eo?view=Query&chain=arbitrum-one) |
| Celo      | [Subgraph](https://thegraph.com/explorer/subgraphs/ESdrTJ3twMwWVoQ1hUE2u7PugEHX3QkenudD6aXCkDQ4?view=Query&chain=arbitrum-one) |
| Blast     | [Subgraph](https://thegraph.com/explorer/subgraphs/2LHovKznvo8YmKC9ZprPjsYAZDCc4K5q4AYz8s3cnQn1?view=Query&chain=arbitrum-one) |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphGuides[v3 Protocol Query Examples](https://docs.uniswap.org/api/subgraph/guides/v3-examples)

# v3 Protocol Query Examples

## Subgraph Query Examples

This doc will teach you how to query Uniswap v3 analytics by writing GraphQL queries on the subgraph. You can fetch data points like :

- [collected fees for a position](https://docs.uniswap.org/api/subgraph/guides/v3-examples#general-position-data)
- [current liquidity](https://docs.uniswap.org/api/subgraph/guides/v3-examples#pool-data) of a pool
- [volume on a certain day](https://docs.uniswap.org/api/subgraph/guides/v3-examples#historical-global-data)

and much more. Below are some example queries. To run a query copy and paste it into the [v3 explorer](https://thegraph.com/explorer/subgraphs/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV?view=Query&chain=arbitrum-one) to get fresh data.

## Global Data

Global data refers to data points about the Uniswap v3 protocol as a whole. Some examples of global data points are:

- Total value locked in the protocol,
- Total pools deployed,
- Total transaction counts.

Thus, to query global data you must pass in the Uniswap v3 Factory address `0x1F98431c8aD98523631AE4a59f267346ea31F984` and select the desired fields. Reference the full [factory schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L1) to see all possible fields.

### Current Global Data

An example querying total pool count, transaction count, and total volume in USD and ETH:

```text
{
  factory(id: "0x1F98431c8aD98523631AE4a59f267346ea31F984" ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```



### Historical Global Data

You can also query historical data by specifying a block number.

```text
{
  factory(
    id: "0x1F98431c8aD98523631AE4a59f267346ea31F984", 
    block: { 
      number: 13380584 
    }
  ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```



## Pool Data

To get data about a certain pool, pass in the pool address. Reference the full [pool schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L77) and adjust the query fields to retrieve the data points you want.

### General Pool Query

The query below returns the feeTier, spot price, and liquidity for the ETH-USDC pool.

```text
{
  pool(id: "0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8") {
    tick
    token0 {
      symbol
      id
      decimals
    }
    token1 {
      symbol
      id
      decimals
    }
    feeTier
    sqrtPrice
    liquidity
  }
}
```



### All Possible Pools

The maximum items you can query at once is 1000. Thus to get all possible pools, you can iterate using the skip variable. To get pools beyond the first 1000 you can also set the skip as shown below.

### Skipping First 1000 Pools

This query sets the skip value and returns the first 10 responses after the first 1000.

```text
{
  pools(first:10, skip:1000) {
    id
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```



### Creating a Skip Variable

This next query sets a skip variable. In your language and environment of choice you can then iterate through a loop, query to get 1000 pools each time, and continually adjust skip by 1000 until all pool responses are returned.

Check out [this example](https://github.com/Uniswap/v3-info/blob/770a05dc1a191cf229432ebc43c1f2ceb3666e3b/src/data/pools/chartData.ts#L14) from our interface for poolDayData that does something similar.

> **Note** This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```text
query pools($skip: Int!) {
  pools(
    first: 1000, 
    skip: $skip, 
    orderDirection: asc
  ) {
    id
    sqrtPrice
    token0 {
      id
    }
    token1 {
      id
    }
  }
}
```



### Most Liquid Pools

Retrieve the top 1000 most liquid pools. You can use this similar set up to orderBy other variables like number of swaps or volume.

```text
{
  pools(
    first: 1000, 
    orderBy: liquidity, 
    orderDirection: desc
  ) {
    id
  }
}
```



### Pool Daily Aggregated

This query returns daily aggregated data for the first 10 days since the given timestamp for the UNI-ETH pool.

```text
{
  poolDayDatas(
    first: 10, 
    orderBy: date, 
    where: {
      pool: "0x1d42064fc4beb5f8aaf85f4617ae8b3b5b8bd801", 
      date_gt: 1633642435
    }
  ) {
    date
    liquidity
    sqrtPrice
    token0Price
    token1Price
    volumeToken0
    volumeToken1
  }
}
```



## Swap Data

### General Swap Data

To query data about a particular swap, input the transaction hash + "#" + the index in the swaps the transaction array. This is the reference for the full [swap schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L253).

This query fetches data about the sender, receiver, amounts, transaction data, and timestamp for a particular swap.

```text
{
  swap(id: "0x000007e1111cbd97f74cfc6eea2879a5b02020f26960ac06f4af0f9395372b64#66785") {
    sender
    recipient
    amount0
    amount1
    transaction {
      id
      blockNumber
      gasUsed
      gasPrice
    }
    timestamp
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```



### Recent Swaps Within a Pool

You can set the `where` field to filter swap data by pool address. This example fetches data about multiple swaps for the USDC-USDT pool, ordered by timestamp.

```text
{
  swaps(
    orderBy: timestamp, 
    orderDirection: desc, 
    where: { 
      pool: "0x7858e59e0c01ea06df3af3d20ac7b0003275d4bf" 
    }
  ) {
    pool {
      token0 {
        id
        symbol
      }
      token1 {
        id
        symbol
      }
    }
    sender
    recipient
    amount0
    amount1
  }
}
```



## Token Data

Input the token contract address to fetch token data. Any token that exists in at least one Uniswap v3 pool can be queried. The output will aggregate data across all v3 pools that include the token.

### General Token Data

This queries the decimals, symbol, name, pool count, and volume in USD for the UNI token. Reference the full [token schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L38) for all possible fields you can query.

```text
{
  token(id:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984") {
    symbol
    name
    decimals
    volumeUSD
    poolCount
  }
}
```



### Token Daily Aggregated

You can fetch aggregate data about a specific token over a 24-hour period. This query gets 10-days of the 24-hour volume data for the UNI token ordered from oldest to newest.

```text
{
  tokenDayDatas(
    first: 10, 
    where: {
      token: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    }, 
    orderBy: date, 
    orderDirection: asc
  ) {
    date
    token {
      id
      symbol
    }
    volumeUSD
  }
}
```



### All Tokens

Similar to retrieving all pools, you can fetch all tokens by using skip.

> **Note** This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```text
query tokens($skip: Int!) {
  tokens(first: 1000, skip: $skip) {
    id
    symbol
    name
  }
}
```



## Position Data

### General Position Data

To get data about a specific position, input the NFT tokenId. This queries the collected fees for token0 and token1 and current liquidity for the position with tokenId 3. Reference the full [position schema](https://github.com/Uniswap/v3-subgraph/blob/main/schema.graphql#L192) to see all fields.

```text
{
  position(id: 3) {
    id
    collectedFeesToken0
    collectedFeesToken1
    liquidity
    token0 {
      id
      symbol
    }
    token1
    {
      id
      symbol
    }
  }
}
```



## Contribute

There are many more queries you can do with the Uniswap v3 subgraph including data related to ticks, mints, positions, and burns. Once again you can reference the full schema [here](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql). If you'd like to suggest more example queries to showcase, feel free to drop some suggestions in [discord](https://discord.com/invite/uniswap) under #dev-chat or [contribute](https://github.com/Uniswap/docs/blob/main/CONTRIBUTING.md) your own queries by submitting a pull request to the docs repo.



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphGuides[v4 Protocol Query Examples](https://docs.uniswap.org/api/subgraph/guides/v4-examples)

# v4 Protocol Query Examples

## Subgraph Query Examples

This doc will teach you how to query Uniswap v4 analytics by writing GraphQL queries on the subgraph. You can fetch data points like:

- [position details](https://docs.uniswap.org/api/subgraph/guides/v4-examples#general-position-data)
- [current liquidity](https://docs.uniswap.org/api/subgraph/guides/v4-examples#pool-data) of a pool
- [volume on a certain day](https://docs.uniswap.org/api/subgraph/guides/v4-examples#historical-global-data)

and much more. Below are some example queries. To run a query copy and paste it into the [v4 explorer](https://thegraph.com/explorer/subgraphs/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G?view=Query&chain=arbitrum-one) to get fresh data.

## Global Data

Global data refers to data points about the Uniswap v4 protocol as a whole. Some examples of global data points are:

- Total value locked in the protocol,
- Total pools deployed,
- Total transaction counts.

Thus, to query global data you must pass in the PoolManager address `0x000000000004444c5dc75cb358380d2e3de08a90` and select the desired fields. Reference the full [poolManager schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L1) to see all possible fields. PoolManager addresses for all supported chains are listed in the [Deployments](https://docs.uniswap.org/contracts/v4/deployments) section.

### Current Global Data

An example querying total pool count, transaction count, and total volume in USD and ETH:

```text
{
  poolManager(id: "0x000000000004444c5dc75cb358380d2e3de08a90") {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```



### Historical Global Data

You can also query historical data by specifying a block number.

```text
{
  poolManager(
    id: "0x000000000004444c5dc75cb358380d2e3de08a90", 
    block: {
      number: 22451931
    }
  ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```



## Pool Data

To get data about a certain pool, pass in the pool address. Reference the full [pool schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L76) and adjust the query fields to retrieve the data points you want.

### General Pool Query

The query below returns the feeTier, spot price, and liquidity for the ETH-USDC pool.

```text
{
  pool(id: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27") {
    tick
    token0 {
      symbol
      id
      decimals
    }
    token1 {
      symbol
      id
      decimals
    }
    feeTier
    sqrtPrice
    liquidity
  }
}
```



### All Possible Pools

The maximum items you can query at once is 1000. Thus to get all possible pools, you can iterate using the skip variable. To get pools beyond the first 1000 you can also set the skip as shown below.

### Skipping First 1000 Pools

This query sets the skip value and returns the first 10 responses after the first 1000.

```text
{
  pools(first: 10, skip: 1000) {
    id
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```



### Creating a Skip Variable

This next query sets a skip variable. In your language and environment of choice you can then iterate through a loop, query to get 1000 pools each time, and continually adjust skip by 1000 until all pool responses are returned.

Check out [this example](https://github.com/Uniswap/v3-info/blob/770a05dc1a191cf229432ebc43c1f2ceb3666e3b/src/data/pools/chartData.ts#L14) from our interface for poolDayData that does something similar.

> **Note** This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```text
query pools($skip: Int!) {
  pools(
    first: 1000
    skip: $skip
    orderDirection: asc
  ) {
    id
    sqrtPrice
    token0 {
      id
    }
    token1 {
      id
    }
  }
}
```



### Most Liquid Pools

Retrieve the top 1000 most liquid pools. You can use this similar set up to orderBy other variables like number of swaps or volume.

```text
{
  pools(
    first: 1000, 
    orderBy: liquidity, 
    orderDirection: desc
  ) {
    id
  }
}
```



### Pool Daily Aggregated

This query returns daily aggregated data for the first 10 days since the given timestamp for the UNI-ETH pool. To calculate `poolId`, refer to [PoolId Library](https://docs.uniswap.org/contracts/v4/reference/core/types/PoolId#toid).

```text
{
  poolDayDatas(
    first: 10, 
    orderBy: date, 
    where: {
      pool: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27",
      date_gt: 1735689600
    } 
  ) {
    date
    liquidity
    sqrtPrice
    token0Price
    token1Price
    volumeToken0
    volumeToken1
  }
}
```



## Swap Data

### General Swap Data

To query data about a particular swap, input the transaction hash + "-" + the index in the swaps the transaction array. This is the reference for the full [swap schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L186).

This query fetches data about the sender, amounts, transaction data, timestamp, and tokens for a particular swap.

```text
{
   swap(id: "0x0000329e0d864d8e7c93627b76f6b5b99bd776cb18d9f8829e7da469f563e7d4-212") {
    sender
    amount0
    amount1
    transaction {
      id
      blockNumber
      gasUsed
      gasPrice
    }
    timestamp
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
   }
 }
```



### Recent Swaps Within a Pool

You can set the `where` field to filter swap data by pool address. This example fetches data about multiple swaps for the ETH-USDT pool, ordered by timestamp.

```text
{
  swaps(
    orderBy: timestamp,
    orderDirection: desc,
    where: {
      pool: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27"
    }
  ) {
    pool {
      token0 {
        id
        symbol
      }
      token1 {
        id
        symbol
      }
    }
    sender
    amount0
    amount1
  }
}
```



## Token Data

Input the token contract address to fetch token data. Any token that exists in at least one Uniswap v4 pool can be queried. The output will aggregate data across all v4 pools that include the token.

### General Token Data

This queries the decimals, symbol, name, pool count, and volume in USD for the UNI token. Reference the full [token schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L37) for all possible fields you can query.

```text
{
  token(id:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984") {
    symbol
    name
    decimals
    volumeUSD
    poolCount
  }
}
```



### Token Daily Aggregated

You can fetch aggregate data about a specific token over a 24-hour period. This query gets 10-days of the 24-hour volume data for the UNI token ordered from oldest to newest.

```text
{
  tokenDayDatas(
    first: 10, 
    where: {
      token: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    }, 
    orderBy: date, 
    orderDirection: asc
  ) {
    date
    token {
      id
      symbol
    }
    volumeUSD
  }
}
```



### All Tokens

Similar to retrieving all pools, you can fetch all tokens by using skip.

> **Note** This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```text
query tokens($skip: Int!) {
  tokens(first: 1000, skip: $skip) {
    id
    symbol
    name
  }
}
```



## Position Data

### General Position Data

To get data about a specific position, input the NFT tokenId. This queries the subscriptions, unsubscriptions, and transfers for the position with tokenId 3. Reference the full [position schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#416) to see all fields.

```text
{
  position(id:3) {
    id
    subscriptions {
      id
    }
    unsubscriptions {
      id
    }
    transfers {
      id
    }
  }
}
```



## Contribute

There are many more queries you can do with the Uniswap v4 subgraph including data related to ticks, subscriptions, unsubscriptions, and more. Once again you can reference the full schema [here](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql). If you'd like to suggest more example queries to showcase, feel free to drop some suggestions in [discord](https://discord.com/invite/uniswap) under #dev-chat or [contribute](https://github.com/Uniswap/docs/blob/main/CONTRIBUTING.md) your own queries by submitting a pull request to the docs repo.



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Introduction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/intro)

# Introduction

## Uniswap V3 SubGraph Docs

Welcome to exploring the data of [**Uniswap**](https://uniswap.org/), the leading EVM DEX. The docs help you understand data structure in the **SubGraphs** deployed for the dex on the [graph protocol](https://thegraph.com/).

If you're completely new to the working of the V3 protocol, would recommend going through the [references](https://docs.uniswap.org/api/subgraph/subgraphs-devs/intro#references) below.

## Uniswap Foundation

The docs was possible as I recieved a grant from [Uniswap Foundation](https://uniswapfoundation.mirror.xyz/). The foundation publishes [grant wishlist for RFPs](https://uniswap.notion.site/Uniswap-Foundation-Grants-Wish-List-3be614ba4e504b5caeee7b0159e64a42) regularly if you wish to get involved.

## Get In Touch

For any updates or additions, you can raise a PR to the [docs repo](https://github.com/vintageplayer/uniswap-v3-subgraph-docs).

Feel free to reach out on [Twitter](https://twitter.com/artsofbaniya) to discuss about web3 or any field, or just to keep up with what I'm building.



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Resources](https://docs.uniswap.org/api/subgraph/subgraphs-devs/links-n-resources)

# Resources

### Repo Links:

- [V3 Subgraph Repo](https://github.com/Uniswap/v3-subgraph/tree/main)
- [V3 Core Contracts Repo](https://github.com/Uniswap/v3-core) - Mainly for factory and pool contracts
- [V3 Periphery Contract Repo](https://github.com/Uniswap/v3-periphery) - Mainly for NonFungiblePositionManager Contract

### References

- [Uniswap V3 Core Whitepaper](https://uniswap.org/whitepaper-v3.pdf)
- [Liquidity Math in Uniswap V3](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)
- [Uniswap V3 Development Book](https://uniswapv3book.com/)

### Misc

- [Uniswap Hacker Getting Started Guide](https://uniswap.notion.site/uniswap/Uniswap-Hacker-Getting-Started-Guide-781b008a16c849c8bf4d9920744e77f5)
- [Uniswap Docs](https://docs.uniswap.org/) ([Code Repo](https://github.com/Uniswap/docs/tree/main))
- [Uniswap Info Site](https://info.uniswap.org/#/) to see the pool and token stats using the subgraph
- [V3 New Chain Deployment Guide](https://github.com/Uniswap/v3-new-chain-deployments) (Slightly Outdated)

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Types](https://docs.uniswap.org/api/subgraph/subgraphs-devs/all-entities)

# Entity Types

Following Entity Types are defined in the graph [schema file](https://github.com/Uniswap/v3-subgraph/blob/main/schema.graphql):

|      | Entity                                                       | Description                                                  | Schema differs with chain |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- |
| 1.   | [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) | Captures metrics for all the pools deployed by a specific [factory contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory). | ✅                         |
| 2.   | [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) | Stores the current Eth price in USD.                         |                           |
| 3.   | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) | Stores the metadata and token level metrics for a token present in any of the pools. |                           |
| 4.   | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) | Stores a pool's metadata, current & lifetime metrics and links to events and hourly/daily metrics and references to it's tick entities. | ✅                         |
| 5.   | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) | Stores the metadata for a tick in a pool, it's lifetime metrics and current liquidity and fee variables. | ✅                         |
| 6.   | [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) | Represents a position created through [NonfungiblePositionManager](https://docs.uniswap.org/api/subgraph/contracts/nonfungiblepositionmanager). Stores it's metadata, deposited/withdrawn tokens, fee variables and transactions where it participated. | ✅                         |
| 7    | [PositionSnapshot](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/positionsnapshot) | Saves the state of a position after an action taken on the position. | ✅                         |
| 8    | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) | Stores the list of mint, burn, swap, flash and collects events emitted within a transaction. |                           |
| 9    | [Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint) | Stores details of a mint event emitted while adding liquidity to a pool |                           |
| 10   | [Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn) | Stores details of a burn event emitted while removing liquidity from a pool |                           |
| 11   | [Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap) | Stores details of a swap event emitted while swapping one token for the other in a pool |                           |
| 12   | [Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect) | Stores details of a collect event emitted while removing tokens from a position |                           |
| 13   | [Flash](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/flash) | Stores details of a flash event emitted while a flash loan was taken from a pool |                           |
| 14   | [UniswapDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/uniswapdaydata) | Daily stats for all of Uniswap.                              |                           |
| 15   | [PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata) | Daily stats for each pool                                    | ✅                         |
| 16   | [PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolhourdata) | Hourly stats for each pool                                   | ✅                         |
| 17   | [TickHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickhourdata) | Stats on Liquidity available & Volume of token traded at a tick for a given hour |                           |
| 18   | [TickDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickdaydata) | Stats on Liquidity available & Volume of token traded at a tick on a given day. (Note: this entity gets saved only if there is a change during the day) | ✅                         |
| 19   | [TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokendaydata) | Daily stats for a token across all of Uniswap.               |                           |
| 20   | [TokenHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenhourdata) | Hourly stats for a token across all of Uniswap.              |                           |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Events Monitored](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

# Events Monitored

| Event Name        | Contract Type                                                | Event handler                                                | Description                                                  |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| PoolCreated       | [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory) | [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | Event emitted when a new pool is deployed using the factory contract |
| Initialize        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleInitialize()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleinitialize) | Event emitted when a new deployed pool is initialized with current price and is ready for adding liquidity and doing swaps |
| Swap              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleSwap()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleswap) | Event emitted when a swap takes place                        |
| Mint              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleMint()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handlemint) | Event emitted when liquidity is added to the pool            |
| Burn              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleBurn()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleburn) | Event emitted when liquidity is removed from the pool        |
| Flash             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleFlash()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleflash) | Event emitted when a flash loan was taken from the pool      |
| IncreaseLiquidity | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) | Event emitted when liquidity is added to a new/existing position |
| DecreaseLiquidity | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) | Event emitted when liquidity is removed from a position      |
| Collect           | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleCollect()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handlecollect) | Event emitted when removed liquidity and it's accumulated fee collected by the position owner |
| Transfer          | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleTransfer()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handletransfer) | Even emitted whent the NFT representing the position ownership is transferred to a different address |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[Factory Contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory)

# Factory Contract

## Contract Details

| Chain        | Address                                    | StartBlock |
| ------------ | ------------------------------------------ | ---------- |
| Mainnet      | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 12369621   |
| Polygon      | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 22757547   |
| Arbitrum-One | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 175        |
| Optimism     | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 0          |

## Events Tracked

| Event Name  | Event handler                                                |
| ----------- | ------------------------------------------------------------ |
| PoolCreated | [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[NonFungiblePositionManager Contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager)

# NonFungiblePositionManager Contract

## Contract Details

| Chain        | Address                                    | StartBlock |
| ------------ | ------------------------------------------ | ---------- |
| Mainnet      | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 12369651   |
| Polygon      | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 22760586   |
| Arbitrum-One | None                                       | None       |
| Optimism     | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 0          |

## Events Tracked

| Event Name        | Event handler                                                |
| ----------------- | ------------------------------------------------------------ |
| IncreaseLiquidity | [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) |
| DecreaseLiquidity | [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) |
| Collect           | [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect) |
| Transfer          | [handleTransfer()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handletransfer) |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[Pool Contract (Templatized)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool)

# Pool Contract (Templatized)

## Contract Details

Pools are deployed dynamically and the addresses cannot be pre-determined. Thus the template feature of graph protocol is used and the Pool contracts to monitor are added when a new pool is deployed using the factory. The [`handlePoolCreated()`](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) event handler adds a new pool contract to monitor.

## Events Tracked

| Event Name | Event handler                                                |
| ---------- | ------------------------------------------------------------ |
| Initialize | [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize) |
| Swap       | [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |
| Mint       | [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |
| Burn       | [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |
| Flash      | [handleFlash()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleflash) |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Introduction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/intro)

# Introduction

## Uniswap V3 SubGraph Docs

Welcome to exploring the data of [**Uniswap**](https://uniswap.org/), the leading EVM DEX. The docs help you understand data structure in the **SubGraphs** deployed for the dex on the [graph protocol](https://thegraph.com/).

If you're completely new to the working of the V3 protocol, would recommend going through the [references](https://docs.uniswap.org/api/subgraph/subgraphs-devs/intro#references) below.

## Uniswap Foundation

The docs was possible as I recieved a grant from [Uniswap Foundation](https://uniswapfoundation.mirror.xyz/). The foundation publishes [grant wishlist for RFPs](https://uniswap.notion.site/Uniswap-Foundation-Grants-Wish-List-3be614ba4e504b5caeee7b0159e64a42) regularly if you wish to get involved.

## Get In Touch

For any updates or additions, you can raise a PR to the [docs repo](https://github.com/vintageplayer/uniswap-v3-subgraph-docs).

Feel free to reach out on [Twitter](https://twitter.com/artsofbaniya) to discuss about web3 or any field, or just to keep up with what I'm building.

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Resources](https://docs.uniswap.org/api/subgraph/subgraphs-devs/links-n-resources)

# Resources

### Repo Links:

- [V3 Subgraph Repo](https://github.com/Uniswap/v3-subgraph/tree/main)
- [V3 Core Contracts Repo](https://github.com/Uniswap/v3-core) - Mainly for factory and pool contracts
- [V3 Periphery Contract Repo](https://github.com/Uniswap/v3-periphery) - Mainly for NonFungiblePositionManager Contract

### References

- [Uniswap V3 Core Whitepaper](https://uniswap.org/whitepaper-v3.pdf)
- [Liquidity Math in Uniswap V3](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)
- [Uniswap V3 Development Book](https://uniswapv3book.com/)

### Misc

- [Uniswap Hacker Getting Started Guide](https://uniswap.notion.site/uniswap/Uniswap-Hacker-Getting-Started-Guide-781b008a16c849c8bf4d9920744e77f5)

- [Uniswap Docs](https://docs.uniswap.org/) ([Code Repo](https://github.com/Uniswap/docs/tree/main))

- [Uniswap Info Site](https://info.uniswap.org/#/) to see the pool and token stats using the subgraph

- [V3 New Chain Deployment Guide](https://github.com/Uniswap/v3-new-chain-deployments) (Slightly Outdated)

- [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Types](https://docs.uniswap.org/api/subgraph/subgraphs-devs/all-entities)

  # Entity Types

  Following Entity Types are defined in the graph [schema file](https://github.com/Uniswap/v3-subgraph/blob/main/schema.graphql):

  |      | Entity                                                       | Description                                                  | Schema differs with chain |
  | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- |
  | 1.   | [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) | Captures metrics for all the pools deployed by a specific [factory contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory). | ✅                         |
  | 2.   | [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) | Stores the current Eth price in USD.                         |                           |
  | 3.   | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) | Stores the metadata and token level metrics for a token present in any of the pools. |                           |
  | 4.   | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) | Stores a pool's metadata, current & lifetime metrics and links to events and hourly/daily metrics and references to it's tick entities. | ✅                         |
  | 5.   | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) | Stores the metadata for a tick in a pool, it's lifetime metrics and current liquidity and fee variables. | ✅                         |
  | 6.   | [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) | Represents a position created through [NonfungiblePositionManager](https://docs.uniswap.org/api/subgraph/contracts/nonfungiblepositionmanager). Stores it's metadata, deposited/withdrawn tokens, fee variables and transactions where it participated. | ✅                         |
  | 7    | [PositionSnapshot](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/positionsnapshot) | Saves the state of a position after an action taken on the position. | ✅                         |
  | 8    | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) | Stores the list of mint, burn, swap, flash and collects events emitted within a transaction. |                           |
  | 9    | [Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint) | Stores details of a mint event emitted while adding liquidity to a pool |                           |
  | 10   | [Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn) | Stores details of a burn event emitted while removing liquidity from a pool |                           |
  | 11   | [Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap) | Stores details of a swap event emitted while swapping one token for the other in a pool |                           |
  | 12   | [Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect) | Stores details of a collect event emitted while removing tokens from a position |                           |
  | 13   | [Flash](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/flash) | Stores details of a flash event emitted while a flash loan was taken from a pool |                           |
  | 14   | [UniswapDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/uniswapdaydata) | Daily stats for all of Uniswap.                              |                           |
  | 15   | [PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata) | Daily stats for each pool                                    | ✅                         |
  | 16   | [PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolhourdata) | Hourly stats for each pool                                   | ✅                         |
  | 17   | [TickHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickhourdata) | Stats on Liquidity available & Volume of token traded at a tick for a given hour |                           |
  | 18   | [TickDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickdaydata) | Stats on Liquidity available & Volume of token traded at a tick on a given day. (Note: this entity gets saved only if there is a change during the day) | ✅                         |
  | 19   | [TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokendaydata) | Daily stats for a token across all of Uniswap.               |                           |
  | 20   | [TokenHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenhourdata) | Hourly stats for a token across all of Uniswap.              |                           |

  [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Events Monitored](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

  # Events Monitored

  | Event Name        | Contract Type                                                | Event handler                                                | Description                                                  |
  | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | PoolCreated       | [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory) | [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | Event emitted when a new pool is deployed using the factory contract |
  | Initialize        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleInitialize()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleinitialize) | Event emitted when a new deployed pool is initialized with current price and is ready for adding liquidity and doing swaps |
  | Swap              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleSwap()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleswap) | Event emitted when a swap takes place                        |
  | Mint              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleMint()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handlemint) | Event emitted when liquidity is added to the pool            |
  | Burn              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleBurn()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleburn) | Event emitted when liquidity is removed from the pool        |
  | Flash             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) | [handleFlash()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/core.ts#handleflash) | Event emitted when a flash loan was taken from the pool      |
  | IncreaseLiquidity | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) | Event emitted when liquidity is added to a new/existing position |
  | DecreaseLiquidity | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) | Event emitted when liquidity is removed from a position      |
  | Collect           | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleCollect()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handlecollect) | Event emitted when removed liquidity and it's accumulated fee collected by the position owner |
  | Transfer          | [NonFungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager) | [handleTransfer()](https://docs.uniswap.org/api/subgraph/functions-n-handlers/mappings/position-manager.ts#handletransfer) | Even emitted whent the NFT representing the position ownership is transferred to a different address |

  [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[Factory Contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory)

  # Factory Contract

  ## Contract Details

  | Chain        | Address                                    | StartBlock |
  | ------------ | ------------------------------------------ | ---------- |
  | Mainnet      | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 12369621   |
  | Polygon      | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 22757547   |
  | Arbitrum-One | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 175        |
  | Optimism     | 0x1F98431c8aD98523631AE4a59f267346ea31F984 | 0          |

  ## Events Tracked

  | Event Name  | Event handler                                                |
  | ----------- | ------------------------------------------------------------ |
  | PoolCreated | [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) |

  [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[NonFungiblePositionManager Contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager)

  # NonFungiblePositionManager Contract

  ## Contract Details

  | Chain        | Address                                    | StartBlock |
  | ------------ | ------------------------------------------ | ---------- |
  | Mainnet      | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 12369651   |
  | Polygon      | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 22760586   |
  | Arbitrum-One | None                                       | None       |
  | Optimism     | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 0          |

  ## Events Tracked

  | Event Name        | Event handler                                                |
  | ----------------- | ------------------------------------------------------------ |
  | IncreaseLiquidity | [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) |
  | DecreaseLiquidity | [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) |
  | Collect           | [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect) |
  | Transfer          | [handleTransfer()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handletransfer) |

  [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Contracts](https://docs.uniswap.org/category/contracts)[Pool Contract (Templatized)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool)

  # Pool Contract (Templatized)

  ## Contract Details

  Pools are deployed dynamically and the addresses cannot be pre-determined. Thus the template feature of graph protocol is used and the Pool contracts to monitor are added when a new pool is deployed using the factory. The [`handlePoolCreated()`](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) event handler adds a new pool contract to monitor.

  ## Events Tracked

  | Event Name | Event handler                                                |
  | ---------- | ------------------------------------------------------------ |
  | Initialize | [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize) |
  | Swap       | [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |
  | Mint       | [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |
  | Burn       | [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |
  | Flash      | [handleFlash()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleflash) |

  [APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory)

  # Factory

  Entity to capture metrics for all the pools deployed by a specific [factory contract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/factory).

  ## Schema

  | Field                        | Type        | derivedFrom | Description                                                  |
  | ---------------------------- | ----------- | ----------- | ------------------------------------------------------------ |
  | id                           | ID!         |             | Factory Contract address                                     |
  | poolCount                    | BigInt!     |             | No. of pools created using the factory                       |
  | txCount                      | BigInt!     |             | No. of all the transactions through pools mananged by the factory |
  | totalVolumeUSD               | BigDecimal! |             | Total Volume all time in derived USD                         |
  | totalVolumeETH               | BigDecimal! |             | Total Volume all time in derived ETH                         |
  | totalFeesUSD                 | BigDecimal! |             | Total Swap Fees all time in derived USD                      |
  | totalFeesETH                 | BigDecimal! |             | Total Swap Fees all time in derived ETH                      |
  | untrackedVolumeUSD           | BigDecimal! |             | Total Volume all time, including less reliable USD values    |
  | totalValueLockedUSD          | BigDecimal! |             | TVL derived in USD                                           |
  | totalValueLockedETH          | BigDecimal! |             | TVL derived in ETH                                           |
  | totalValueLockedUSDUntracked | BigDecimal! |             | TVL including tokens with unreliable USD prices in USD       |
  | totalValueLockedETHUntracked | BigDecimal! |             | TVL including tokens with unreliable USD prices in ETH       |
  | populated                    | Boolean     |             | Flag capturing if the new pool is populated                  |
  | owner                        | ID!         |             | Current Owner of the factory contract                        |

  ## Referencing Functions

  | FunctionName                                                 | Create | Read | Update | Save |
  | ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
  | [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | ✅      | ✅    | ✅      | ✅    |
  | [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        | ✅    | ✅      | ✅    |
  | [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        | ✅    | ✅      | ✅    |
  | [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |
  | [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata) |        | ✅    |        |      |

  

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle)

# Bundle

Entity to store the current Eth price in USD.

## Schema

| Field       | Type        | derivedFrom | Description                                         |
| ----------- | ----------- | ----------- | --------------------------------------------------- |
| id          | ID!         |             | ID to fetch a unique entity. (Only ID='1' is used.) |
| ethPriceUSD | BigDecimal! |             | Price of ETH in USD                                 |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken) |        | ✅    |        |      |
| [getTrackedAmountUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#gettrackedamountusd) |        | ✅    |        |      |
| [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | ✅      |      | ✅      | ✅    |
| [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize) |        |      | ✅*     | ✅*   |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        | ✅    |        |      |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        | ✅    |        |      |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |
| [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) |        | ✅*   |        |      |
| [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) |        | ✅*   |        |      |
| [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect) |        | ✅*   |        |      |
| [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalupdates.ts#updatetokendaydata) |        | ✅    |        |      |
| [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalupdates.ts#updatetokenhourdata) |        | ✅    |        |      |

\* -> Varies across chains

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)

# Token

Entity to stores the metadata and token level metrics for a token present in any of the pools.

## Schema

| Field                        | Type                                                         | derivedFrom                  | Description                                                  |
| ---------------------------- | ------------------------------------------------------------ | ---------------------------- | ------------------------------------------------------------ |
| id                           | ID!                                                          |                              | Token Contract Address                                       |
| symbol                       | String!                                                      |                              | Token Symbol                                                 |
| name                         | String!                                                      |                              | Token Name                                                   |
| decimals                     | BigInt!                                                      |                              | No. of decimals in the token value                           |
| totalSupply                  | BigInt!                                                      |                              | Total supply of the token                                    |
| volume                       | BigDecimal!                                                  |                              | Total token volume traded in swaps                           |
| volumeUSD                    | BigDecimal!                                                  |                              | Total token value traded in swaps in USD                     |
| untrackedVolumeUSD           | BigDecimal!                                                  |                              | Total token value traded in USD, including pools with unreliable USD values |
| feesUSD                      | BigDecimal!                                                  |                              | Amount of Fees taken from token swaps in derived in USD      |
| txCount                      | BigInt!                                                      |                              | No. of transactions across all pools that include this token |
| poolCount                    | BigInt!                                                      |                              | No. of pools containing this token                           |
| totalValueLocked             | BigDecimal!                                                  |                              | Liquidity across all pools for the token                     |
| totalValueLockedUSD          | BigDecimal!                                                  |                              | Liquidity across all pools for the token in terms of USD value |
| totalValueLockedUSDUntracked | BigDecimal!                                                  |                              | Liquidity across all pools (including pools with unreliable USD values) for the token in terms of USD value |
| derivedETH                   | BigDecimal!                                                  |                              | Price of token relative to ETH                               |
| whitelistPools               | [[Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)!]! |                              | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) entities which can can be used for reliable USD pricing of the token |
| tokenDayData                 | [[TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokendaydata)!]! | @derivedFrom(field: "token") | Link to daily stats for the token                            |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [sqrtPriceX96ToTokenPrices()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#sqrtpricex96totokenprices) |        | ✅    |        |      |
| [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken) |        | ✅    |        |      |
| [getTrackedAmountUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#gettrackedamountusd) |        | ✅    |        |      |
| [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata) |        | ✅    |        |      |
| [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata) |        | ✅    |        |      |
| [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize) |        | ✅*   | ✅      | ✅    |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        | ✅    | ✅      | ✅    |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        | ✅    | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅*   |
| [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | ✅      | ✅    | ✅      | ✅    |
| [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) |        | ✅    |        |      |
| [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) |        | ✅    |        |      |
| [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect) |        | ✅    |        |      |
| [populateToken()*](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populatetoken) | ✅      |      | ✅      | ✅    |
| [populateEmptyPools()*](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populateemptypools) |        | ✅    | ✅      | ✅    |

\* -> Different across chains



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)

# Pool

Entity to store a pool's metadata, current & lifetime metrics and links to events and hourly/daily metrics and references to it's tick entities.

## Schema

| Field                        | Type                                                         | derivedFrom                 | Description                                                  | Field Missing |
| ---------------------------- | ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ | ------------- |
| id                           | ID!                                                          |                             | Pool Contract Address                                        |               |
| createdAtTimestamp           | BigInt!                                                      |                             | BlockTime where the pool was created                         |               |
| createdAtBlockNumber         | BigInt!                                                      |                             | Block Number where the pool was created                      |               |
| token0                       | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |                             | Token entity for token0                                      |               |
| token1                       | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |                             | Token entity for token1                                      |               |
| feeTier                      | BigInt!                                                      |                             | The percentage of token taken as fee in terms of basis points |               |
| liquidity                    | BigInt!                                                      |                             | Liquidity in the currently active tick range                 |               |
| sqrtPrice                    | BigInt!                                                      |                             | The current token pair price tracked in square root & Q96 format |               |
| feeGrowthGlobal0X128         | BigInt!                                                      |                             | The total fee in token0 per unit of liquidity collected by the pool | arbitrum-one  |
| feeGrowthGlobal1X128         | BigInt!                                                      |                             | The total fee in token1 per unit of liquidity collected by the pool | arbitrum-one  |
| token0Price                  | BigDecimal!                                                  |                             | Price of token0 in terms of token1                           |               |
| token1Price                  | BigDecimal!                                                  |                             | Price of token1 in terms of token0                           |               |
| tick                         | BigInt                                                       |                             | The current active [tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) |               |
| observationIndex             | BigInt!                                                      |                             | The current observation index (used to record historic prices) |               |
| volumeToken0                 | BigDecimal!                                                  |                             | Total volume of token0 swapped in the pool                   |               |
| volumeToken1                 | BigDecimal!                                                  |                             | Total volume of token1 swapped in the pool                   |               |
| volumeUSD                    | BigDecimal!                                                  |                             | Total volume swapped in the pool in USD value                |               |
| untrackedVolumeUSD           | BigDecimal!                                                  |                             | Total volume swapped in the pool (including values for unreliable USD pools) in USD value |               |
| feesUSD                      | BigDecimal!                                                  |                             | Total fee collected in USD value                             |               |
| txCount                      | BigInt!                                                      |                             | Total no. of transactions in the pool                        |               |
| collectedFeesToken0          | BigDecimal!                                                  |                             | Total amount of token0 fee collected                         |               |
| collectedFeesToken1          | BigDecimal!                                                  |                             | Total amount of token1 fee collected                         |               |
| collectedFeesUSD             | BigDecimal!                                                  |                             | Total amount of fee collected in USD value                   |               |
| totalValueLockedToken0       | BigDecimal!                                                  |                             | Total amount of token0 locked across all ticks in the pool   |               |
| totalValueLockedToken1       | BigDecimal!                                                  |                             | Total amount of token1 locked across all ticks in the pool   |               |
| totalValueLockedETH          | BigDecimal!                                                  |                             | Total value locked in the pool in ETH value                  |               |
| totalValueLockedUSD          | BigDecimal!                                                  |                             | Total value locked in the pool in USD value                  |               |
| totalValueLockedUSDUntracked | BigDecimal!                                                  |                             | Total value locked in the pool (including tokens with unreliable USD values) in USD value |               |
| liquidityProviderCount       | BigInt!                                                      |                             | Used for detecting new exchanges. (Currently not updated Anywhere) |               |
| poolHourData                 | [[PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolhourdata)!]! | @derivedFrom(field: "pool") | Hourly Snapshots of Pool's data                              |               |
| poolDayData                  | [[PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata)!]! | @derivedFrom(field: "pool") | Daily Snapshots of Pool's data                               |               |
| mints                        | [[Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint)!]! | @derivedFrom(field: "pool") | Mint Events emitted from the Pool                            |               |
| burns                        | [[Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn)!]! | @derivedFrom(field: "pool") | Burn Events emitted from the Pool                            |               |
| swaps                        | [[Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap)!]! | @derivedFrom(field: "pool") | Swap Events emitted from the Pool                            |               |
| collects                     | [[Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect)!]! | @derivedFrom(field: "pool") | Collect Events emitted from the Pool                         |               |
| ticks                        | [[Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)!]! | @derivedFrom(field: "pool") | Tick entities respresenting the Pool liquidity               |               |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated) | ✅      |      | ✅      | ✅    |
| [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata) |        | ✅    |        |      |
| [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata) |        | ✅    |        |      |
| [getEthPriceInUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#getethpriceinusd) |        | ✅    |        |      |
| [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken) |        | ✅    |        |      |
| [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize) |        | ✅    | ✅      | ✅*   |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        | ✅    | ✅      | ✅    |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        | ✅    | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |
| [handleFlash()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleflash) |        |      | ✅      | ✅    |
| [populateEmptyPools()*](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populateemptypools) | ✅      |      | ✅      | ✅    |

\* -> Different across chains

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)

# Tick

Entity to stores the metadata for a tick in a pool, it's lifetime metrics and current liquidity and fee variables.

## Schema

| Field                  | Type                                                         | derivedFrom | Description                                                  | Field Missing |
| ---------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ------------- |
| id                     | ID!                                                          |             | Tick ID. Format: `<pool address>#<tick address>`             |               |
| poolAddress            | String                                                       |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) contract address |               |
| tickIdx                | BigInt!                                                      |             | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) Index |               |
| pool                   | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) Entity |               |
| liquidityGross         | BigInt!                                                      |             | Total Liquidity the pool has at the tick with it's lower and upper range. |               |
| liquidityNet           | BigInt!                                                      |             | Liquidity change when the tick is crossed                    |               |
| price0                 | BigDecimal!                                                  |             | Price of token0 at this tick (constant)                      |               |
| price1                 | BigDecimal!                                                  |             | Price of token1 at this tick (constant)                      |               |
| volumeToken0           | BigDecimal!                                                  |             | Total volume of token0 transacted with tick in active range  |               |
| volumeToken1           | BigDecimal!                                                  |             | Total volume of token1 transacted with tick in active range  |               |
| volumeUSD              | BigDecimal!                                                  |             | Total transacted value with tick in active range in USD      |               |
| untrackedVolumeUSD     | BigDecimal!                                                  |             | Total transacted value with tick in active range (including tokens with unreliable USD value) in USD |               |
| feesUSD                | BigDecimal!                                                  |             | Fee collected with the tick in active range in USD           |               |
| collectedFeesToken0    | BigDecimal!                                                  |             | Total amount of token0 collected as fee when this tick is active |               |
| collectedFeesToken1    | BigDecimal!                                                  |             | Total amount of token1 collected as fee when this tick is active |               |
| collectedFeesUSD       | BigDecimal!                                                  |             | Total value of fee collected when this tick is active is USD |               |
| createdAtTimestamp     | BigInt!                                                      |             | BlockTime when the tick was initialized                      |               |
| createdAtBlockNumber   | BigInt!                                                      |             | BlockNumber when the tick was initialized                    |               |
| liquidityProviderCount | BigInt!                                                      |             | Used for detecting new exchanges. (Not Used currently)       |               |
| feeGrowthOutside0X128  | BigInt!                                                      |             | Used for calculating token0 fee's accumulated outside a tick whenever it is crossed | arbitrum-one  |
| feeGrowthOutside1X128  | BigInt!                                                      |             | Used for calculating token1 fee's accumulated outside a tick whenever it is crossed | arbitrum-one  |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick) | ✅      |      | ✅      |      |
| [updateTickDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetickdaydata) |        | ✅    |        |      |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        |      | ✅      |      |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        |      | ✅      |      |
| [updateTickFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave) |        |      | ✅      | ✅    |
| [loadTickUpdateFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#loadtickupdatefeevarsandsave) |        | ✅    |        |      |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position)

# Position

Entity to store details of a position created through [NonfungiblePositionManager](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager). Stores it's metadata, deposited/withdrawn tokens, fee variables and transactions where it participated.

Entity Not Defined

- Currently the entity is not defined for arbitrum-one chain

## Schema

| Field                    | Type                                                         | derivedFrom | Description                                                  | Field Missing     |
| ------------------------ | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ----------------- |
| id                       | ID!                                                          |             | Position NFT Token ID                                        |                   |
| owner                    | Bytes!                                                       |             | Position NFT owner's address                                 |                   |
| pool                     | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) where the position staked the tokens |                   |
| token0                   | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token0 entity of the pool                                    |                   |
| token1                   | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token1 entity of the pool                                    |                   |
| tickLower                | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)! |             | Lower [Tick Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) of the position |                   |
| tickUpper                | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)! |             | Upper [Tick Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) of the position |                   |
| liquidity                | BigInt!                                                      |             | Total liquidity added by the position                        |                   |
| depositedToken0          | BigDecimal!                                                  |             | Total amount token0 ever deposited to the position           |                   |
| depositedToken1          | BigDecimal!                                                  |             | Total amount token1 ever deposited to the position           |                   |
| withdrawnToken0          | BigDecimal!                                                  |             | Total amount token0 withdrawn to the position (excluding fees) |                   |
| withdrawnToken1          | BigDecimal!                                                  |             | Total amount token1 withdrawn to the position (excluding fees) |                   |
| collectedToken0          | BigDecimal!                                                  |             | Total amount of token0 collected (inclusive of burn amounts) | mainnet           |
| collectedToken1          | BigDecimal!                                                  |             | Total amount of token1 collected (inclusive of burn amounts) | mainnet           |
| collectedFeesToken0      | BigDecimal!                                                  |             | Total amount token0 fee collected                            |                   |
| collectedFeesToken1      | BigDecimal!                                                  |             | Total amount token1 fee collected                            |                   |
| amountDepositedUSD       | BigDecimal!                                                  |             | Total amount deposited in terms of USD                       | mainnet, optimsim |
| amountWithdrawnUSD       | BigDecimal!                                                  |             | Total amount withdrawn in terms of USD                       | mainnet, optimism |
| amountCollectedUSD       | BigDecimal!                                                  |             | Total amount collected in terms of USD                       | mainnet, optimism |
| transaction              | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the position was created |                   |
| feeGrowthInside0LastX128 | BigInt!                                                      |             | Tracking the amount of token0 fee accumulated by the position |                   |
| feeGrowthInside1LastX128 | BigInt!                                                      |             | Tracking the amount of token1 fee accumulated by the position |                   |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition) | ✅      |      | ✅      |      |
| [updateFeeVars()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#updatefeevars) |        |      | ✅      |      |
| [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot) |        | ✅    |        |      |
| [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity) |        | ✅    | ✅      | ✅    |
| [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity) |        | ✅    | ✅      | ✅    |
| [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect) |        | ✅    | ✅      | ✅    |
| [handleTransfer()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handletransfer) |        |      | ✅      | ✅    |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[PositionSnapshot](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/positionsnapshot)

# PositionSnapshot

Entity storing the state of a position after an action taken on the position.

Entity Not Defined

- Currently the entity is not defined for arbitrum-one chain

## Schema

| Field                    | Type                                                         | derivedFrom | Description                                                  |
| ------------------------ | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id                       | ID!                                                          |             | Position Snapshot ID. Format: `<NFT Token ID>#<Block Number>` |
| owner                    | Bytes!                                                       |             | Position NFT's Owner's Address                               |
| pool                     | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) entity to which the position belongs to |
| position                 | [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position)! |             | [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) entity for which the snapshot is taken |
| blockNumber              | BigInt!                                                      |             | BlockNumber in which the snapshot was created                |
| timestamp                | BigInt!                                                      |             | Timestamp of the block in which the snapshot was created     |
| liquidity                | BigInt!                                                      |             | Total Liquidity of the position                              |
| depositedToken0          | BigDecimal!                                                  |             | Total amount of token0 ever deposited to the position        |
| depositedToken1          | BigDecimal!                                                  |             | Total amount of token1 ever deposited to the position        |
| withdrawnToken0          | BigDecimal!                                                  |             | Total amount of token0 withdrawn from the position (excluding the fee) |
| withdrawnToken1          | BigDecimal!                                                  |             | Total amount of token1 withdrawn from the position (excluding the fee) |
| collectedFeesToken0      | BigDecimal!                                                  |             | Total amount of token0 fee collected                         |
| collectedFeesToken1      | BigDecimal!                                                  |             | Total amount of token1 fee collected                         |
| transaction              | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the Snapshot was created. |
| feeGrowthInside0LastX128 | BigInt!                                                      |             | Marker to compute the position's token0 fee in a pool        |
| feeGrowthInside1LastX128 | BigInt!                                                      |             | Marker to compute the position's token1 fee in a pool        |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot) | ✅      |      | ✅      | ✅    |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)

# Transaction

Entity capturing uniswap transaction details with a list of mint, burn, swap, flash and collects events emitted within a transaction.

## Schema

| Field       | Type                                                         | derivedFrom                        | Description                                                  |
| ----------- | ------------------------------------------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| id          | ID!                                                          |                                    | Transaction Hash                                             |
| blockNumber | BigInt!                                                      |                                    | Block Number where the transaction was added to the chain    |
| timestamp   | BigInt!                                                      |                                    | Timestamp of the block where the transaction was added to the chain |
| gasUsed     | BigInt!                                                      |                                    | Amount of Gas Units Consumed to execute the transaction      |
| gasPrice    | BigInt!                                                      |                                    | Cost of one unit Gas paid for the transaction                |
| mints       | [[Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint)]! | @derivedFrom(field: "transaction") | [Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint) entities created in this transaction |
| burns       | [[Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn)]! | @derivedFrom(field: "transaction") | [Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn) entities created in this transaction |
| swaps       | [[Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap)]! | @derivedFrom(field: "transaction") | [Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap) entities created in this transaction |
| flashed     | [[Flash](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/flash)]! | @derivedFrom(field: "transaction") | [Flash](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/flash) entities created in this transaction |
| collects    | [[Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect)]! | @derivedFrom(field: "transaction") | [Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect) entities created in this transaction |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction) | ✅      |      | ✅      | ✅    |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) |        | ✅    |        |      |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) |        | ✅    |        |      |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    |        |      |
| [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition) |        | ✅    |        |      |
| [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot) |        | ✅    |        |      |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint)

# Mint

Entity to store details of a mint event emitted while adding liquidity to a pool.

## Schema

| Field       | Type                                                         | derivedFrom | Description                                                  |
| ----------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id          | ID!                                                          |             | Mint Entity ID. Format: `<transaction hash>#<index in transaction.mints array>` |
| transaction | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the mint event was emitted |
| timestamp   | BigInt!                                                      |             | Timestamp of the block in which which the mint event was emitted |
| pool        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) in which the mint event was emitted |
| token0      | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token0 entity of the pool                                    |
| token1      | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token1 entity of the pool                                    |
| owner       | Bytes!                                                       |             | owner of the position to which the liquidity was minted      |
| sender      | Bytes                                                        |             | the address that minted the liquidity                        |
| origin      | Bytes!                                                       |             | The EOA address that initiated the transaction               |
| amount      | BigInt!                                                      |             | Amount of liquidity minted                                   |
| amount0     | BigDecimal!                                                  |             | Amount of token0 minted                                      |
| amount1     | BigDecimal!                                                  |             | Amount of token1 minted                                      |
| amountUSD   | BigDecimal                                                   |             | Mint value derived in USD based on available prices of tokens |
| tickLower   | BigInt!                                                      |             | Lower tick of the position                                   |
| tickUpper   | BigInt!                                                      |             | Upper tick of the position                                   |
| logIndex    | BigInt                                                       |             | Order of the Mint Event within the logs of the transaction   |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint) | ✅      |      | ✅      | ✅    |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn)

# Burn

Entity to stores the details of a burn event emitted while removing liquidity from a pool.

## Schema

| Field       | Type                                                         | derivedFrom | Description                                                  |
| ----------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id          | ID!                                                          |             | Burn Entity ID. Format: `<transaction hash>#<index in transaction.burns array>` |
| transaction | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the burn event was emitted |
| pool        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) in which the burn event was emitted |
| token0      | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token0 entity of the pool                                    |
| token1      | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token1 entity of the pool                                    |
| timestamp   | BigInt!                                                      |             | Timestamp of the block in which which the burn event was emitted |
| owner       | Bytes!                                                       |             | owner of the position to which the liquidity was burnt       |
| origin      | Bytes!                                                       |             | The EOA address that initiated the transaction               |
| amount      | BigInt!                                                      |             | Amount of liquidity burnt                                    |
| amount0     | BigDecimal!                                                  |             | Amount of token0 burnt                                       |
| amount1     | BigDecimal!                                                  |             | Amount of token1 burnt                                       |
| amountUSD   | BigDecimal                                                   |             | Burn value derived in USD based on available prices of tokens |
| tickLower   | BigInt!                                                      |             | Lower tick of the position                                   |
| tickUpper   | BigInt!                                                      |             | Upper tick of the position                                   |
| logIndex    | BigInt                                                       |             | Order of the Burn event within the logs of the transaction   |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn) | ✅      |      | ✅      | ✅    |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap)

# Swap

Entity to stores details of a swap event emitted while swapping one token for the other in a pool.

## Schema

| Field        | Type                                                         | derivedFrom | Description                                                  |
| ------------ | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id           | ID!                                                          |             | Swap Entity ID. Format: `<transaction hash>#<index in transaction.swaps array>` |
| transaction  | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the swap event was emitted |
| timestamp    | BigInt!                                                      |             | Timestamp of the block in which which the swap event was emitted |
| pool         | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) in which the swap event was emitted |
| token0       | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token0 entity of the pool                                    |
| token1       | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | token1 entity of the pool                                    |
| sender       | Bytes                                                        |             | the address that triggered the swap                          |
| recipient    | Bytes!                                                       |             | The address that gets their tokens swapped                   |
| origin       | Bytes!                                                       |             | The EOA address that initiated the transaction               |
| amount0      | BigDecimal!                                                  |             | Amount of token0 swapped                                     |
| amount1      | BigDecimal!                                                  |             | Amount of token1 swapped                                     |
| amountUSD    | BigDecimal                                                   |             | Swapped token value derived in USD based on available prices of tokens |
| sqrtPriceX96 | BigInt!                                                      |             | The sqrt(price) of the pool after the swap, as a Q64.96      |
| tick         | BigInt!                                                      |             | The tick after the swap                                      |
| logIndex     | BigInt                                                       |             | Order of the swap event within the logs of the transaction   |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) | ✅      |      | ✅      | ✅    |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Collect](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/collect)

# Collect

Entity to store details of a collect event emitted while removing tokens from a position.

## Schema

| Field       | Type                                                         | derivedFrom | Description                                                  |
| ----------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id          | ID!                                                          |             | Collect Entity ID. Format: `<transaction hash>#<index in transaction.collects array>` |
| transaction | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the collect event was emitted |
| timestamp   | BigInt!                                                      |             | Timestamp of the block in which which the collect event was emitted |
| pool        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) in which the collect event was emitted |
| owner       | Bytes!                                                       |             | owner of the position from which the tokens were collected   |
| amount0     | BigDecimal!                                                  |             | Amount of token0 collected                                   |
| amount1     | BigDecimal!                                                  |             | Amount of token1 collected                                   |
| amountUSD   | BigDecimal                                                   |             | Collect value derived in USD based on available prices of tokens |
| tickLower   | BigInt!                                                      |             | Lower tick of the position                                   |
| tickUpper   | BigInt!                                                      |             | Upper tick of the position                                   |
| logIndex    | BigInt                                                       |             | Order of the Collect Event within the logs of the transaction |

## Referencing Functions

danger

Couldn't find any references to collect schema

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[Flash](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/flash)

# Flash

Entity to store details of a flash event emitted while a flash loan was taken from a pool.

## Schema

| Field       | Type                                                         | derivedFrom | Description                                                  |
| ----------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id          | ID!                                                          |             | Flash Entity ID. Format: `<transaction hash>#<index in transaction.flashed array>` |
| transaction | [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction)! |             | [Transaction Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) in which the flash event was emitted |
| timestamp   | BigInt!                                                      |             | Timestamp of the block in which which the flash event was emitted |
| pool        | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) in which the flash event was emitted |
| sender      | Bytes                                                        |             | the address of the sender that invoked the flash operation   |
| recipient   | Bytes!                                                       |             | the address of the recipient that received the flash amount  |
| amount0     | BigDecimal!                                                  |             | Amount of token0 flashed                                     |
| amount1     | BigDecimal!                                                  |             | Amount of token1 flashed                                     |
| amountUSD   | BigDecimal                                                   |             | Flash value derived in USD based on available prices of tokens |
| amount0Paid | BigDecimal!                                                  |             | Amount of token0 paid for the flash operation                |
| amount1Paid | BigDecimal!                                                  |             | Amount of token1 paid for the flash operation                |
| logIndex    | BigInt                                                       |             | Order of the Flash Event within the logs of the transaction  |

## Referencing Functions

danger

Couldn't find any references to collect schema



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[UniswapDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/uniswapdaydata)

# UniswapDayData

Entities capturing the daily metrics for all of the Uniswap protocol.

## Schema

| Field              | Type        | derivedFrom | Description                                                  |
| ------------------ | ----------- | ----------- | ------------------------------------------------------------ |
| id                 | ID!         |             | Timestamp rounded to current day by dividing by 86400        |
| date               | Int!        |             | Timestamp rounded to current day by dividing by 86400        |
| volumeETH          | BigDecimal! |             | Total daily volume in Uniswap derived in terms of ETH        |
| volumeUSD          | BigDecimal! |             | Total daily volume in Uniswap derived in terms of USD        |
| volumeUSDUntracked | BigDecimal! |             | total daily volume in Uniswap derived in terms of USD (including tokens with unreliable USD value) |
| feesUSD            | BigDecimal! |             | Amount of swap fee taken during the day in terms of USD      |
| txCount            | BigInt!     |             | No. of transactions that occurred during the day             |
| tvlUSD             | BigDecimal! |             | TVL locked at the end of the day in terms of USD             |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata) | ✅      |      | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata)

# PoolDayData

Entity to store the daily metrics for each pool.

## Schema

| Field                | Type                                                         | derivedFrom | Description                                                  | Field Missing |
| -------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ------------- |
| id                   | ID!                                                          |             | PoolDayData Entity ID. Format: `<pool.address>-<Timestamp rounded to current day by dividing by 86400>` |               |
| date                 | Int!                                                         |             | Timestamp rounded to hour by dividing by 86400               |               |
| pool                 | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) for which the daily metrics are tracked |               |
| liquidity            | BigInt!                                                      |             | In range Liquidity at the end of the day                     |               |
| sqrtPrice            | BigInt!                                                      |             | Pool Price at the end of the day                             |               |
| token0Price          | BigDecimal!                                                  |             | Price of token0 in terms of token1 at the end of the day     |               |
| token1Price          | BigDecimal!                                                  |             | Price of token1 in terms of token0 at the end of the day     |               |
| tick                 | BigInt                                                       |             | Actice Tick at the end of the day                            |               |
| feeGrowthGlobal0X128 | BigInt!                                                      |             | Global Fee Marker Value for token0 at the end of the day     | arbitrum-one  |
| feeGrowthGlobal1X128 | BigInt!                                                      |             | Global Fee Marker Value for token1 at the end of the day     | arbitrum-one  |
| tvlUSD               | BigDecimal!                                                  |             | TVL available at the end of the day derived in USD           |               |
| volumeToken0         | BigDecimal!                                                  |             | Total daily volume in token0                                 |               |
| volumeToken1         | BigDecimal!                                                  |             | Total daily volume in token1                                 |               |
| volumeUSD            | BigDecimal!                                                  |             | Total daily volume in USD                                    |               |
| feesUSD              | BigDecimal!                                                  |             | Total swap fee taken during the day in terms of USD          |               |
| txCount              | BigInt!                                                      |             | No. of transactions in pool executed during the day          |               |
| open                 | BigDecimal!                                                  |             | Open Price of token0                                         |               |
| high                 | BigDecimal!                                                  |             | High Price of token0                                         |               |
| low                  | BigDecimal!                                                  |             | Low Price of token0                                          |               |
| close                | BigDecimal!                                                  |             | Close Price of token0                                        |               |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata) | ✅      | ✅    | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata)

# PoolDayData

Entity to store the daily metrics for each pool.

## Schema

| Field                | Type                                                         | derivedFrom | Description                                                  | Field Missing |
| -------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ------------- |
| id                   | ID!                                                          |             | PoolDayData Entity ID. Format: `<pool.address>-<Timestamp rounded to current day by dividing by 86400>` |               |
| date                 | Int!                                                         |             | Timestamp rounded to hour by dividing by 86400               |               |
| pool                 | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) for which the daily metrics are tracked |               |
| liquidity            | BigInt!                                                      |             | In range Liquidity at the end of the day                     |               |
| sqrtPrice            | BigInt!                                                      |             | Pool Price at the end of the day                             |               |
| token0Price          | BigDecimal!                                                  |             | Price of token0 in terms of token1 at the end of the day     |               |
| token1Price          | BigDecimal!                                                  |             | Price of token1 in terms of token0 at the end of the day     |               |
| tick                 | BigInt                                                       |             | Actice Tick at the end of the day                            |               |
| feeGrowthGlobal0X128 | BigInt!                                                      |             | Global Fee Marker Value for token0 at the end of the day     | arbitrum-one  |
| feeGrowthGlobal1X128 | BigInt!                                                      |             | Global Fee Marker Value for token1 at the end of the day     | arbitrum-one  |
| tvlUSD               | BigDecimal!                                                  |             | TVL available at the end of the day derived in USD           |               |
| volumeToken0         | BigDecimal!                                                  |             | Total daily volume in token0                                 |               |
| volumeToken1         | BigDecimal!                                                  |             | Total daily volume in token1                                 |               |
| volumeUSD            | BigDecimal!                                                  |             | Total daily volume in USD                                    |               |
| feesUSD              | BigDecimal!                                                  |             | Total swap fee taken during the day in terms of USD          |               |
| txCount              | BigInt!                                                      |             | No. of transactions in pool executed during the day          |               |
| open                 | BigDecimal!                                                  |             | Open Price of token0                                         |               |
| high                 | BigDecimal!                                                  |             | High Price of token0                                         |               |
| low                  | BigDecimal!                                                  |             | Low Price of token0                                          |               |
| close                | BigDecimal!                                                  |             | Close Price of token0                                        |               |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata) | ✅      | ✅    | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅    |





[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolhourdata)

# PoolHourData

Entity to store the hourly stats for each pool.

## Schema

| Field                | Type                                                         | derivedFrom | Description                                                  | Field Missing |
| -------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ------------- |
| id                   | ID!                                                          |             | PoolHourData Entity ID. Format: `<pool.address>-<Timestamp rounded to the hour by dividing by 3600>` |               |
| periodStartUnix      | Int!                                                         |             | Timestamp rounded to hour by dividing by 3600                |               |
| pool                 | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) for which the hourly metrics are tracked |               |
| liquidity            | BigInt!                                                      |             | In range Liquidity at the end of the hour                    |               |
| sqrtPrice            | BigInt!                                                      |             | Pool Price at the end of the hour                            |               |
| token0Price          | BigDecimal!                                                  |             | Price of token0 in terms of token1 at the end of the hour    |               |
| token1Price          | BigDecimal!                                                  |             | Price of token1 in terms of token0 at the end of the hour    |               |
| tick                 | BigInt                                                       |             | Actice Tick at the end of the hour                           |               |
| feeGrowthGlobal0X128 | BigInt!                                                      |             | Global Fee Marker Value for token0 at the end of the hour    | arbitrum-one  |
| feeGrowthGlobal1X128 | BigInt!                                                      |             | Global Fee Marker Value for token1 at the end of the hour    | arbitrum-one  |
| tvlUSD               | BigDecimal!                                                  |             | TVL available at the end of the hour derived in USD          |               |
| volumeToken0         | BigDecimal!                                                  |             | Total hourly volume in token0                                |               |
| volumeToken1         | BigDecimal!                                                  |             | Total hourly volume in token1                                |               |
| volumeUSD            | BigDecimal!                                                  |             | Total hourly volume in USD                                   |               |
| feesUSD              | BigDecimal!                                                  |             | Total swap fee taken during the hour in terms of USD         |               |
| txCount              | BigInt!                                                      |             | No. of transactions in pool executed during the hour         |               |
| open                 | BigDecimal!                                                  |             | Open Price of token0                                         |               |
| high                 | BigDecimal!                                                  |             | High Price of token0                                         |               |
| low                  | BigDecimal!                                                  |             | Low Price of token0                                          |               |
| close                | BigDecimal!                                                  |             | Close Price of token0                                        |               |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatehourdaydata) | ✅      | ✅    | ✅      | ✅    |
| [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap) |        | ✅    | ✅      | ✅*   |

\* -> Different across chains



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[TickHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickhourdata)

# TickHourData

Entities capturing details of Liquidity available & Volume of token traded at a tick for a given hour.

Not Used

The Schema is not currently populated in mainnet subgraph

## Schema

| Field           | Type                                                         | derivedFrom | Description                                                  |
| --------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id              | ID!                                                          |             | TickHourData Entity ID. Format: `<pool.address>-<Tick Index>-<Timestamp rounded to the hour by dividing by 3600>` |
| periodStartUnix | Int!                                                         |             | Timestamp rounded to the hour by dividing by 3600            |
| pool            | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) for which the hourly tick metrics were recorded |
| tick            | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)! |             | [Tick Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) for which hourly metrics were recorded |
| liquidityGross  | BigInt!                                                      |             | Total liquidity around the tick (1-tick range below or above) at end of the hour |
| liquidityNet    | BigInt!                                                      |             | Change in liquidity when the tick is crossed at end of the hour |
| volumeToken0    | BigDecimal!                                                  |             | Hourly volume of token0 with this tick in active range       |
| volumeToken1    | BigDecimal!                                                  |             | Hourly volume of token1 with this tick in active range       |
| volumeUSD       | BigDecimal!                                                  |             | Hourly swap value with this tick in active range in derived USD |
| feesUSD         | BigDecimal!                                                  |             | Hourly swap fee with this tick in active range in derived USD |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[TickDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickdaydata)

# TickDayData

Entities storing the details of Liquidity available & volume of token traded at a tick on a given day.

info

An entity is created only if there is a change during the day

## Schema

| Field                 | Type                                                         | derivedFrom | Description                                                  | Field Missing |
| --------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | ------------- |
| id                    | ID!                                                          |             | TickDayData Entity ID. Format: `<pool.address>-<Tick Index>-<Timestamp rounded to the day by dividing by 86400>` |               |
| date                  | Int!                                                         |             | Timestamp rounded to the day by dividing by 86400            |               |
| pool                  | [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool)! |             | [Pool Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) for which the daily tick metrics were recorded |               |
| tick                  | [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick)! |             | [Tick Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) for which daily metrics were recorded |               |
| liquidityGross        | BigInt!                                                      |             | Total liquidity around the tick (1-tick range below or above) at end of the day |               |
| liquidityNet          | BigInt!                                                      |             | Change in liquidity when the tick is crossed at end of the day |               |
| volumeToken0          | BigDecimal!                                                  |             | Daily volume of token0 with this tick in active range        |               |
| volumeToken1          | BigDecimal!                                                  |             | Daily volume of token1 with this tick in active range        |               |
| volumeUSD             | BigDecimal!                                                  |             | Daily swap value with this tick in active range in derived USD |               |
| feesUSD               | BigDecimal!                                                  |             | Daily swap fee with this tick in active range in derived USD |               |
| feeGrowthOutside0X128 | BigInt!                                                      |             | token0 fee accumulated marker outside the tick range at the end of the day | arbitrum-one  |
| feeGrowthOutside1X128 | BigInt!                                                      |             | token1 fee accumulated marker outside the tick range at the end of the day | arbitrum-one  |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updateTickDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetickdaydata) | ✅      |      | ✅      | ✅    |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokendaydata)

# TokenDayData

Entities capturing the daily stats for a token across all of Uniswap.

## Schema

| Field               | Type                                                         | derivedFrom | Description                                                  |
| ------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id                  | ID!                                                          |             | TokenDayData Entity ID. Format: `<token address>-<Timestamp rounded to the day by dividing by 86400>` |
| date                | Int!                                                         |             | Timestamp rounded to the day by dividing by 86400            |
| token               | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | [Token Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) for which the daily metric were recorded |
| volume              | BigDecimal!                                                  |             | Daily swap volume of the token                               |
| volumeUSD           | BigDecimal!                                                  |             | Daily swap volume of the token in derived USD                |
| untrackedVolumeUSD  | BigDecimal!                                                  |             | Daily swap volume of the token in derived USD (including in pools with tokens with unreliable USD value) |
| totalValueLocked    | BigDecimal!                                                  |             | Liquidity across all pools in token units at the end of the day |
| totalValueLockedUSD | BigDecimal!                                                  |             | Total value of liquidity across all pools in token units in derived USD at the end of the day |
| priceUSD            | BigDecimal!                                                  |             | Price of token in USD at the end of the day                  |
| feesUSD             | BigDecimal!                                                  |             | Total Fee Collected in derived USD at the end of the day     |
| open                | BigDecimal!                                                  |             | Open Price of the token                                      |
| high                | BigDecimal!                                                  |             | High Price of the token                                      |
| low                 | BigDecimal!                                                  |             | Low Price of the token                                       |
| close               | BigDecimal!                                                  |             | Close Price of the token                                     |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata) | ✅      | ✅    | ✅      | ✅    |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Entity Schemas](https://docs.uniswap.org/category/entity-schemas)[TokenHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenhourdata)

# TokenHourData

Entities capturing the hourly metrics for a token across all of Uniswap.

## Schema

| Field               | Type                                                         | derivedFrom | Description                                                  |
| ------------------- | ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| id                  | ID!                                                          |             | TokenHourData Entity ID. Format: `<token address>-<Timestamp rounded to the hour by dividing by 3600>` |
| periodStartUnix     | Int!                                                         |             | Timestamp rounded to the hour by dividing by 3600            |
| token               | [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token)! |             | [Token Entity](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) for which the hourly metric were recorded |
| volume              | BigDecimal!                                                  |             | Hourly swap volume of the token                              |
| volumeUSD           | BigDecimal!                                                  |             | Hourly swap volume of the token in derived USD               |
| untrackedVolumeUSD  | BigDecimal!                                                  |             | Hourly swap volume of the token in derived USD (including in pools with tokens with unreliable USD value) |
| totalValueLocked    | BigDecimal!                                                  |             | Liquidity across all pools in token units at the end of the hour |
| totalValueLockedUSD | BigDecimal!                                                  |             | Total value of liquidity across all pools in token units in derived USD at the end of the hour |
| priceUSD            | BigDecimal!                                                  |             | Price of token in USD at the end of the hour                 |
| feesUSD             | BigDecimal!                                                  |             | Total Fee Collected in derived USD at the end of the hour    |
| open                | BigDecimal!                                                  |             | Open Price of the token                                      |
| high                | BigDecimal!                                                  |             | High Price of the token                                      |
| low                 | BigDecimal!                                                  |             | Low Price of the token                                       |
| close               | BigDecimal!                                                  |             | Close Price of the token                                     |

## Referencing Functions

| FunctionName                                                 | Create | Read | Update | Save |
| ------------------------------------------------------------ | ------ | ---- | ------ | ---- |
| [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata) | ✅      | ✅    | ✅      | ✅    |



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Core Functions](https://docs.uniswap.org/category/core-functions)

# Core Functions

Implementation details of functions present in the /src/mappings folder

[📄️ core.tspath: /src/mappings/core.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts)

[📄️ factory.tspath: /src/mappings/factory.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts)

[📄️ position-manager.tsThe complete file is missing for arbitrum-one](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Core Functions](https://docs.uniswap.org/category/core-functions)[core.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts)

# core.ts

path: [`/src/mappings/core.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/core.ts)

### handleInitialize()

```text
Params:
 - event (initialize): entity of the initialize event emitted in a pool contract

ReturnType: void
```



- Eth Mainnet
- Polygon, Optimism
- Arbitrum-One

- Handles the initialization of a new pool by setting it's `price` and current `tick` value.
- Updates the pools daily and hourly metrics using `updatePoolDayData()` and `updatePoolHourData()`.
- Updates Eth's USD price using `getEthPriceInUSD()` .
- Updates the token's prices relative to Eth using `findEthPerToken()`.

#### Entities

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read & Write
2. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Write
3. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Write

#### Dependencies:

1. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
3. [getEthPriceInUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#getethpriceinusd)
4. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)

#### Invoked at:

1. [Initialize Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleMint()

```text
Params:
 - event (MintEvent): entity of the initialize event emitted in a pool contract

ReturnType: void
```



- updates `txCount`, `totalValueLockedETH` and `totalValueLockedUSD` metrics for `pool`, `factory` and `token` entities.
- Increases `pool.liquidity` by `event.params.amount` if the current `pool.tick` value is within the minted tick range.
- Creates a new `Mint` entity using `transaction.id` and `pool.txCount` as `mint.id`
- Creates tick entities `lowerTick` and `upperTick` if not already present using `createTick()` and updates their `liquidityGross` and `liquidityNet` fields.
- Updates the pool and token metrics using `updateUniswapDayData()`, `updatePoolDayData()`, `updatePoolHourData()`, `updateTokenDayData()`, `updateTokenHourData()`.
- Updates the fees accumulated outside the lower/upper ticks using `updateTickFeeVarsAndSave()`

#### Entities

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read
2. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read & Write
3. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read & Write
4. [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) - Read & Write
5. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Read/Create & Write
6. [Mint](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/mint) - Create & Write

#### Dependencies:

1. [FACTORY_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction)
4. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)
5. [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)
6. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
7. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
8. [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)
9. [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)
10. [updateTickFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave)
11. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)

#### Invoked at:

1. [Mint Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleBurn()

```text
Params:
 - event (BurnEvent): entity of the burn event emitted in a pool contract

ReturnType: void
```



- Other-Chains
- Optimism

- updates `txCount`, `totalValueLockedETH` and `totalValueLockedUSD` metrics for `pool`, `factory` and `token` entities.
- Decreases `pool.liquidity` by `event.params.amount` if the current `pool.tick` value is within the burnt tick range.
- Creates a new `Burn` entity using `transaction.id` and `pool.txCount` as `mint.id`. Sets the values from `event` parameters.
- Reduces the liquidity represented by `liquidityGross` and `liquidityNet` fields of the LowerTick and UpperTick.
- Updates the pool and token metrics using `updateUniswapDayData()`, `updatePoolDayData()`, `updatePoolHourData()`, `updateTokenDayData()`, `updateTokenHourData()`.
- Updates the fees accumulated outside the lower/upper ticks using `updateTickFeeVarsAndSave()`

#### Entities

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read
2. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read & Write
3. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read & Write
4. [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) - Read & Write
5. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Read & Write
6. [Burn](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/burn) - Create & Write

#### Dependencies:

1. [FACTORY_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction)
4. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)
5. [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)
6. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
7. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
8. [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)
9. [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)
10. [updateTickFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave)

#### Invoked at:

1. [Burn Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleSwap()

```text
Params:
 - event (SwapEvent): entity of the swap event emitted in a pool contract

ReturnType: void
```



Ignored Pool

The following pool address is ignored by the function: [0x9663f2ca0454accad3e094448ea6f77443880454](https://etherscan.io/address/9663f2ca0454accad3e094448ea6f77443880454) (WETH-LUSD)

- Eth Mainnet
- Polygon
- Arbitrum-One

- Calculates the tracked and untracked USD amount for the swap. `tracked` amount is the USD amount calculated only for tokens present in `WHITELIST_TOKEN` using `getTrackedAmountUSD`. `untracked` amount is calculated using `token.derivedETH * bundle.ethPriceUSD`.
- Calculates the fee in `ETH` & `USD` using the formula `amountTracked * (pool.feeTier/1,000,000)`.
- Updates the fields for `txCount`, volume & fees (in eth & usd) and `untrackedVolumeUSD` for `pool`, `factory` & `token` entities.
- For `pool` entity, sets `liquidity`, `tick`, `sqrtPrice` from the `event` parameters.
- Sets the `pool.token0Price` and `pool.token1Price` using `sqrtPriceX96ToTokenPrices()`.
- Updates the `bundle.ethPriceUSD` using `getEthPriceInUSD()`.
- Updates the `token.derivedETH` value using `findEthPerToken()`.
- Updates the `totalValueLockedETH` and `totalValueLockedUSD` for `pool`, `factory` and `token` entities after the USD price update.
- Creates a new `Swap` entity using `transaction.id` and `pool.txCount` as `swap.id`. Sets the values from `event` parameters.
- Sets `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` by reading the them from pool contract's blockchain state using the ABI.
- Triggers updates to the daily and hourly metrics for pool and tokens. Uses the returned instances to set the fields for volume & fee.
- If the updated `pool.tick` is initialized, updates it's fee variables using `loadTickUpdateFeeVarsAndSave()`.
- Iterates over all the ticks crossed with the swap (oldTick to newTick) and updates their fee fields using `loadTickUpdateFeeVarsAndSave()`. If the number of ticks cross is more than 100, the updates are ignored to prevent timeouts.

#### Entities

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read & Write
2. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read & Write
3. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read & Write
4. [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) - Read & Write
5. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Read/Create & Write
6. [Swap](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/swap) - Create & Write
7. [UniswapDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/uniswapdaydata) - Write
8. [PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pooldaydata) - Write
9. [PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolhourdata) - Write
10. [TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokendaydata) - Write
11. [TokenHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenhourdata) - Write

#### ABI Dependencies:

1. pool.json

#### Dependencies:

1. [FACTORY_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction)
4. [getTrackedAmountUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#gettrackedamountusd)
5. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)
6. [sqrtPriceX96ToTokenPrices()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#sqrtpricex96totokenprices)
7. [getEthPriceInUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#getethpriceinusd)
8. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)
9. [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)
10. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
11. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
12. [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)
13. [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)
14. [loadTickUpdateFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#loadtickupdatefeevarsandsave)
15. [feeTierToTickSpacing()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#feetiertotickspacing)
16. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
17. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
18. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)

#### Invoked at:

1. [Swap Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleFlash()

```text
Params:
 - event (FlashEvent): entity of the flash event emitted in a pool contract

ReturnType: void
```



- Eth Mainnet, Polygon
- Arbitrum-One

- Sets `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` by reading the them from pool contract's blockchain state using the ABI.

#### Entities

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read & Write

#### ABI Dependencies:

1. pool.json

#### Invoked at:

1. [Flash Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### updateTickFeeVarsAndSave()

```text
Params:
 - tick (Tick): Fee Variables are updated for this tick entity
 - event (Ethereum.event): An event from the pool the tick represent is in

ReturnType: void
```



- Eth Mainnet, Polygon
- Arbitrum-One

- Sets `tick.feeGrowthOutside0X128` and `tick.feeGrowthOutside1X128` by reading the tick from pool contract's blockchain state using the ABI.
- Triggers update to tick day metrics by invoking `updateTickDayData()`.

#### Entities

1. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Write

#### ABI Dependencies:

1. pool.json

#### Dependencies:

1. [updateTickDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetickdaydata)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
2. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
3. [loadTickUpdateFeeVarsAndSave](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#loadtickupdatefeevarsandsave)

### loadTickUpdateFeeVarsAndSave()

```text
Params:
 - tickId (i32): The fee variables are updated for this tickId
 - event (ethereum.event): An event from the pool contract which the tick is a part of.

ReturnType: void
```



- Loads the tick using `event.address` and `tickId`. If found, updates the tick variables by invoking `updateTickFeeVarsAndSave()`.

#### Entities

1. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Read & Write

#### Dependencies:

1. [updateTickFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave)

#### Invoked at:

1. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)





[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Core Functions](https://docs.uniswap.org/category/core-functions)[factory.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts)

# factory.ts

path: [`/src/mappings/factory.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/factory.ts)

### handlePoolCreated()

```text
Params:
 - event (PoolCreated): Event entity representing the Factory Contracts's Pool created event

ReturnType: void
```



- Eth Mainnet, Polygon
- Arbitrum-One
- Optimism

Ignored Pool

The following pool address is ignored by the function: [0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248](https://etherscan.io/address/0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248) (MULAN-USDT)

- Loads the factory entity at `FACTORY_ADDRESS`, or creates one if not found. Creates the bundle entity while creating factory. Initializes the new entity to `ZERO_BD`, `ZERO_BI`.
- Increment the factory's pool count.
- Creates new `Token` entity for each of the tokens in the pool if not already present. Initializes the token parameters using `fetchTokenSymbol()`, `fetchTokenName()`, `fetchTokenTotalSupply()`, `fetchTokenDecimals()` and metrics to `ZERO_BD` or `ZERO_BI`.
- If a token is present in the `WHITELIST_TOKENS` list, it is added to the other token's `whitelistPools` list, which is used for calculating the amount in USD.
- Creates a new `Pool` entity for the token pair. Uses the event parameters, and `token` entities to initialize the values, while sets the metrics to `ZERO_BI` or `ZERO_BD`.
- Finally, using `Pool`(Template), adds a new pool entity to listen for events from the new pool.

Token decimals mandatory

While creating either of the tokens, if the decimals value is not available, the pool entity is not created and the function returns without changing any entity. Only the bundle entity is still created if factory entity didn't exist.

#### Entities:

1. [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) - Read/Create & Write Entity
2. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Create Entity
3. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Create Entity
4. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read/Create & Write

#### Contracts

1. [Pool (Template)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) - Create

#### Dependencies:

1. [FACTORY_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factory_address)
2. [ADDRESS_ZERO](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#address_zero)
3. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
4. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
5. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)
6. [fetchTokenSymbol()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokensymbol)
7. [fetchTokenName()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokenname)
8. [fetchTokenTotalSupply()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokentotalsupply)
9. [fetchTokenDecimals()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokendecimals)
10. [WHITELIST_TOKENS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#whitelist_tokens)

#### Invoked at:

1. [PoolCreated Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)





[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Core Functions](https://docs.uniswap.org/category/core-functions)[position-manager.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts)

# position-manager.ts

File Missing

The complete file is missing for arbitrum-one

path: [`/src/mappings/position-manager.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/position-manager.ts)

### getPosition()

```text
Params:
 - event (ethereum.Event): An event from the NFT Position Manager contract
 - tokenId (BigInt): NFT Id for the staked position

ReturnType: Position | null
```



- Eth Mainnet
- Polygon, Optimism

- Returns a `Position` entity for the given `tokenId` if found.
- If not found, retrieves a position by directly querying the `NonfungiblePositionManager` contract using the ABI. Invokes `factoryContract.getPool()` and passing it the `position`'s parameters `token0`, `token1` and `fee` to find the `pool` contract address.
- Then creates a new position entity for the tokenId and set the metadata properties using `position` read earlier from the `NonfungiblePositionManager` contract. Sets the metrics to `ZERO_BD`.

No Position for same Block Mint and burn

In certain scenarios, the position is minted and burnt within the same block. The contract call to NonfungiblePositionManager to retrieve position data reverts in such scenarios as the position no longer exists.

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Read/Create Without Saving

#### ABI Dependencies:

1. NonfungiblePositionManager.json

#### Dependencies:

1. [factoryContract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factorycontract)
2. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
3. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
4. [ADDRESS_ZERO](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#address_zero)
5. [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction)

#### Invoked at:

1. [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaaseliquidity)
3. [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect)
4. [handleTransfer()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handletransfer)

### updateFeeVars()

```text
Params:
 - position (Position): The position for which the fee variables are set
 - event (ethereum.Event): An event from the NFT Position Manager contract
 - tokenId (BigInt): NFT Id for the staked position

ReturnType: Position
```



- Updates the fields `position.feeGrowthInside0LastX128` and `position.feeGrowthInside1LastX128` for the position represented by `tokenId` by reading the value from the `NonfungiblePositionManager` triggering the `event`.

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Update Fields Without Saving

#### ABI Dependencies:

1. NonfungiblePositionManager.json

#### Invoked at:

1. [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaaseliquidity)
3. [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect)

### savePositionSnapshot()

```text
Params:
 - position (Position): Position entity for which the current state is saved as a snapshot
 - event (ethereum.Event): NonfungiblePositionManager Contract event after which the snapshot is being saved

ReturnType: void
```



- Saves the current values of a `Position` entity for future reference, including liquidity, tokens deposited and withdrawn, fee collected, feeGrowthInside.

#### Entities

1. [PositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/positionsnapshot) - Create

#### Dependencies:

1. [loadTransaction()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#loadtransaction)

#### Invoked at:

1. [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaaseliquidity)
3. [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect)
4. [handleTransfer()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handletransfer)

### handleIncreaseLiquidity()

```text
Params:
 - event (IncreaseLiquidity): Entity for a IncreaseLiquidity event emitted by NonfungiblePositionManager Contract

ReturnType: void
```



- Eth Mainnet
- Polygon
- Optimism

Ignored Blocks and Addresses

- Block 14317993 is ignored by the function.
- Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.liquidity`, `position.depositedToken0` and `position.depositedToken1`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Write
2. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read

#### Dependencies:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#updatefeevars)
4. [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)

#### Invoked at:

1. [IncreaseLiquidity Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleDecreaseLiquidity()

```text
Params:
 - event (DecreaseLiquidity): Entity for a DecreaseLiquidity event emitted by NonfungiblePositionManager Contract

ReturnType: void
```



- Eth Mainnet
- Polygon
- Optimism

Ignored Blocks and Addresses

- Block 14317993 is ignored by the function.
- Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.liquidity`, `position.withdrawnToken0` and `position.withdrawnToken1`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Write
2. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read

#### Dependencies:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#updatefeevars)
4. [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)

#### Invoked at:

1. [DecreaseLiquidity Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleCollect()

```text
Params:
 - event (Collect): Entity for a Collect event emitted by NonfungiblePositionManager Contract

ReturnType: void
```



Ignored Addresses

- Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.

- Eth Mainnet
- Polygon
- Optimism

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.collectedFeesToken0` and `position.collectedFeesToken1` by adding the `event.params.amount0` after adjusting it with `token.decimals`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

Incorrect Collected Fees Token1 amount

`event.params.amount0` (adjusted with `token0.decimals`) is added to both `position.collectedFeesToken0` and `position.collectedFeesToken1`. This logic needs to be validated.

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Write
2. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read

#### Dependencies:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
2. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#updatefeevars)
4. [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)

#### Invoked at:

1. [Collect Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)

### handleTransfer()

```text
Params:
 - event (Transfer): Entity for a Transfer event emitted by NonfungiblePositionManager Contract

ReturnType: void
```



- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Sets `position.owner` with `event.params.to`.
- Triggers `savePositionSnapshot()`.

#### Entities

1. [Position](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/position) - Write

#### Dependencies:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
2. [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)

#### Invoked at:

1. [Transfer Event (Handler)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/events)



# Utility Functions

Docs for /src/utils functions

[📄️ constants.tspath: /src/utils/constants.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts)

[📄️ index.tspath: /src/utils/index.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts)

[📄️ intervalUpdates.tspath: /src/utils/intervalUpdates.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts)

[📄️ pricing.tspath: /src/utils/pricing.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts)

[📄️ staticTokenDefinition.tspath: /src/utils/staticTokenDefinition.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts)

[📄️ tick.tspath: /src/utils/tick.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts)

[📄️ token.tspath: /src/utils/token.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts)

[📄️ backfill.tsThe file is present only for the optimism subgraph](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[constants.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts)

# constants.ts

path: [`/src/utils/constants.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/constants.ts)

### ADDRESS_ZERO

```text
- type: String
- value: '0x0000000000000000000000000000000000000000'
```



Represents the null address in ethereum.

#### Referenced at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)
2. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)

### FACTORY_ADDRESS

```text
- type: String
- value: '0x1F98431c8aD98523631AE4a59f267346ea31F984'
```



#### Referenced at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)
2. [factoryContract](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factorycontract)
3. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
4. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
5. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)
6. [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)

### ZERO_BI

```text
- type: BigInt
- value: 0
```



- Other-Chains
- Optimism

#### Referenced at:

1. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
3. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)
4. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)
5. [exponentToBigDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)
6. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
7. [tokenAmountToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#tokenamounttodecimal)
8. [priceToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#pricetodecimal)
9. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
10. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)
11. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
12. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### ONE_BI

```text
- type: BigInt
- value: 1
```



#### Referenced at:

1. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
3. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)
4. [exponentToBigDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)
5. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
6. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
7. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
8. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### TWO_BI

- Arbitrum-One
- Other-Chains

```text
- type: BigInt
- value: 2
```



#### Referenced at:

1. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)

### ZERO_BD

```text
- type: BigDecimal
- value: 0
```



- Other-Chains
- Optimism

#### Referenced at:

1. [updatePoolDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)
3. [updateTokenDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)
4. [updateTokenHourData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)
5. [updateUniswapDayData()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)
6. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)
7. [getTrackedAmountUSD()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#gettrackedamountusd)
8. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)
9. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)
10. [equalToZero()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#equaltozero)
11. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)
12. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
13. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### ONE_BD

```text
- type: BigDecimal
- value: 1
```



#### Referenced at:

1. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)
2. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
3. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)

### BI_18

```text
- type: BigInt
- value: 18
```



### factoryContract

An object representing a smart contract based on `abis/factory.json` abi, binded to `FACTORY_ADDRESS` to query the smart contract data.

#### Dependencies:

1. [FACTORY_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#factory_address)

#### Referenced at:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[index.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts)

# index.ts

path: [`/src/utils/index.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/index.ts)

### exponentToBigDecimal()

```text
Params:
 - decimals (BigInt): The power of ten to return.

ReturnType: BigDecimal
```



Returns the number `1` followed by `decimals` number of `0s` with type BigDecimal.
It uses a for loop to iterate between `0` and `decimals` and multiplies the previous result by `10`. Thus, only positive values are possible.

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)

#### Invoked at:

1. [tokenAmountToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#tokenamounttodecimal)
2. [priceToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#pricetodecimal)
3. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)
4. [convertEthToDecimal](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#convertethtodecimal)
5. [sqrtPriceX96ToTokenPrices](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#sqrtpricex96totokenprices)

### safeDiv()

```text
Params:
 - amount0 (BigDecimal): Numerator for the division
 - amount1 (BigDecimal): Denominator for the division

ReturnType: BigDecimal
```



Return `0` if parameter `amount1` is equal to `ZERO_BD`.
Else returns the result of dividing `amount0` by `amount1` using `BigDecimal`'s `div()` method.

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
2. [priceToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#pricetodecimal)
3. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)

### bigDecimalExponated()

```text
Params:
 - value (BigDecimal): value to be raised to a certain power
 - power (BigInt): the exponent of the value to be calculated

ReturnType: BigDecimal
```



- Other-Chains
- Arbitrum-One

If `power` is `ZERO_BI`, `ONE_BD` is returned. `value` is multipled by itself in a simple for loop executed `abs(power)` number of times. If the `power` is negative, uses `safeDiv` to divide `ONE_BD` with the result of the previous calculation. Returns the result in BigDecimal.

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
3. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)
4. [ONE_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bd)
5. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)

#### Invoked at:

1. [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick)

### tokenAmountToDecimal()

```text
Params:
 - tokenAmount (BigDecimal): The amount of tokens to be divided (numerator)
 - exchangeDecimals (BigInt): The power of 10 to divide the amount with

ReturnType: BigDecimal
```



If exchangeDecimals is `ZERO_BI`, returns tokenAmount after converting to BigDecimal. Else divides the BigDecimal tokenAmount using 10 raised to `exchangeDecimals` as the denominator.

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [exponentToBigDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)

#### Invoked at:

1. []

### priceToDecimal()

```text
Params:
 - amount (BigDecimal): The amount to be divided (numerator)
 - exchangeDecimals (BigInt): The power of 10 to divide the amount with

ReturnType: BigDecimal
```



If `exchangeDecimals` is equal to `ZERO_BI` returns the amount as it is. Otherwise uses `safeDiv` to divide `amount` with `10^exchangeDecimals` in BigDecimals type.

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)
3. [exponentToBigDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)

#### Invoked at:

1. 

### equalToZero()

```text
Params:
 - value (BigDecimal): Value to check whether zero

ReturnType: boolean
```



Converts value to string and then to float. Compares it against ZERO_BD after converting to String and then parsing as float. Returns boolean value from comparing the equality of the two float values.

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. 

### isNullEthValue()

```text
Params:
 - value (String) - Hex String to check for Null Eth value

ReturnType: boolean
```



Returns boolean value. True is value == '0x0000000000000000000000000000000000000000000000000000000000000001', else false.

#### Invoked at:

1. [fetchTokenSymbol()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokensymbol)
2. [fetchTokenName()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokenname)

### bigDecimalExp18()

```text
ReturnType: BigDecimal
Value: 10^18
```



#### Invoked at:

1. 

### convertTokenToDecimal()

```text
Params:
 - tokenAmount (BigInt) - The amount of token value to be converted
 - exchangeDecimals (BigInt) - The positive power of the exponent to divide the tokenAmount with

ReturnType: BigDecimal
```



- Other-Chains
- Optimism

If exchangeDecimals is `ZERO_BI`, returns tokenAmount after converting to BigDecimal. Else divides the BigDecimal tokenAmount using 10 raised to `exchangeDecimals` as the denominator.

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [exponentToBigDecimal](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
2. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
3. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)
4. [handleIncreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)
5. [handleDecreaseLiquidity()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)
6. [handleCollect()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#handlecollect)

### convertEthToDecimal()

```text
Params:
 - eth (BigInt) - Int value representing ether amount in wei

ReturnType: BigDecimal
```



Converts the value of ether in wei from integer to big decimal representing amount in ether. It converts the eth parameter to BigDecimal and then divides it with 10^18 BigDecimal value.

#### Dependencies:

1. [exponentToBigDecimal](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)

#### Invoked at:

1. 

### loadTransaction()

```text
Params:
 - event (ethereum.Event) - Ethereum event emitted from the transaction to return.

ReturnType: Transaction
```



Returns a [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) instance for the specified event. If a transaction instance doesn't already exit for the event, it's created and then returned. Uses `event.transaction.hash.toHexString()` to find the relevant transaction or to create a new transaction instance. Uses `event` parameters `block.blockNumber`, `block.timestamp`, `transaction.gasUsed` and `transaction.gasPrice` to populate `transaction`'s fields.

#### Entites:

1. [Transaction](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/transaction) - Read/Create & Write

#### Invoked at:

1. [getPosition()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#getposition)
2. [savePositionSnapshot()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)
3. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
4. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
5. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[intervalUpdates.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts)

# intervalUpdates.ts

path: [`/src/utils/intervalUpdates.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/intervalUpdates.ts)

### updateUniswapDayData()

```text
Params:
 - event (ethereum.Event): The event used to determine dayId

ReturnType: UniswapDayData
```



Updates the `tvlUSD` and `txCount` parameters for `UniswapDayData` entity for a given day. Sets the variables to `factory` entity's `totalValueLockedUSD` and `txCount` values respectively.

Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID` for `UniswapDayData`. If a `UniswapDayData` entity for the given day doesn't exist already, it is first created, with rest of the metrics initialized to `ZERO_BD`.

#### Entities:

1. [Factory](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/factory) - Read
2. [UniswapDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/uniswapDayData) - Read/Create & Write

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
2. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
3. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### updatePoolDayData()

```text
Params:
 - event (ethereum.Event): The event used to determine pool address and dayId to get the PoolId

ReturnType: PoolDayData
```



- Other-Chains
- Arbitrum-One

Using `event.block.timestamp.toI32()/86400` and `event.address.toHexString()` to get the `dayID` and `poolID` respectively. Together also give the `poolDayDataID`.

Creates a new `PoolDayData` entity for the day if not found. The new entity's metrics are initialized to `ZERO_BD` or `ZERO_BI`, while the `open`, `high`, `low` and `close` values are set to `pool.token0price`.

Updates the `PoolDayData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Updates the rest of the metrics using values from `Pool` entity.

Note: Currently updates `poolDayData.close` only when a new entity is created.

#### Entities:

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read
2. [PoolDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolDayData) - Read/Create & Write

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
2. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)

#### Invoked at:

1. [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize)
2. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
3. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
4. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### updatePoolHourData()

```text
Params:
 - event (ethereum.Event): The event used to determine pool address and hourId to get the HourPoolId

ReturnType: PoolHourData
```



- Other-Chains
- Arbitrum-One

Using `event.block.timestamp.toI32()/3600` and `event.address.toHexString()` to get the `hourIndex` and `poolID` respectively. Together also give the `hourPoolID`.

Creates a new `PoolHourData` entity for the specific hour if not found. The new entity's metrics are initialized to `ZERO_BD` or `ZERO_BI`, while the `open`, `high`, `low` and `close` values are set to `pool.token0price`.

Updates the `PoolHourData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Updates the rest of the metrics using values from `Pool` entity.

#### Entities:

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read
2. [PoolHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/poolHourData) - Read/Create & Write

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
2. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
3. [ONE_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bi)

#### Invoked at:

1. [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize)
2. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
3. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
4. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### updateTokenDayData()

```text
Params:
 - token (Token): token to update the daily metrics for
 - event (ethereum.Event): The event used to determine the dayID

ReturnType: TokenDayData
```



Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID`. Uses `dayId` and `token.id.toString()` to get the `tokenDayID`.

Uses `token`'s value in terms of eth and multiplies it with eth's price in USD using `bundle.ethPriceUSD` to get `tokenPrice`.

Creates a new `TokenDayData` entity if one for `tokenDayID` is not found. Initializes the metrics to `ZERO_BD`, while the `open`, `high`, `low` and `close` are set to `tokenPrice`.

Updates the `TokenDayData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Upadates the rest of the metrics using valus from `Token` entity.

#### Entities:

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read
2. [TokenDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenDayData) - Read/Create & Write

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
2. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
3. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### updateTokenHourData()

```text
Params:
 - token (Token): token to update hourly metrics for
 - event (ethereum.Event): The event used to determine the hourIndex

ReturnType: TokenHourData
```



Using `event.block.timestamp.toI32()/3600` to get the `hourIndex`. Uses `hourIndex` and `token.id.toString()` to get the `tokenHourID`.

Uses `token`'s value in terms of eth and multiplies it with eth's price in USD using `bundle.ethPriceUSD` to get `tokenPrice`.

Creates a new `TokenHourData` entity for the specific hour if not found. The new entity's metrics are initialized to `ZERO_BD`, while the `open`, `high`, `low` and `close` values are set to `tokenPrice`.

Updates the `TokenHourData` values `high` or `low` conditionally by comparing `tokenPrice` with the existing values.

Updates the rest of the metrics using values from `token` entity.

#### Entities:

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read
2. [TokenHourData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tokenHourData) - Read/Create & Write

#### Dependencies:

1. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)
2. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)
3. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### updateTickDayData()

```text
Params:
 - tick (Tick): Tick to update daily metrics for
 - event (ethereum.Event): The event used to determine the dayId

ReturnType: TickDayData
```



- Other-Chains
- Arbitrum-One

Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID`. Uses `dayId` and `tick.id` to get the `tickDayDataID`.

Creates a new `TickDayData` entity for the specific day if not found. Initializes the fields `pool` and `tick` using `tick.pool` and `tick.id` respectively.

Sets the `TickDayData` entity's field values using corresponding fields from `tick`.

#### Entities:

1. [TickDayData](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tickDayData) - Read/Create & Write

#### Invoked at:

1. [updateTickFeeVarsAndSave()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[pricing.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts)

# pricing.ts

path: [`/src/utils/pricing.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/pricing.ts)

### WETH_ADDRESS

- Eth Mainnet
- Polygon
- Arbitrum-one
- Optimism

```text
- type: string
- value: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
```



Address of wrapped-ETH (WETH) contract on ethereum mainnet.

#### Referenced at:

1. [WHITELIST_TOKENS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#whitelist_tokens)
2. [findEthPerToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)

### USDC_WETH_03_POOL

- Eth-Mainnet
- Polygon
- Arbitrum-one
- Optimism

```text
- type: string
- value: '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
```



Address of Uniswap V3 pool contract between `USDC` and `WETH` `ERC-20` tokens on the specific chain.

#### Referenced at:

1. [getEthPriceInUSD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#getethpriceinusd)

### DAI_WETH_03_POOL

- Optimism
- Other-Chains

```text
- type: string
- value: '0x03af20bdaaffb4cc0a521796a223f7d85e2aac31'
```



Address of Uniswap V3 pool contract between `DAI` and `WETH` `ERC-20` tokens on optimsim mainnet.

#### Referenced at:

1. [getEthPriceInUSD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#getethpriceinusd)

### WHITELIST_TOKENS

A list of tokens which have considerable usage and are likely to have pool pairing with other tokens. These can be used for calculating liquidity in USD by using the tokens price in USD.

The following token addresses are present in the list:

- Eth-Mainnet
- Polygon
- Arbitrum-one
- Optimism

| Symbol | Address                                                      |
| ------ | ------------------------------------------------------------ |
| WETH   | `WETH_ADDRESS`*                                              |
| DAI    | [0x6b175474e89094c44da98b954eedeac495271d0f](https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f) |
| USDC   | [0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48](https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48) |
| USDT   | [0xdac17f958d2ee523a2206206994597c13d831ec7](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7) |
| TUSD   | [0x0000000000085d4780b73119b644ae5ecd22b376](https://etherscan.io/address/0x0000000000085d4780b73119b644ae5ecd22b376) |
| WBTC   | [0x2260fac5e5542a773aa44fbcfedf7c193bc2c599](https://etherscan.io/address/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599) |
| cDAI   | [0x5d3a536e4d6dbd6114cc1ead35777bab948e3643](https://etherscan.io/address/0x5d3a536e4d6dbd6114cc1ead35777bab948e3643) |
| cUSDC  | [0x39aa39c021dfbae8fac545936693ac917d5e7563](https://etherscan.io/address/0x39aa39c021dfbae8fac545936693ac917d5e7563) |
| EBASE  | [0x86fadb80d8d2cff3c3680819e4da99c10232ba0f](https://etherscan.io/address/0x86fadb80d8d2cff3c3680819e4da99c10232ba0f) |
| sUSD   | [0x57ab1ec28d129707052df4df418d58a2d46d5f51](https://etherscan.io/address/0x57ab1ec28d129707052df4df418d58a2d46d5f51) |
| MKR    | [0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2) |
| COMP   | [0xc00e94cb662c3520282e6f5717214004a7f26888](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888) |
| LINK   | [0x514910771af9ca656af840dff83e8264ecf986ca](https://etherscan.io/address/0x514910771af9ca656af840dff83e8264ecf986ca) |
| SNX    | [0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f](https://etherscan.io/address/0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f) |
| YFI    | [0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e](https://etherscan.io/address/0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e) |
| 1INCH  | [0x111111111117dc0aa78b770fa6a738034120c302](https://etherscan.io/address/0x111111111117dc0aa78b770fa6a738034120c302) |
| yCurv  | [0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8](https://etherscan.io/address/0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8) |
| FEI    | [0x956f47f50a910163d8bf957cf5846d573e7f87ca](https://etherscan.io/address/0x956f47f50a910163d8bf957cf5846d573e7f87ca) |
| MATIC  | [0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0](https://etherscan.io/address/0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0) |
| AAVE   | [0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9) |
| sETH2  | [0xfe2e637202056d30016725477c5da089ab0a043a](https://etherscan.io/address/0xfe2e637202056d30016725477c5da089ab0a043a) |

#### Dependencies:

1. [WETH_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#weth_address)

#### Referenced at:

1. [getTrackedAmountUSD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#gettrackedamountusd)
2. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

\* -> The value is imported from a variable and listed directly in the list declaration.

### STABLE_COINS

A list of ERC20 token contract addresses which have stable coin prices, i.e., 1 token expected to be valued at 1 USD.

- Eth-Mainnet
- Polygon
- Arbitrum-One
- Optimism

|        | Address                                                      |
| ------ | ------------------------------------------------------------ |
| DAI    | [0x6b175474e89094c44da98b954eedeac495271d0f](https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f) |
| USDC   | [0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48](https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48) |
| USDT   | [0xdac17f958d2ee523a2206206994597c13d831ec7](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7) |
| TUSD   | [0x0000000000085d4780b73119b644ae5ecd22b376](https://etherscan.io/address/0x0000000000085d4780b73119b644ae5ecd22b376) |
| FEI    | [0x956f47f50a910163d8bf957cf5846d573e7f87ca](https://etherscan.io/address/0x956f47f50a910163d8bf957cf5846d573e7f87ca) |
| PRINTS | [0x4dd28568d05f09b02220b09c2cb307bfd837cb95](https://etherscan.io/address/0x4dd28568d05f09b02220b09c2cb307bfd837cb95) |

#### Referenced at:

1. [findEthPertoken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)

### MINIMUM_ETH_LOCKED

- Eth-Mainnet
- Polygon
- Arbitrum-one
- Optimism

```text
 - type: BigDecimal
 - value: 60
```



While calculating token price in USD, the value of other token locked in the pool in terms of eth has to be greated than `MINIMUM_ETH_LOCKED`.

#### Referenced at:

1. [findEthPertoken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#findethpertoken)

### sqrtPriceX96ToTokenPrices()

```text
Params:
 - sqrtPriceX96 (BigInt): The square root of the price of token1 in terms of token0 in Q64.96 format. Formula: sqrt(token0.price/token1.price)*(2^96)
 - token0 (Token): The first token in the pool pair to calculate the relative price for
 - token1 (Token): The second token in the pool pair to calculate the relative price for

ReturnType: BigDecimal[]
```



Find the price of `token0` and `token1` in the pool relative to each other and returns the two prices.

#### Formula:

```text
    num = (sqrtPriceX96^2) # Squaring the root to get the price
    denom = 2^192 # To divide price by 96^2 to convert the Q64.96 number to BigDecimal
    price1 = ((num/denom) * (10^token0.decimals))/ (10^token1.decimals) # Calculating price1
    price0 = 1/price1
```



#### Dependencies:

1. [exponentToBigDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#exponenttobigdecimal)
2. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)

#### Invoked at:

1. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

### getEthPriceInUSD()

```text
Params: none

ReturnType: BigDecimal
```



- Other-Chains
- Arbitrum-One
- Optimism

Returns the Price of ETH in terms of USD, based on the stable coin pools. Currently, the `token0Price` for the `pool` represented by `USDC_WETH_03_POOL`. When `pool` entity is not found, returns `ZERO_BD`.

#### Entites:

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read Entity

#### Dependencies:

1. [USDC_WETH_03_POOL](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#usdc_weth_03_pool)
2. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize)
2. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleSwap)

### findEthPerToken()

```text
Params:
 - token (Token): Token entity to find the price in terms of ETH

ReturnType: BigDecimal
```



- Eth Mainnet, Polygon
- Arbitrum-One

If token is weth, returns 1. If token in `STABLE_COINS`, returns `1/bundle.ethPriceUSD`.

Else, iterates over all the whitelisted pools for the token using `token.whitelistPools`. Finds the pool with largest liquidity value in terms of ETH, as long as the value is atleast `MINIMUM_ETH_LOCKED`. Uses the eth value of the paired token and relative token price between the token pair to find the `token`'s' value in terms of eth. If there's no whitelisted pool with `MINIMUM_ETH_LOCKED`, returns `ZERO_BD`.

#### Entites:

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read Entity
2. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Read Entity
3. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read Entity

#### Dependencies:

1. [WETH_ADDRESS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#weth_address)
2. [ONE_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bd)
3. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
4. [STABLE_COINS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#stable_coins)
5. [MINIMUM_ETH_LOCKED](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#minimum_eth_locked)

#### Invoked at:

1. [handleInitialize()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleinitialize)
2. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleSwap)

### getTrackedAmountUSD()

```text
Params:
 - tokenAmount0 (BigDecimal):
 - token0 (Token0):
 - tokenAmount1 (BigDecimal):
 - token1 (Token):

ReturnType: BigDecimal
```



Returns the USD value equivalent to `tokenAmoun0` and `tokenAmount1` together. Calculates the USD price using `token.derviedEth*bundle.ethPriceUSD` as the multiplier if the token is present in `WHITELIST_TOKENS`. If both the tokens are present, it adds their individual USD prices. If only one is present, it uses 2X the value of that token. If neither are in the `WHITELIST_TOKENS` list, returns `ZERO_BD`.

#### Entites:

1. [Bundle](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/bundle) - Read Entity

#### Dependencies:

1. [WHITELIST_TOKENS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#whitelist_tokens)
2. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)

#### Invoked at:

1. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleSwap)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[staticTokenDefinition.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts)

# staticTokenDefinition.ts

path: [`/src/utils/staticTokenDefinition.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/staticTokenDefinition.ts)

## Class StaticTokenDefinition

A utility class to represent an `ERC20` token metadata. Contains four fields:

| Field    | Type    |
| -------- | ------- |
| address  | Address |
| symbol   | string  |
| name     | string  |
| decimals | BigInt  |

It has a constructor to initialized an object:

```text
constructor(address: Address, symbol: string, name: string, decimals: BigInt)
```



The class exposes two static functions:

1. [getStaticDefinitions()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#getstaticdefinitions)
2. [fromAddress()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#fromaddress)

### getStaticDefinitions()

Returns an `Array<StaticTokenDefinition>` object with the token definitions defined with the function:

- Other-Chains
- Arbitrum-One
- Optimism

| Address                                    | Symbol | Name       | Decimals |
| ------------------------------------------ | ------ | ---------- | -------- |
| 0xe0b7927c4af23765cb51314a0e0521a9645f0e2a | DGD    | DGD        | 9        |
| 0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9 | AAVE   | Aave Token | 18       |
| 0xeb9951021698b42e4399f9cbb6267aa35f82d59d | LIF    | Lif        | 18       |
| 0xbdeb4b83251fb146687fa19d1c660f99411eefe3 | SVD    | savedroid  | 18       |
| 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 | TheDAO | TheDAO     | 16       |
| 0x38c6a68304cdefb9bec48bbfaaba5c5b47818bb2 | HPB    | HPBCoin    | 18       |

#### Invoked at:

1. [fromAddress()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#fromaddress)

### fromAddress()

```text
Params:
 - tokenAddress (Address): the ERC20 address to search for in the ERC20 symbols defined in StaticTokenDefinition class

ReturnType: StaticTokenDefinition | null
```



Get an Array of `StaticTokenDefinition` objects from static method getStaticDefinition() and iterates through them to find the `tokenAddress`, If found returns the `StaticTokenDefinition` object, else returns `null`.

#### Dependencies:

1. [getStaticDefinitions()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#getstaticdefinitions)

#### Invoked at:

1. [fetchTokenSymbol()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokensymbol)
2. [fetchTokenName()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokenname)
3. [fetchTokenDecimals()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokendecimals)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[tick.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts)

# tick.ts

path: [`/src/utils/tick.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/tick.ts)

### createTick()

```text
Params:
 - tickId (String): ID of the tick instance to create. Format: <pool address>#<tick index>
 - tickIdx (i32): Tick index
 - poolId (string): PoolId
 - event (MintEvent): The mint event where liquidity was added to the tick

ReturnType: Tick
```



- Other-Chains
- Arbitrum-One

Initializes a new Tick to store the liquidity present at the specific tick.

Sets `tick.id`, `tick.tickIdx`, `tick.pool` and `tick.poolId` from the parametrs. Sets `tick.creatdAtTimeStamp` and `tick.createdAtBlockNumber` from `event.block.timestamp` and `event.block.number` respectively.

`tick.price0` is calcualted as `1.0001^tickIdx` and `tick.price1` as `safeDiv(ONE_BD, price0)`.

All the other parameters are initialized to `ZERO_BD` or `ZERO_BI`.

#### Entites:

1. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Create

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [ONE_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bd)
3. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
4. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
5. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)

#### Invoked at:

1. [handleMint()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handlemint)

### createTickBurn()

Only in Optimism

This function exists only in optimism subgraph

```text
Params:
 - tickId (String): ID of the tick instance to initialize. Format: <pool address>#<tick index>
 - tickIdx (i32): Tick index
 - poolId (string): PoolId
 - event (MintEvent): The event where the liquidity from the tick is removed

ReturnType: Tick
```



Instantiate a tick that already exists from previous transactions.

- Uses the same logic as [createTick()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts#createtick) to initialize a new tick entity
- Later reads the Pool contract ticks data for `tickIdx` and sets the `tick.liquidityGross`, `tick.liquidityNet`, `tick.feeGrowthOutside0X128` and `tick.feeGrowthOutside1X128` vlaues.

#### Entites:

1. [Tick](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/tick) - Create * Write

#### ABI Dependencies:

1. pool.json

#### Dependencies:

1. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
2. [ONE_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#one_bd)
3. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
4. [bigDecimalExponated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#bigdecimalexponated)
5. [safeDiv()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#safediv)

#### Invoked at:

1. [handleBurn()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleburn)

### feeTierToTickSpacing()

```text
Params:
 - feeTier (BigInt): The fee tier specified for the pool

ReturnType: BigInt
```



- Other-Chains
- Arbitrum-One

Given a specific fee tier, returns a BigInt value for the respective tick spacing used in the pool contract.

| Fee Tier      | TickSpaceing Returned        |
| ------------- | ---------------------------- |
| 10000         | 200                          |
| 3000          | 60                           |
| 500           | 10                           |
| 100           | 1                            |
| Anything Else | Error: 'Unexpected fee tier' |

#### Invoked at:

1. [handleSwap()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts#handleswap)

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[token.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts)

# token.ts

path: [`/src/utils/token.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/token.ts)

### fetchTokenSymbol()

```text
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the symbol is returned

ReturnType: string
```



- Other-Chains
- Arbitrum-One
- Optimism

Returns the string value representing the ERC20 symbol read from the contract with address `tokenAddress` using `symbol()` method. If reverted, checks if the `tokenAddres` is present in `StaticTokenDefinition`. Returns `unknown` if not found.

#### ABI Dependencies:

1. ERC20.json
2. ERC20SymbolBytes.json

#### Dependencies:

1. [isNullEthValue()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#isnullethvalue)
2. [StaticTokenDefintion](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#statictokendefinition)
3. [StaticTokenDefintion.fromAddress()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#fromaddress)

#### Invoked at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

### fetchTokenName()

```text
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the Name is returned

ReturnType: string
```



- Other-Chains
- Arbitrum-One
- Optimism

Returns the string value representing the ERC20 name read from the contract with address `tokenAddress` using `name()` method. If reverted, checks if the `tokenAddres` is present in `StaticTokenDefinition`. Returns `unknown` if not found.

#### ABI Dependencies:

1. ERC20.json
2. ERC20NameBytes.json

#### Dependencies:

1. [isNullEthValue()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#isnullethvalue)
2. [StaticTokenDefintion](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#statictokendefinition)
3. [StaticTokenDefintion.fromAddress()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#fromaddress)

#### Invoked at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

### fetchTokenTotalSupply()

```text
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the Total Supply is 

ReturnType: BigInt
```



- Other-Chains
- Optimism

Queries the ERC20 contract with address `tokenAddress` and returns total token supply using `totalSupply()` method. If call reverts, typecasts `null` to i32 then to BigDecimal and returns the value.

#### ABI Dependencies:

1. ERC20.json

#### Invoked at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

### fetchTokenDecimals()

```text
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the number of decimals is returned

ReturnType: BigInt
```



- Other-Chains
- Arbitrum-One
- Optimism

Queries the ERC20 contract with address `tokenAddress` and returns the decimals value for the token `decimals()` method. If call reverts, check for `tokenAddress` in `StaticTokenDefinition`. If not found, typecasts `null` to i32 then to BigDecimal and returns the value.

#### ABI Dependencies:

1. ERC20.json

#### Dependencies:

1. [StaticTokenDefintion](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#statictokendefinition)
2. [StaticTokenDefintion.fromAddress()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts#fromaddress)

#### Invoked at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Utility Functions](https://docs.uniswap.org/category/utility-functions)[backfill.ts](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts)

# backfill.ts

Only in Optimism

The file is present only for the optimism subgraph

path: [`/src/utils/backfill.ts`](https://github.com/Uniswap/v3-subgraph/blob/ian/optimism-fix/src/utils/backfill.ts)

### populateToken()

```text
Params:
 - tokenAddress (String): 

ReturnType: void
```



- Initializes a new Token Enttity for the token address if not already present.
- Initializes the token parameters using `fetchTokenSymbol()`, `fetchTokenName()`, `fetchTokenTotalSupply()`, `fetchTokenDecimals()` and metrics to `ZERO_BD` or `ZERO_BI`.

#### Entities:

1. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read/Create & Write

#### Dependencies:

1. [fetchTokenSymbol()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokensymbol)
2. [fetchTokenName()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokenname)
3. [fetchTokenTotalSupply()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokentotalsupply)
4. [fetchTokenDecimals()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts#fetchtokendecimals)
5. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
6. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)

#### Invoked at:

1. [populateEmptyPools()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populateemptypools)

### populateEmptyPools()

```text
Params:
 - event (ethereum.Event): 

ReturnType: void
```



Create entities for each pool and token before regenesis of optimism chain.

- Iterates through the pools present in `POOL_MAPPINGS` list. Fow each of the items, does the below mentioned steps.
- Using PoolABI, loads the pool contract. Creates a new `Pool` entity and sets it's `token0`, `token1` values from POOL_MAPPING and liquidity from the contract read. Iniitalizes all the metrics to `ZERO_BD` or `ZERO_BI`.
- set `pool.feeTier` by reading it from the contract.
- Invokes `populateToken()` for the two tokens.
- For each token, adds pool to `token.whitelistPool` if the other token is present in `WHITELIST_TOKENS` list.
- Sets `pool.totalValueLockedToken` and `token.totalValueLocked` by reading the ERC20 contract and invoking `balanceOf()`.
- Saves the token and pool entities.

Overwrites Token TVL

`token.tokenValueLocked` is set everytime instead of adding it to the existing balance. Thus if a token is present in multiple pools, the TVL in the from the last pool will be shown.

#### Entities:

1. [Pool](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/pool) - Create & Write
2. [Token](https://docs.uniswap.org/api/subgraph/subgraphs-devs/schemas/token) - Read/Create & Write

#### Contracts

1. [Pool (Template)](https://docs.uniswap.org/api/subgraph/subgraphs-devs/contracts/pool) - Create

#### ABI Dependencies:

1. pool.json
2. ERC20.json

#### Dependencies:

1. [POOL_MAPPINGS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/poolMapping.ts#pool_mappings)
2. [ZERO_BD](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bd)
3. [ZERO_BI](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts#zero_bi)
4. [populateToken()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populatetoken)
5. [WHITELIST_TOKENS](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts#whitelist_tokens)
6. [convertTokenToDecimal()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts#converttokentodecimal)

#### Invoked at:

1. [handlePoolCreated()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts#handlepoolcreated)

[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Functions](https://docs.uniswap.org/category/functions)[Pool Mapping](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/poolMapping.ts)

# Pool Mapping

Only in Optimism

The file is present in Optimism only

### POOL_MAPPINGS

The table captures pool addresses pre-regenesis provided by the Optimism team. This is needed as subgraph indexer has no knowledge for pre-regenesis events.

| Old Address                                | New Address                                | Token0 Address                             | Token1 Address                             |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |
| 0x8c505fd76eed0945699265c7c7e5bbf756b7e5ad | 0x03af20bdaaffb4cc0a521796a223f7d85e2aac31 | 0x4200000000000000000000000000000000000006 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x8c505fd76eed0945699265c7c7e5bbf756b7e5ad | 0x827f0a2a4376bc26729f398b865f424dc8456841 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xdd54251a35078ba39e3ad5fb059f9aa243693b9d | 0x73b14a78a0d396c521f954532d43fd5ffe385216 | 0x4200000000000000000000000000000000000006 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0x0ad1af4178e17d7f41dbcdf9d573701bef5eb501 | 0xdd0c6bae8ad5998c358b823df15a2a4181da1b80 | 0x4200000000000000000000000000000000000006 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xdf42e37f057c61765fe7204642c4d2e5ff929cfe | 0x815ae7bf44dda74ed9274377ed711efc8b567911 | 0x4200000000000000000000000000000000000006 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x6b952bfbfda057a7f288edaa9f611cd446ddbe22 | 0x95d9d28606ee55de7667f0f176ebfc3215cfd9c0 | 0x4200000000000000000000000000000000000006 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x0bec645f0373750fe0256ee0e7b06d63eae5e04d | 0x2df05e4cdbd758cb1a99a34bb0d767e040d6b078 | 0x4200000000000000000000000000000000000006 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x6afd8618459729da24ee36978567fb04fe5fd1bd | 0x85c31ffa3706d1cce9d525a00f1c7d4a2911754c | 0x4200000000000000000000000000000000000006 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0xa61dea82c7c3e64a6a80550aacb251eed604b46b | 0x37ffd11972128fd624337ebceb167c8c0a5115ff | 0x4200000000000000000000000000000000000006 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0xcf438c19332d507326210da527fb9cf792fd3e18 | 0xc858a329bf053be78d6239c4a4343b8fbd21472b | 0x4200000000000000000000000000000000000006 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xaddd011cb3b61d0dc4f85c2661cc9bd1bd640067 | 0xb29a022ff4b37bdfb21e5f1daff4af5a22aa9510 | 0x4200000000000000000000000000000000000006 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0x47516ccba929c607e14dbd02f2ebac1e7960b1f8 | 0x0392b358ce4547601befa962680bede836606ae2 | 0x4200000000000000000000000000000000000006 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0x13b2d83ec506b5c770f64ee0f564ff9719c74071 | 0xfea834a5c47b923add607cc5b96288d18ffb9c3f | 0x4200000000000000000000000000000000000006 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0xd20bf925e04933ff79274479009218dedab6657f | 0xac721d2e27ca148f505b5106fc95e594c78ace5b | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x7678f1e1ed90efec8757af161ab25bf1e8e00238 | 0xa13514b5444e50067f6e48c386016b211773cf9e | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x2816913eda0010af856d323724f521fb702a25a7 | 0xcf2aebb91fec906f51fc11cd57035a09d8b16965 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x2419a5fee0f8e0192869507ed6a301382ad9edda | 0xea0f33940eb221aaad9360891cab08ef4f1f0703 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x0ccf6bf2df83d250d0f6a636215ef7d19f86dd01 | 0x703eb589321f3dc7408e9dde01b790e64a9fe4e9 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x1135e9ce18373238c77ff602a9b0a579ca86eb8e | 0xc22662b904d98e45f89e030201355c3e372cc819 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x2f5ccaf670e9c5f4336c127a29fdd4932f238069 | 0x1aa9b4d9933ff96b2011fddd764240d4a16b7c07 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x0f641370eb5cb4f0b0d58140d5fb2f97ffcbfce5 | 0x2459023a29d3b07711b8b916d86aa7e8a14747af | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xa14e5b3ba5dd981b536e0950390b03972b795018 | 0xadb35413ec50e0afe41039eac8b930d313e94fa4 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xbdb9a8279a525bafe9be7efb9b5df79b18eeb23f | 0x84eb2c5c23999b3ddc87be10f15ccec5d22c7d97 | 0x4200000000000000000000000000000000000006 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xa194977b416f082f71a0362041b57208c91ee1c1 | 0x2e80d5a7b3c613d854ee43243ff09808108561eb | 0x4200000000000000000000000000000000000006 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xc3099d7fd3fc7d4feea11911fbe6eadc94c7c07a | 0x3d44cc727fe2f603e4929be164c70edb3b498b5f | 0x4200000000000000000000000000000000000006 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xfe901e734c8c55645731acd4eb0be963d2a85b94 | 0xa588c9d2884c60b098c5ad028ec2f4a1fab772b5 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0xeaa5ba3ef450887e4d5a627700aef3c1a16d4090 | 0xc53f2be3331926d2f30ee2b10362bb45fdbe7bf6 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0x263312f667279452ad44cda7971fe93f18b6dad4 | 0x0843e0f56b9e7fdc4fb95fabba22a01ef4088f41 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x051580636f94b8b6ba69b879958939d324d8f650 | 0x8184f5cf4921558c201923ef6d7d5258a6efa31f | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xbb8a699cbd6b45f7c31dcd14bd6d965ab4293e2c | 0x8b057f0ccd9fb78f688472574cf3f9d2322f5454 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x98fd8560e184136f482054c19a63e644240e30f4 | 0x9f08065dfc4817a0a56db7bcab757e86399bc51d | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xbeafe824395fff8df37c4814e8de9d455e79cdad | 0x7628784d2c5d47fcd5479ba812343b1aabad6484 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xcfe7288e10994555ca97dfa2d0c50e55a4d4dc39 | 0xceb488e01c8e2e669c40b330bfc1440921c9ebe2 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0x4cff717ff0b0a4a3578e8bbb7a5f06d32574238b | 0x25e412992634b93a025e2a538c53222a8c62e2d6 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0x072611197970d6a9e57680f97f177ff947f09139 | 0xc0f184c6c4832b3ed861bd5b05722792ffa64abd | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0x380ff418bf1589b46e9660c6b2197b4ce8ae8a12 | 0xf046d8b7365d8abe5a8f8301c669b4b5284fc21d | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xac8c823548f13874dcfc76029089de01f4adc1d3 | 0x1f2390484dfe2d8900bc91c7111d274b7b2d63a1 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x8cf0a5fdcaed0956a3221e1dd5219bb14f092595 | 0xa0959d2dcd9dd56bf080a10cfe29eeb401344e3d | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xaf00e47d2fe45befc4540fe02a87cb053e252065 | 0x30be2fff09fcd820a1d472e646bd233dbd812133 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x00a0e3cd857a7e5676c901bd349ed1d6afb59fb3 | 0x3202c46666e774b44ba463eafaa6da9a968a058f | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x4200000000000000000000000000000000000006 |
| 0x90fc3f5f84fb868b7693b1f2690b91f28c1600d0 | 0x85e8d0fddf559a57aac6404e7695142cd53eb808 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0xc87adb8ac31434e96b429ced522ed84a2ce707a6 | 0x22fc5dc36811d15fafde7cc7900ae73a538e59e0 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x466fd9d58bdd0e246cbe9112d95d077b81b341af | 0xe7ee03b72a89f87d161425e42548bd5492d06679 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x7b6467b86878b86163bcb3162d84e34ea5c7389b | 0xfe1bd31a79163d6277ab8c2917d7857c225db065 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xc24383ba6d156706864a48f50fc01e89c0bf11d7 | 0xbf595eb9a512b1c274125264aef84a2847158eb3 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0x93d9dfb5caf591df911b251db4d76cd95f4644b7 | 0x124657e5bb6afc12a15c439d08fc80070f9a1a1e | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x36c95ae265883c2b19e61997760b110cc05e4a60 | 0xd6101cda1a51924e249132cbcae82bfcd0a91fbc | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xd515990647c39c4a0b8c03f811f9b746958a0eec | 0x19ea026886cbb7a900ecb2458636d72b5cae223b | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x4200000000000000000000000000000000000006 |
| 0x3b6479c7748eb5b143a3a52d237c0097734b811b | 0x5aacc66073cb0c3064353f1441c2e04170b4dbbf | 0x4200000000000000000000000000000000000006 | 0xc5Db22719A06418028A40A9B5E9A7c02959D0d08 |
| 0x2d073707207098cc69e8e86c6a3fd12644b8a1b2 | 0x4284b21e76d1b3977cab8f0032867e00e6eea382 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0xc5Db22719A06418028A40A9B5E9A7c02959D0d08 |
| 0x015986c7074ec1eeae0387a8baf485fd9d811b7d | 0x2f10a1a3e640ad1615cbedf95a1749a4af88cbc0 | 0xB548f63D4405466B36C0c0aC3318a22fDcec711a | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x4a88e6fa2afad460befd586fc1581f322308c490 | 0x32846ede08688d10a9da59387707a8fbb0790fa7 | 0x4200000000000000000000000000000000000006 | 0xab7bAdEF82E9Fe11f6f33f87BC9bC2AA27F2fCB5 |
| 0xccf24898ca659afa8cb6a3bdb8a2e0a2debda12d | 0xbdb6371fffc1753b33b87c68c827eb7978670515 | 0x4200000000000000000000000000000000000006 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 |
| 0x856d50c587824f84de481ea706208b03db38f6f2 | 0x2eee8ed7df992f23d7554b0db8835d483cce901c | 0x298B9B95708152ff6968aafd889c6586e9169f1D | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0xe3d8cfc3a0b43d2288b3da41563b1fe0623209de | 0x65dc095b35679005229896566928f6852948092b | 0x298B9B95708152ff6968aafd889c6586e9169f1D | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 |
| 0x62196490fcf045437e5e4cb49228bbd778b7196d | 0x2d6497dd08a1620d386ce708edac50aaec332415 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0xe405de8f52ba7559f9df3c368500b6e6ae6cee49 |
| 0x3b1f6287be238c9b0a4b48d85d2359d58aaa9683 | 0x039ae8860fbfdf61f654b1a5b55cc3aa753f5842 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x91e50b184ea237b3da1c005ee5d2a17a904a34c6 | 0x24342b5d46f69ba05c09becdd00e5324f9f0f7ca | 0x298B9B95708152ff6968aafd889c6586e9169f1D | 0x4200000000000000000000000000000000000006 |
| 0x518767d8ef1acffd978581c16789f8a2803f9bef | 0xf0d0e52da1fdde512af299f3d8ea1c5e3bebb96f | 0x4200000000000000000000000000000000000006 | 0xe3C332a5DcE0e1d9bC2cC72A68437790570C28a4 |
| 0xc2c0786e85ac9b0b223966d040ebc641fa44225e | 0xb589969d38ce76d3d7aa319de7133bc9755fd840 | 0x4200000000000000000000000000000000000006 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0xa2389a4ee391b4b04ae8dc664664190f3d28f2fe | 0x8eda97883a1bc02cf68c6b9fb996e06ed8fdb3e5 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xf9ca53854d1ac7adb43d9447aa87f17fe1454e31 | 0x100bdc1431a9b09c61c0efc5776814285f8fb248 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x4893c5f29301cfd7a6527331f3e06ea82e68a952 | 0xe229ce1cdbea9983362ca29f0f0b2c70bb2dacdf | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xf2e805fe3b15297e1df03b6036d01b32ab8f7998 | 0xd9b160620447d9a9a6ca90c0450f5490e5219257 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x6663eea65669978481bae55814cbc496acd50352 | 0x1179b19438a622fe36be5f9c073b700420384397 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x7bbc5726e6c2640ed0f0fda1546dc232dc5db89c | 0xf3f3433c3a97f70349c138ada81da4d3554982db | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x0d4294ae819ff83a4e2a99db8d06cdd025c19218 | 0x85149247691df622eaf1a8bd0cafd40bc45154a9 | 0x4200000000000000000000000000000000000006 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0x9e845c705aba9a2ca6e97c2423797e18a98d34c0 | 0x6fa1ea0ccbbe9b2ad52440c88a47b5d73cd9a731 | 0x298B9B95708152ff6968aafd889c6586e9169f1D | 0x4200000000000000000000000000000000000006 |
| 0x00a4dfb447a43a583d8e07eae9d4efbb3656cbcb | 0xad4c666fc170b468b19988959eb931a3676f0e9f | 0x4200000000000000000000000000000000000006 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 |
| 0xdeb1106b510d94df3bcc55e74f51a6f6b231d97e | 0x4983691a26d55eb9e18d2e12e3b770cdd3f76a5f | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xd2243a43813cd7c4bfb2287f32d3989b0f2f67d5 | 0x8e2eaef2c05ef93f424a8324b94e725eaa362f91 | 0x4200000000000000000000000000000000000006 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 |
| 0x0b3a6896345b68539571aab140134630151ebc68 | 0x8531e48a8611729185be9eaad945acbd6b32e256 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x4200000000000000000000000000000000000006 |
| 0x99959743247f2fa2e97b33e532337eae616beeda | 0xeb1817b708415f4f78c5f0c99cbbd6a3a899fa6d | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x94ee41af02171d6dc1e05b790de547fa50dbd7cf | 0x26e7fed14a97e0c482a302237971cf1b04f6d3e9 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x7613311fbb6a4580cdd602f9978c317b2a783d5f | 0x3926a81afe5c9c3d05296e4fac4728ba5411ac78 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x89fe55759966831d747669bfbda477ebf09475d6 | 0x7a5ea63fe3430a3b9a06fd80a4a9afaa17c1e878 | 0x4200000000000000000000000000000000000006 | 0xB27E3Eab7526bF721ea8029bFcd3fDc94c4f8b5b |
| 0x1c536614fd8ed5faba94528782fbc886c426651a | 0xf5a389030a565c13d6e6bbe9342ac9d31dc7521a | 0x4200000000000000000000000000000000000006 | 0xe405de8f52ba7559f9df3c368500b6e6ae6cee49 |
| 0xb0e9a44258cce8ef36c87e8f252aa6bf7cd4b245 | 0x6168ec836d0b1f0c37381ec7ed1891a412872121 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0xcd7b42cee81a3394ee58dab93bbfc87cab03adb5 | 0x2024c394741a5301e89a375b7bf52f865bc166fd | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0x88f8cd42570f74ff3ef5acd090419070c6efe37a | 0x91cca461ee9435848ac0da8fc416ad0816272786 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0xd4bbfe5b58381ba4b9ce87146ce9e5a2d1057d3e | 0x865d39d66dee5719e6bee98885ef40b9a36bf56e | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0x94b008aA00579c1307B0EF2c499aD98a8ce58e58 |
| 0x9b8ad5085af53eff13f3ddadcafa453549f7a93f | 0x1fff624960ff9d0556420f3647d6aaf06389aab1 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0x188530f0c09e56e6e30dd5ef76a9b3f0dc403763 | 0xc8c07386e29f3f239b91019d5426ae139c5bd17b | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6 |
| 0x704baee64df71741cf3029652dc99101adc846f0 | 0x1b19825a9e32b1039080acb1e1f9271314938b96 | 0x7FB688CCf682d58f86D7e38e03f9D22e7705448B | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0xe4decbe898a6b8bb79ac48e93681cd04d7b1ca1b | 0x602a4d0f9e8d40ad3f620050efd1690da908dc0d | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x7FB688CCf682d58f86D7e38e03f9D22e7705448B |
| 0x251144c131413a5f6e54001cb586f9101b447059 | 0x345ddb5743859efce0e6e8293ebd35373d34b6c7 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0xe405de8f52ba7559f9df3c368500b6e6ae6cee49 |
| 0x4065c249115481baaec5c6a16929592935d29ec1 | 0x94ad9a19126ebb02dda874237e5820fd4943f5de | 0x4200000000000000000000000000000000000006 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0x6c66eb2798bf42455b63cff3fa3e5bcc3d31848f | 0x905707e5c7a10e8351bbd03347be8b5f5de7301a | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 |
| 0xa0eed53ea02a174e4ee81d88d3970b5198580b52 | 0x7d1602f342787f80aef458c10e741149a1697447 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 |
| 0xb61a5a79a83ff386dbe40a1bc95578856ab2fa5f | 0xa7bb0d95c6ba0ed0aca70c503b34bc7108589a47 | 0x68f180fcCe6836688e9084f035309E29Bf0A2095 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0xc102e1de27d8467589cc65f4b4b18d534f6fdac6 | 0xb0eca217602b031e03956553fb510085c9f2df28 | 0x4200000000000000000000000000000000000006 | 0x8F69Ee043d52161Fd29137AeDf63f5e70cd504D5 |
| 0x61057f7f7c2e338c36fd29433d7977b618348cd0 | 0x320616dbe138aa2f3db7a5a46ba79a13032cc5f2 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0x05c1d7c9b9b4f1c38859681bd7b4eebb4c373a8e | 0xba213008fe93b3591e439f3b2aa51b3e4a2bd7c7 | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 |
| 0xbf592a3a4c64c8c28b667d060336e25480fe6c48 | 0x680b4eb8b9b8533d503a545adad4af9f00df5f05 | 0x4200000000000000000000000000000000000006 | 0x7C17611Ed67D562D1F00ce82eebD39Cb7B595472 |
| 0xb2ab739b499ff9fa019ff944135b4974942b3a95 | 0x296b88b607ea3a03c821ca4dc34dd9e7e4efa041 | 0x4200000000000000000000000000000000000006 | 0x7FB688CCf682d58f86D7e38e03f9D22e7705448B |
| 0x3e9ef76529932226742113984e6a6c7cea7e2452 | 0xa99638e4ac81d4ce32c945c1415f89ab8d86bf2c | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9 |
| 0xcb590932a77e02aac00c83bbba4d8014efbebb89 | 0x9bb3267c4c3e69a961479c475f8fcc4c300af5bd | 0x4200000000000000000000000000000000000006 | 0x7FB688CCf682d58f86D7e38e03f9D22e7705448B |
| 0x3643c5840fc0ccf4f667a35a151e10302d4d0d23 | 0x65f8a80d8049a77619435f841055fa4c8d785c47 | 0x4200000000000000000000000000000000000006 | 0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6 |
| 0x805b9cf595282d807adfe84a89bec85be5d07f53 | 0xd3265ea86af798659b4132a453e7cdb29b877e10 | 0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6 | 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1 |
| 0x1a718270a5b014209fb77ac2985556ee471b29af | 0x8dfc59e8b119bffa5f552642028e005b1972edc4 | 0x6fd9d7AD17242c41f7131d257212c54A0e816691 | 0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6 |
| 0xb91cf01b64c6e6540c45ae356554599cbe92831f | 0xc210aeb4e84e0c3b6ee5816858984d52d04f0219 | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6 |
| 0x8956827b23063c82d0c697004f0015b454a2f107 | 0x9aaa481a863e95168c01f23640b357b014dff09a | 0x7F5c764cBc14f9669B88837ca1490cCa17c31607 | 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4 |
| 0x86cf7e458ce79afe44924263d58ef1fd57d1b57c | 0x25cc77a38f8de3b9b090fea8f0f5995c4e10a386 | 0x4200000000000000000000000000000000000006 | 0xe0BB0D3DE8c10976511e5030cA403dBf4c25165B |

#### References At:

1. [populateEmptyPools()](https://docs.uniswap.org/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts#populateemptypools)



[APIs](https://docs.uniswap.org/api/subgraph/overview)SubgraphSubgraph-Devs[Subgraph Configuration](https://docs.uniswap.org/api/subgraph/subgraphs-devs/subgraph-configs)

# Subgraph Configuration

### Subgraphs

info

The subgraphs link are picked from the clients specified in [v3-info](https://github.com/Uniswap/v3-info/blob/master/src/apollo/client.ts)

| Subgraph                                                     | Code Branch Referred                                         | Graft Base                                     | Graft Block | NFT Position Manager Address               | NFT Position Manager Start Block |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------- | ----------- | ------------------------------------------ | -------------------------------- |
| [Mainnet](https://thegraph.com/hosted-service/subgraph/uniswap/uniswap-v3) | [main](https://github.com/Uniswap/v3-subgraph/tree/main)     | QmS13421u6qsbVdBCrZhdRaZw2wH67drwF3urmueJvvJ5P | 13591197    | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 12369651                         |
| [Polygon](https://thegraph.com/hosted-service/subgraph/ianlapham/uniswap-v3-polygon) | [polygon](https://github.com/Uniswap/v3-subgraph/tree/polygon) | QmUKRxaVLRpn18UA9mwukAwRQudH9TfBW5wiKCWEJghUS8 | 25459720    | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 22760586                         |
| [Arbitrum-One](https://thegraph.com/hosted-service/subgraph/ianlapham/uniswap-arbitrum-one) | [arbitrum-minimal](https://github.com/Uniswap/v3-subgraph/tree/arbitrum-minimal) | None                                           | None        | None                                       | None                             |
| [Optimism](https://thegraph.com/hosted-service/subgraph/ianlapham/optimism-post-regenesis) | [ian/optimism-fix](https://github.com/Uniswap/v3-subgraph/tree/ian/optimism-fix) | Qmf9i13TJknQwcamcLbb75hEhbf3nqDi321XWhtFBj3P5s | 10028767    | 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 | 0                                |



[LLMs](https://docs.uniswap.org/llms/overview)

# LLMs and AI Integration

Large Language Models (LLMs) and AI tools can help developers better understand and work with the Uniswap Protocol. This section provides resources and guidance for leveraging AI assistance when building on Uniswap.

## AI-Powered Documentation

The Uniswap documentation is designed to work seamlessly with modern AI tools to provide enhanced developer support and assistance.

### Getting AI Help

Use the built-in AI integration features throughout the documentation:

- **Copy to AI**: Use the dropdown button on any documentation page to quickly get AI assistance
- **Context-Aware**: AI tools receive relevant documentation context for better responses
- **Multiple Platforms**: Integrate with popular AI assistants like Claude and ChatGPT

## LLMs.txt

This documentation includes an [LLMs.txt file](https://docs.uniswap.org/assets/files/llms-0535f49abd170e69dc72fdc37b81dff2.txt) that provides comprehensive context about Uniswap for AI systems. This file helps ensure AI assistants can provide accurate and up-to-date information about:

- Protocol architecture and concepts
- Smart contract interfaces and functionality
- SDK usage and integration patterns
- Development best practices

## Best Practices for AI-Assisted Development

When using AI tools for Uniswap development:

1. **Provide Context**: Always include relevant protocol version (v2, v3, v4) in your queries
2. **Verify Code**: Always test and verify AI-generated code before deployment
3. **Reference Documentation**: Cross-check AI responses against official documentation
4. **Security First**: Have AI-generated smart contracts audited before production use

## Supported AI Platforms

The documentation provides optimized integration with:

- **Claude**: Advanced reasoning for complex DeFi concepts
- **ChatGPT**: Code generation and debugging assistance
- **Other LLMs**: Compatible with any AI tool that supports context injection

## Contributing AI Resources

Help improve AI assistance for the Uniswap community by:

- Reporting AI-generated errors or inaccuracies
- Suggesting improvements to the LLMs.txt context file
- Contributing examples of effective AI prompts for Uniswap development



**LLMs.txt**

```
# Uniswap Documentation - LLM Context File

This file provides structured context for Large Language Models about the Uniswap Protocol documentation.

## About Uniswap

Uniswap is a decentralized exchange protocol built on Ethereum that enables users to swap ERC-20 tokens without intermediaries. The protocol uses an automated market maker (AMM) model with liquidity pools rather than order books.

## Current Protocol Versions

### Uniswap v4 (Latest)
- **Status**: Recently launched, actively developed
- **Key Features**: Hooks, singleton architecture, flash accounting, custom pools
- **Documentation**: `/contracts/v4/`, `/sdk/v4/`
- **Major Innovation**: Hooks system allows custom logic in pools

### Uniswap v3
- **Status**: Mature, widely used
- **Key Features**: Concentrated liquidity, multiple fee tiers, NFT positions
- **Documentation**: `/contracts/v3/`, `/sdk/v3/`
- **Innovation**: Capital efficiency through concentrated liquidity

### Uniswap v2
- **Status**: Legacy, still functional
- **Key Features**: Simple AMM, fixed liquidity ranges
- **Documentation**: `/contracts/v2/`, `/sdk/v2/`

## Documentation Structure

### Core Concepts (`/concepts/`)
- Protocol overview and fundamentals
- How AMMs work
- Liquidity provision concepts
- Governance and tokenomics

### Smart Contracts (`/contracts/`)
- **v4**: Latest contract documentation, hooks, examples
- **v3**: Core contracts, periphery contracts, guides
- **v2**: Legacy contract documentation
- **UniswapX**: Intent-based trading protocol

### SDKs (`/sdk/`)
- **v4-SDK**: TypeScript SDK for v4 integration
- **v3-SDK**: Comprehensive TypeScript SDK for v3
- **v2-SDK**: Legacy SDK for v2

### APIs (`/api/`)
- **Subgraph**: GraphQL API for querying protocol data
- **Routing API**: For finding optimal swap routes

## Key Topics by Category

### For Developers
1. **Getting Started**: Protocol basics, choosing versions
2. **Integration**: SDK usage, contract interactions
3. **Advanced**: Custom hooks, flash loans, arbitrage

### For Liquidity Providers
1. **Concepts**: Impermanent loss, fee earnings, ranges
2. **Strategies**: Position management, rebalancing
3. **Risk Management**: Price impact, slippage

### For Traders
1. **Swapping**: How trades work, routing, slippage
2. **Advanced Trading**: MEV protection, limit orders
3. **Interfaces**: Web app usage, integration options

## Technical Implementation Details

### Smart Contracts
- **Core Contracts**: Factory, Pool, Router patterns
- **Security**: Audits, formal verification, testing
- **Gas Optimization**: Efficient operations, batch transactions

### Integration Patterns
- **Direct Integration**: Contract-to-contract calls
- **SDK Integration**: TypeScript/JavaScript applications
- **Subgraph Queries**: Data fetching and analytics

### Common Use Cases
1. **DeFi Protocols**: Integrating swaps into other protocols
2. **Wallets**: Adding swap functionality
3. **Arbitrage Bots**: MEV and price difference exploitation
4. **Analytics**: Protocol metrics and user behavior

## Version Migration Guides

### v2 to v3 Migration
- Concentrated liquidity concepts
- Position management differences
- Fee tier selection

### v3 to v4 Migration  
- Hooks architecture understanding
- Singleton pattern benefits
- Gas efficiency improvements

## Ecosystem and Governance

### Uniswap Foundation
- Ecosystem growth and grants
- Community governance support
- Research and development funding

### Uniswap Labs
- Core protocol development
- Interface development
- Commercial applications

### Governance
- UNI token voting
- Proposal processes
- Community decision making

## Common Issues and Solutions

### Integration Challenges
1. **Slippage Management**: Setting appropriate tolerances
2. **MEV Protection**: Using private mempools, flashbots
3. **Gas Optimization**: Batch operations, efficient routing

### Development Pitfalls
1. **Price Manipulation**: Using time-weighted averages
2. **Reentrancy**: Proper security patterns
3. **Oracle Usage**: Avoiding price manipulation

## Resources and References

### Official Links
- Main Protocol: https://uniswap.org
- Documentation: https://docs.uniswap.org
- GitHub: https://github.com/Uniswap
- Governance: https://gov.uniswap.org

### Community
- Discord: https://discord.gg/uniswap
- Twitter: https://twitter.com/Uniswap
- Research Forum: https://gov.uniswap.org

### Developer Tools
- Interface: https://app.uniswap.org
- Analytics: https://info.uniswap.org
- Subgraph: TheGraph hosted service

## AI Assistant Guidelines

When helping users with Uniswap-related questions:

1. **Version Awareness**: Always clarify which version (v2/v3/v4) the user needs
2. **Security First**: Emphasize security best practices, audits, testing
3. **Gas Efficiency**: Consider gas costs in recommendations
4. **Latest Updates**: v4 is the newest with hooks - recommend for new projects
5. **Integration Complexity**: Start with SDK examples before low-level contracts
6. **Risk Disclosure**: Always mention risks like impermanent loss, smart contract risks

## Recent Updates and Changes

- **v4 Launch**: New hooks system, singleton architecture
- **UniswapX**: Intent-based trading protocol
- **Mobile Interface**: Improved mobile trading experience
- **Governance Evolution**: Continued decentralization efforts

This documentation covers a comprehensive DeFi protocol with multiple versions, extensive developer tools, and active community governance. Always refer users to the most recent documentation and emphasize security best practices.
```








